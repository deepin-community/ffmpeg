From 2eb6cdc7e5f5b2e507d1a0a6aef4d6570218968a Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 27 Dec 2023 22:51:23 +0800
Subject: [PATCH 001/103] lavu: add NV15 format support

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/pixdesc.c | 12 ++++++++++++
 libavutil/pixfmt.h  |  2 ++
 2 files changed, 14 insertions(+)

diff --git a/libavutil/pixdesc.c b/libavutil/pixdesc.c
index 6ded9467b0a..27f052400f6 100644
--- a/libavutil/pixdesc.c
+++ b/libavutil/pixdesc.c
@@ -2793,6 +2793,18 @@ static const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = {
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
+    [AV_PIX_FMT_NV15] = {
+        .name = "nv15",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .comp = {
+            { 0, 10,  0, 0, 10 },      /* Y */
+            { 1, 20,  0, 0, 10 },      /* U */
+            { 1, 20, 10, 0, 10 },      /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BITSTREAM,
+    },
 };
 
 static const char * const color_range_names[] = {
diff --git a/libavutil/pixfmt.h b/libavutil/pixfmt.h
index a26c72d56be..9c6cd4fb6ad 100644
--- a/libavutil/pixfmt.h
+++ b/libavutil/pixfmt.h
@@ -429,6 +429,8 @@ enum AVPixelFormat {
     AV_PIX_FMT_GBRAP14BE,  ///< planar GBR 4:4:4:4 56bpp, big-endian
     AV_PIX_FMT_GBRAP14LE,  ///< planar GBR 4:4:4:4 56bpp, little-endian
 
+    AV_PIX_FMT_NV15,        ///< like P010, but has no zero padding bits, 15bpp, little-endian
+
     AV_PIX_FMT_NB         ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 

From 529fe6e12e821ffa95f5c3102bc453516212ce50 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 27 Dec 2023 22:52:46 +0800
Subject: [PATCH 002/103] lsws/input: add NV15 and NV20 formats support

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libswscale/input.c               | 41 ++++++++++++++++++++++++++++++++
 libswscale/utils.c               |  2 ++
 tests/ref/fate/imgutils          |  1 +
 tests/ref/fate/sws-pixdesc-query |  5 ++++
 4 files changed, 49 insertions(+)

diff --git a/libswscale/input.c b/libswscale/input.c
index d171394bb27..c3b21bc980b 100644
--- a/libswscale/input.c
+++ b/libswscale/input.c
@@ -793,6 +793,39 @@ static void nv21ToUV_c(uint8_t *dstU, uint8_t *dstV,
     nvXXtoUV_c(dstV, dstU, src1, width);
 }
 
+static av_always_inline void nv15_20ToYUV_c(uint16_t *dst, const uint8_t *src,
+                                            int dst_pos, int src_pos)
+{
+    int shift = (src_pos << 1) & 7;
+    src_pos = (src_pos * 10) >> 3;
+    AV_WN16(dst + dst_pos,
+            ((AV_RL16(src + src_pos) >> shift) |
+             (AV_RL16(src + src_pos + 1) << (8 - shift))) & 0x3FF);
+}
+
+static void nv15_20ToY_c(uint8_t *_dst, const uint8_t *_src, const uint8_t *unused1,
+                         const uint8_t *unused2, int width, uint32_t *unused, void *opq)
+{
+    int i;
+    const uint8_t *src = (const uint8_t *)_src;
+    uint16_t *dst      = (uint16_t *)_dst;
+    for (i = 0; i < width; i++)
+        nv15_20ToYUV_c(dst, src, i, i);
+}
+
+static void nv15_20ToUV_c(uint8_t *_dstU, uint8_t *_dstV,
+                          const uint8_t *unused0, const uint8_t *_src1, const uint8_t *_src2,
+                          int width, uint32_t *unused, void *opq)
+{
+    int i;
+    const uint8_t *src1 = (const uint8_t *)_src1;
+    uint16_t *dstU      = (uint16_t *)_dstU, *dstV = (uint16_t *)_dstV;
+    for (i = 0; i < width; i++) {
+        nv15_20ToYUV_c(dstU, src1, i, 2 * i);
+        nv15_20ToYUV_c(dstV, src1, i, 2 * i + 1);
+    }
+}
+
 #define p01x_uv_wrapper(bits, shift) \
     static void p0 ## bits ## LEToUV_c(uint8_t *dstU, uint8_t *dstV,     \
                                        const uint8_t *unused0,           \
@@ -1444,6 +1477,10 @@ av_cold void ff_sws_init_input_funcs(SwsContext *c)
     case AV_PIX_FMT_XV36LE:
         c->chrToYV12 = read_xv36le_UV_c;
         break;
+    case AV_PIX_FMT_NV15:
+    case AV_PIX_FMT_NV20:
+        c->chrToYV12 = nv15_20ToUV_c;
+        break;
     case AV_PIX_FMT_P010LE:
     case AV_PIX_FMT_P210LE:
     case AV_PIX_FMT_P410LE:
@@ -1944,6 +1981,10 @@ av_cold void ff_sws_init_input_funcs(SwsContext *c)
     case AV_PIX_FMT_BGRA64LE:
         c->lumToYV12 = bgr64LEToY_c;
         break;
+    case AV_PIX_FMT_NV15:
+    case AV_PIX_FMT_NV20:
+        c->lumToYV12 = nv15_20ToY_c;
+        break;
     case AV_PIX_FMT_P010LE:
     case AV_PIX_FMT_P210LE:
     case AV_PIX_FMT_P410LE:
diff --git a/libswscale/utils.c b/libswscale/utils.c
index e1ad6859722..61efe702bd9 100644
--- a/libswscale/utils.c
+++ b/libswscale/utils.c
@@ -230,6 +230,8 @@ static const FormatEntry format_entries[] = {
     [AV_PIX_FMT_XYZ12BE]     = { 1, 1, 1 },
     [AV_PIX_FMT_XYZ12LE]     = { 1, 1, 1 },
     [AV_PIX_FMT_AYUV64LE]    = { 1, 1},
+    [AV_PIX_FMT_NV15]        = { 1, 0 },
+    [AV_PIX_FMT_NV20]        = { 1, 0 },
     [AV_PIX_FMT_P010LE]      = { 1, 1 },
     [AV_PIX_FMT_P010BE]      = { 1, 1 },
     [AV_PIX_FMT_P012LE]      = { 1, 1 },
diff --git a/tests/ref/fate/imgutils b/tests/ref/fate/imgutils
index f166cb67fb5..62de71ddb9d 100644
--- a/tests/ref/fate/imgutils
+++ b/tests/ref/fate/imgutils
@@ -268,3 +268,4 @@ p412be          planes: 2, linesizes: 128 256   0   0, plane_sizes:  6144 12288
 p412le          planes: 2, linesizes: 128 256   0   0, plane_sizes:  6144 12288     0     0, plane_offsets:  6144     0     0, total_size: 18432
 gbrap14be       planes: 4, linesizes: 128 128 128 128, plane_sizes:  6144  6144  6144  6144, plane_offsets:  6144  6144  6144, total_size: 24576
 gbrap14le       planes: 4, linesizes: 128 128 128 128, plane_sizes:  6144  6144  6144  6144, plane_offsets:  6144  6144  6144, total_size: 24576
+nv15            planes: 2, linesizes:  80  80   0   0, plane_sizes:  3840  1920     0     0, plane_offsets:  3840     0     0, total_size: 5760
diff --git a/tests/ref/fate/sws-pixdesc-query b/tests/ref/fate/sws-pixdesc-query
index fff93bbf0ef..c89434fc0b9 100644
--- a/tests/ref/fate/sws-pixdesc-query
+++ b/tests/ref/fate/sws-pixdesc-query
@@ -61,6 +61,7 @@ isNBPS:
   gray14le
   gray9be
   gray9le
+  nv15
   nv20be
   nv20le
   p010be
@@ -221,6 +222,7 @@ isYUV:
   ayuv64be
   ayuv64le
   nv12
+  nv15
   nv16
   nv20be
   nv20le
@@ -337,6 +339,7 @@ isYUV:
 
 isPlanarYUV:
   nv12
+  nv15
   nv16
   nv20be
   nv20le
@@ -434,6 +437,7 @@ isPlanarYUV:
 
 isSemiPlanarYUV:
   nv12
+  nv15
   nv16
   nv20be
   nv20le
@@ -868,6 +872,7 @@ Planar:
   gbrpf32be
   gbrpf32le
   nv12
+  nv15
   nv16
   nv20be
   nv20le

From c359d00d131770502deaf1c198211edcf43fa013 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 27 Dec 2023 22:54:43 +0800
Subject: [PATCH 003/103] HACK: lavu: allow image copy for NV15 and NV20

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/imgutils.c | 26 +++++++++++++++++++-------
 1 file changed, 19 insertions(+), 7 deletions(-)

diff --git a/libavutil/imgutils.c b/libavutil/imgutils.c
index da3812698e6..c703425a066 100644
--- a/libavutil/imgutils.c
+++ b/libavutil/imgutils.c
@@ -341,14 +341,12 @@ int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     return AVERROR(EINVAL);
 }
 
-static void image_copy_plane(uint8_t       *dst, ptrdiff_t dst_linesize,
-                             const uint8_t *src, ptrdiff_t src_linesize,
-                             ptrdiff_t bytewidth, int height)
+static void image_copy_plane2(uint8_t       *dst, ptrdiff_t dst_linesize,
+                              const uint8_t *src, ptrdiff_t src_linesize,
+                              ptrdiff_t bytewidth, int height)
 {
     if (!dst || !src)
         return;
-    av_assert0(FFABS(src_linesize) >= bytewidth);
-    av_assert0(FFABS(dst_linesize) >= bytewidth);
     for (;height > 0; height--) {
         memcpy(dst, src, bytewidth);
         dst += dst_linesize;
@@ -356,6 +354,19 @@ static void image_copy_plane(uint8_t       *dst, ptrdiff_t dst_linesize,
     }
 }
 
+static void image_copy_plane(uint8_t       *dst, ptrdiff_t dst_linesize,
+                             const uint8_t *src, ptrdiff_t src_linesize,
+                             ptrdiff_t bytewidth, int height)
+{
+    if (!dst || !src)
+        return;
+    av_assert0(FFABS(src_linesize) >= bytewidth);
+    av_assert0(FFABS(dst_linesize) >= bytewidth);
+    image_copy_plane2(dst, dst_linesize,
+                      src, src_linesize,
+                      bytewidth, height);
+}
+
 void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize,
                                  const uint8_t *src, ptrdiff_t src_linesize,
                                  ptrdiff_t bytewidth, int height)
@@ -424,7 +435,8 @@ void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4],
                    enum AVPixelFormat pix_fmt, int width, int height)
 {
     ptrdiff_t dst_linesizes1[4], src_linesizes1[4];
-    int i;
+    int i, is_nv15_20 = pix_fmt == AV_PIX_FMT_NV15 ||
+                        pix_fmt == AV_PIX_FMT_NV20;
 
     for (i = 0; i < 4; i++) {
         dst_linesizes1[i] = dst_linesizes[i];
@@ -432,7 +444,7 @@ void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4],
     }
 
     image_copy(dst_data, dst_linesizes1, src_data, src_linesizes1, pix_fmt,
-               width, height, image_copy_plane);
+               width, height, is_nv15_20 ? image_copy_plane2 : image_copy_plane);
 }
 
 void av_image_copy_uc_from(uint8_t * const dst_data[4], const ptrdiff_t dst_linesizes[4],

From 49cc93e8925eea1623cc6e2b0202a9a3225e11ec Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 27 Dec 2023 22:45:58 +0800
Subject: [PATCH 004/103] lavu/hwcontext_drm: preparations for RKMPP hwcontext

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_drm.h | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/libavutil/hwcontext_drm.h b/libavutil/hwcontext_drm.h
index 42709f215ef..bc50e427f65 100644
--- a/libavutil/hwcontext_drm.h
+++ b/libavutil/hwcontext_drm.h
@@ -50,6 +50,12 @@ typedef struct AVDRMObjectDescriptor {
      * DRM PRIME fd for the object.
      */
     int fd;
+    /**
+     * DRM PRIME mapped virtual ptr for above fd.
+     *
+     * The content of this buffer must be readonly when acting decoder's out buffer.
+     */
+    void *ptr;
     /**
      * Total size of the object.
      *
@@ -63,6 +69,10 @@ typedef struct AVDRMObjectDescriptor {
      * DRM_FORMAT_MOD_INVALID.
      */
     uint64_t format_modifier;
+    /**
+     * User opaque for the object.
+     */
+    void *opaque;
 } AVDRMObjectDescriptor;
 
 /**

From 570a2a53d8f41739e902f65950eebe7cebfc233b Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 27 Dec 2023 23:27:01 +0800
Subject: [PATCH 005/103] lavu: add RKMPP hwcontext

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure                      |   6 +-
 libavutil/Makefile             |   3 +
 libavutil/hwcontext.c          |   4 +
 libavutil/hwcontext.h          |   1 +
 libavutil/hwcontext_internal.h |   1 +
 libavutil/hwcontext_rkmpp.c    | 590 +++++++++++++++++++++++++++++++++
 libavutil/hwcontext_rkmpp.h    |  91 +++++
 7 files changed, 693 insertions(+), 3 deletions(-)
 create mode 100644 libavutil/hwcontext_rkmpp.c
 create mode 100644 libavutil/hwcontext_rkmpp.h

diff --git a/configure b/configure
index 1f0b9497cba..76c2188e109 100755
--- a/configure
+++ b/configure
@@ -3883,7 +3883,7 @@ avfilter_deps="avutil"
 avfilter_suggest="libm stdatomic"
 avformat_deps="avcodec avutil"
 avformat_suggest="libm network zlib stdatomic"
-avutil_suggest="clock_gettime ffnvcodec gcrypt libm libdrm libmfx opencl openssl user32 vaapi vulkan videotoolbox corefoundation corevideo coremedia bcrypt stdatomic"
+avutil_suggest="clock_gettime ffnvcodec gcrypt libm libdrm libmfx opencl openssl rkmpp user32 vaapi vulkan videotoolbox corefoundation corevideo coremedia bcrypt stdatomic"
 postproc_deps="avutil gpl"
 postproc_suggest="libm stdatomic"
 swresample_deps="avutil"
@@ -6903,8 +6903,8 @@ enabled openssl           && { { check_pkg_config openssl "openssl >= 3.0.0" ope
                                check_lib openssl openssl/ssl.h SSL_library_init -lssl -lcrypto -lws2_32 -lgdi32 ||
                                die "ERROR: openssl not found"; }
 enabled pocketsphinx      && require_pkg_config pocketsphinx pocketsphinx pocketsphinx/pocketsphinx.h ps_init
-enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/rk_mpi.h mpp_create &&
-                               require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.7" rockchip/rk_mpi.h mpp_create &&
+enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp rockchip/rk_mpi.h mpp_create &&
+                               require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.8" rockchip/rk_mpi.h mpp_create &&
                                { enabled libdrm ||
                                  die "ERROR: rkmpp requires --enable-libdrm"; }
                              }
diff --git a/libavutil/Makefile b/libavutil/Makefile
index 4711f8cde88..c6f1ee61522 100644
--- a/libavutil/Makefile
+++ b/libavutil/Makefile
@@ -51,6 +51,7 @@ HEADERS = adler32.h                                                     \
           hwcontext_videotoolbox.h                                      \
           hwcontext_vdpau.h                                             \
           hwcontext_vulkan.h                                            \
+          hwcontext_rkmpp.h                                             \
           imgutils.h                                                    \
           intfloat.h                                                    \
           intreadwrite.h                                                \
@@ -200,6 +201,7 @@ OBJS-$(CONFIG_VAAPI)                    += hwcontext_vaapi.o
 OBJS-$(CONFIG_VIDEOTOOLBOX)             += hwcontext_videotoolbox.o
 OBJS-$(CONFIG_VDPAU)                    += hwcontext_vdpau.o
 OBJS-$(CONFIG_VULKAN)                   += hwcontext_vulkan.o vulkan.o
+OBJS-$(CONFIG_RKMPP)                    += hwcontext_rkmpp.o
 
 OBJS-$(!CONFIG_VULKAN)                  += hwcontext_stub.o
 
@@ -222,6 +224,7 @@ SKIPHEADERS-$(CONFIG_VDPAU)            += hwcontext_vdpau.h
 SKIPHEADERS-$(CONFIG_VULKAN)           += hwcontext_vulkan.h vulkan.h   \
                                           vulkan_functions.h            \
                                           vulkan_loader.h
+SKIPHEADERS-$(CONFIG_RKMPP)            += hwcontext_rkmpp.h
 
 TESTPROGS = adler32                                                     \
             aes                                                         \
diff --git a/libavutil/hwcontext.c b/libavutil/hwcontext.c
index 3650d4653aa..e1cdf3356a1 100644
--- a/libavutil/hwcontext.c
+++ b/libavutil/hwcontext.c
@@ -62,6 +62,9 @@ static const HWContextType * const hw_table[] = {
 #endif
 #if CONFIG_VULKAN
     &ff_hwcontext_type_vulkan,
+#endif
+#if CONFIG_RKMPP
+    &ff_hwcontext_type_rkmpp,
 #endif
     NULL,
 };
@@ -78,6 +81,7 @@ static const char *const hw_type_names[] = {
     [AV_HWDEVICE_TYPE_VIDEOTOOLBOX] = "videotoolbox",
     [AV_HWDEVICE_TYPE_MEDIACODEC] = "mediacodec",
     [AV_HWDEVICE_TYPE_VULKAN] = "vulkan",
+    [AV_HWDEVICE_TYPE_RKMPP] = "rkmpp",
 };
 
 enum AVHWDeviceType av_hwdevice_find_type_by_name(const char *name)
diff --git a/libavutil/hwcontext.h b/libavutil/hwcontext.h
index 7ff08c86085..d1abb200671 100644
--- a/libavutil/hwcontext.h
+++ b/libavutil/hwcontext.h
@@ -37,6 +37,7 @@ enum AVHWDeviceType {
     AV_HWDEVICE_TYPE_OPENCL,
     AV_HWDEVICE_TYPE_MEDIACODEC,
     AV_HWDEVICE_TYPE_VULKAN,
+    AV_HWDEVICE_TYPE_RKMPP,
 };
 
 typedef struct AVHWDeviceInternal AVHWDeviceInternal;
diff --git a/libavutil/hwcontext_internal.h b/libavutil/hwcontext_internal.h
index e6266494ac7..7d34581f827 100644
--- a/libavutil/hwcontext_internal.h
+++ b/libavutil/hwcontext_internal.h
@@ -174,5 +174,6 @@ extern const HWContextType ff_hwcontext_type_vdpau;
 extern const HWContextType ff_hwcontext_type_videotoolbox;
 extern const HWContextType ff_hwcontext_type_mediacodec;
 extern const HWContextType ff_hwcontext_type_vulkan;
+extern const HWContextType ff_hwcontext_type_rkmpp;
 
 #endif /* AVUTIL_HWCONTEXT_INTERNAL_H */
diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
new file mode 100644
index 00000000000..8371ccc8811
--- /dev/null
+++ b/libavutil/hwcontext_rkmpp.c
@@ -0,0 +1,590 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#define _GNU_SOURCE
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+/* This was introduced in version 4.6. And may not exist all without an
+ * optional package. So to prevent a hard dependency on needing the Linux
+ * kernel headers to compile, make this optional. */
+#if HAVE_LINUX_DMA_BUF_H
+#include <linux/dma-buf.h>
+#include <sys/ioctl.h>
+#endif
+
+#include "avassert.h"
+#include "hwcontext.h"
+#include "hwcontext_rkmpp.h"
+#include "hwcontext_internal.h"
+#include "imgutils.h"
+
+static const struct {
+    enum AVPixelFormat pixfmt;
+    uint32_t drm_format;
+} supported_formats[] = {
+    /* grayscale */
+    { AV_PIX_FMT_GRAY8,    DRM_FORMAT_R8        },
+    /* planar YUV */
+    { AV_PIX_FMT_YUV420P,  DRM_FORMAT_YUV420,   },
+    { AV_PIX_FMT_YUV422P,  DRM_FORMAT_YUV422,   },
+    { AV_PIX_FMT_YUV444P,  DRM_FORMAT_YUV444,   },
+    /* semi-planar YUV */
+    { AV_PIX_FMT_NV12,     DRM_FORMAT_NV12,     },
+    { AV_PIX_FMT_NV21,     DRM_FORMAT_NV21,     },
+    { AV_PIX_FMT_NV16,     DRM_FORMAT_NV16,     },
+    { AV_PIX_FMT_NV24,     DRM_FORMAT_NV24,     },
+    /* semi-planar YUV 10-bit */
+    { AV_PIX_FMT_P010,     DRM_FORMAT_P010,     },
+    { AV_PIX_FMT_NV15,     DRM_FORMAT_NV15,     },
+    { AV_PIX_FMT_NV20,     DRM_FORMAT_NV20,     },
+    /* packed YUV */
+    { AV_PIX_FMT_YUYV422,  DRM_FORMAT_YUYV,     },
+    { AV_PIX_FMT_YVYU422,  DRM_FORMAT_YVYU,     },
+    { AV_PIX_FMT_UYVY422,  DRM_FORMAT_UYVY,     },
+    /* packed RGB */
+    { AV_PIX_FMT_RGB555LE, DRM_FORMAT_XRGB1555, },
+    { AV_PIX_FMT_BGR555LE, DRM_FORMAT_XBGR1555, },
+    { AV_PIX_FMT_RGB565LE, DRM_FORMAT_RGB565,   },
+    { AV_PIX_FMT_BGR565LE, DRM_FORMAT_BGR565,   },
+    { AV_PIX_FMT_RGB24,    DRM_FORMAT_RGB888,   },
+    { AV_PIX_FMT_BGR24,    DRM_FORMAT_BGR888,   },
+    { AV_PIX_FMT_RGBA,     DRM_FORMAT_ABGR8888, },
+    { AV_PIX_FMT_RGB0,     DRM_FORMAT_XBGR8888, },
+    { AV_PIX_FMT_BGRA,     DRM_FORMAT_ARGB8888, },
+    { AV_PIX_FMT_BGR0,     DRM_FORMAT_XRGB8888, },
+    { AV_PIX_FMT_ARGB,     DRM_FORMAT_BGRA8888, },
+    { AV_PIX_FMT_0RGB,     DRM_FORMAT_BGRX8888, },
+    { AV_PIX_FMT_ABGR,     DRM_FORMAT_RGBA8888, },
+    { AV_PIX_FMT_0BGR,     DRM_FORMAT_RGBX8888, },
+};
+
+static int rkmpp_device_create(AVHWDeviceContext *hwdev, const char *device,
+                               AVDictionary *opts, int flags)
+{
+    AVRKMPPDeviceContext *hwctx = hwdev->hwctx;
+    AVDictionaryEntry *opt_d = NULL;
+
+    hwctx->flags = MPP_BUFFER_FLAGS_DMA32 | MPP_BUFFER_FLAGS_CACHABLE;
+
+    opt_d = av_dict_get(opts, "dma32", NULL, 0);
+    if (opt_d && !strtol(opt_d->value, NULL, 10))
+        hwctx->flags &= ~MPP_BUFFER_FLAGS_DMA32;
+
+    opt_d = av_dict_get(opts, "cacheable", NULL, 0);
+    if (opt_d && !strtol(opt_d->value, NULL, 10))
+        hwctx->flags &= ~MPP_BUFFER_FLAGS_CACHABLE;
+
+    return 0;
+}
+
+static int rkmpp_frames_get_constraints(AVHWDeviceContext *hwdev,
+                                        const void *hwconfig,
+                                        AVHWFramesConstraints *constraints)
+{
+    int i;
+
+    constraints->min_width  = 16;
+    constraints->min_height = 16;
+
+    constraints->valid_hw_formats =
+        av_malloc_array(2, sizeof(enum AVPixelFormat));
+    if (!constraints->valid_hw_formats)
+        return AVERROR(ENOMEM);
+    constraints->valid_hw_formats[0] = AV_PIX_FMT_DRM_PRIME;
+    constraints->valid_hw_formats[1] = AV_PIX_FMT_NONE;
+
+    constraints->valid_sw_formats =
+        av_malloc_array(FF_ARRAY_ELEMS(supported_formats) + 1,
+                        sizeof(enum AVPixelFormat));
+    if (!constraints->valid_sw_formats)
+        return AVERROR(ENOMEM);
+    for(i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++)
+        constraints->valid_sw_formats[i] = supported_formats[i].pixfmt;
+    constraints->valid_sw_formats[i] = AV_PIX_FMT_NONE;
+
+    return 0;
+}
+
+static void rkmpp_free_drm_frame_descriptor(AVRKMPPDeviceContext *hwctx,
+                                            AVDRMFrameDescriptor *desc)
+{
+    int i, ret;
+
+    if (!desc)
+        return;
+
+    for (i = 0; i < desc->nb_objects; i++) {
+        AVDRMObjectDescriptor *object = &desc->objects[i];
+        MppBuffer mpp_buf = (MppBuffer)object->opaque;
+
+        if (mpp_buf) {
+            ret = mpp_buffer_put(mpp_buf);
+            if (ret != MPP_OK)
+                av_log(NULL, AV_LOG_WARNING,
+                       "Failed to put MPP buffer: %d\n", ret);
+        }
+    }
+
+    memset(desc, 0, sizeof(*desc));
+    av_free(desc);
+}
+
+static void rkmpp_buffer_free(void *opaque, uint8_t *data)
+{
+    AVHWFramesContext *hwfc = opaque;
+    AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
+
+    rkmpp_free_drm_frame_descriptor(hwctx, desc);
+}
+
+static int rkmpp_get_aligned_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
+{
+    const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(pix_fmt);
+    const int is_rgb = pixdesc->flags & AV_PIX_FMT_FLAG_RGB;
+    const int is_planar = pixdesc->flags & AV_PIX_FMT_FLAG_PLANAR;
+    const int is_packed_fmt = is_rgb || (!is_rgb && !is_planar);
+    int linesize;
+
+    if (pix_fmt == AV_PIX_FMT_NV15 ||
+        pix_fmt == AV_PIX_FMT_NV20) {
+        const int log2_chroma_w = plane == 1 ? 1 : 0;
+        const int width_align_256_odds = FFALIGN(width << log2_chroma_w, 256) | 256;
+        return FFALIGN(width_align_256_odds * 10 / 8, 64);
+    }
+
+    linesize = av_image_get_linesize(pix_fmt, width, plane);
+
+    if (is_packed_fmt) {
+        const int pixel_width = av_get_padded_bits_per_pixel(pixdesc) / 8;
+        linesize = FFALIGN(linesize / pixel_width, 8) * pixel_width;
+    } else
+        linesize = FFALIGN(linesize, 64);
+
+    return linesize;
+}
+
+static AVBufferRef *rkmpp_drm_pool_alloc(void *opaque, size_t size)
+{
+    int ret;
+    AVHWFramesContext *hwfc = opaque;
+    AVRKMPPFramesContext *avfc = hwfc->hwctx;
+    AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    AVDRMFrameDescriptor *desc;
+    AVDRMLayerDescriptor *layer;
+    AVBufferRef *ref;
+
+    int i;
+    const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(hwfc->sw_format);
+    const int bits_pp = av_get_padded_bits_per_pixel(pixdesc);
+    const int aligned_w = FFALIGN(hwfc->width * 6 / 5,  64);
+    const int aligned_h = FFALIGN(hwfc->height * 6 / 5, 64);
+
+    MppBuffer mpp_buf = NULL;
+    size_t mpp_buf_size = aligned_w * aligned_h * bits_pp / 8;
+
+    if (hwfc->initial_pool_size > 0 &&
+        avfc->nb_frames >= hwfc->initial_pool_size)
+        return NULL;
+
+    desc = av_mallocz(sizeof(*desc));
+    if (!desc)
+        return NULL;
+
+    desc->nb_objects = 1;
+    desc->nb_layers  = 1;
+
+    ret = mpp_buffer_get(avfc->buf_group, &mpp_buf, mpp_buf_size);
+    if (ret != MPP_OK || !mpp_buf) {
+        av_log(hwctx, AV_LOG_ERROR, "Failed to get MPP buffer: %d\n", ret);
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    desc->objects[0].opaque = mpp_buf;
+
+    desc->objects[0].fd   = mpp_buffer_get_fd(mpp_buf);
+    desc->objects[0].ptr  = mpp_buffer_get_ptr(mpp_buf);
+    desc->objects[0].size = mpp_buffer_get_size(mpp_buf);
+
+    layer = &desc->layers[0];
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++) {
+        if (supported_formats[i].pixfmt == hwfc->sw_format) {
+            layer->format = supported_formats[i].drm_format;
+            break;
+        }
+    }
+    layer->nb_planes = av_pix_fmt_count_planes(hwfc->sw_format);
+    layer->planes[0].object_index = 0;
+    layer->planes[0].offset = 0;
+    layer->planes[0].pitch =
+        rkmpp_get_aligned_linesize(hwfc->sw_format, hwfc->width, 0);
+
+    for (i = 1; i < layer->nb_planes; i++) {
+        layer->planes[i].object_index = 0;
+        layer->planes[i].offset =
+            layer->planes[i-1].offset +
+            layer->planes[i-1].pitch * (hwfc->height >> (i > 1 ? pixdesc->log2_chroma_h : 0));
+        layer->planes[i].pitch =
+            rkmpp_get_aligned_linesize(hwfc->sw_format, hwfc->width, i);
+    }
+
+    ref = av_buffer_create((uint8_t*)desc, sizeof(*desc), rkmpp_buffer_free,
+                           opaque, 0);
+    if (!ref) {
+        av_log(hwfc, AV_LOG_ERROR, "Failed to create RKMPP buffer.\n");
+        goto fail;
+    }
+
+    if (hwfc->initial_pool_size > 0) {
+        av_assert0(avfc->nb_frames < hwfc->initial_pool_size);
+        memcpy(&avfc->frames[avfc->nb_frames], desc, sizeof(*desc));
+        ++avfc->nb_frames;
+    }
+
+    return ref;
+
+fail:
+    rkmpp_free_drm_frame_descriptor(hwctx, desc);
+    return NULL;
+}
+
+static int rkmpp_frames_init(AVHWFramesContext *hwfc)
+{
+    AVRKMPPFramesContext *avfc = hwfc->hwctx;
+    AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    int i, ret;
+
+    if (hwfc->pool)
+        return 0;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++)
+        if (supported_formats[i].pixfmt == hwfc->sw_format)
+            break;
+    if (i >= FF_ARRAY_ELEMS(supported_formats)) {
+        av_log(hwfc, AV_LOG_ERROR, "Unsupported format: %s.\n",
+               av_get_pix_fmt_name(hwfc->sw_format));
+        return AVERROR(EINVAL);
+    }
+
+    avfc->nb_frames = 0;
+    avfc->frames    = NULL;
+    if (hwfc->initial_pool_size > 0) {
+        avfc->frames = av_malloc(hwfc->initial_pool_size *
+                                 sizeof(*avfc->frames));
+        if (!avfc->frames)
+            return AVERROR(ENOMEM);
+    }
+
+    ret = mpp_buffer_group_get_internal(&avfc->buf_group, MPP_BUFFER_TYPE_DRM | hwctx->flags);
+    if (ret != MPP_OK) {
+        av_log(hwfc, AV_LOG_ERROR, "Failed to get MPP internal buffer group: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
+    hwfc->internal->pool_internal =
+        av_buffer_pool_init2(sizeof(AVDRMFrameDescriptor), hwfc,
+                             rkmpp_drm_pool_alloc, NULL);
+    if (!hwfc->internal->pool_internal) {
+        av_log(hwfc, AV_LOG_ERROR, "Failed to create RKMPP buffer pool.\n");
+        return AVERROR(ENOMEM);
+    }
+
+    return 0;
+}
+
+static void rkmpp_frames_uninit(AVHWFramesContext *hwfc)
+{
+    AVRKMPPFramesContext *avfc = hwfc->hwctx;
+
+    av_freep(&avfc->frames);
+
+    if (avfc->buf_group) {
+        mpp_buffer_group_put(avfc->buf_group);
+        avfc->buf_group = NULL;
+    }
+}
+
+static int rkmpp_get_buffer(AVHWFramesContext *hwfc, AVFrame *frame)
+{
+    frame->buf[0] = av_buffer_pool_get(hwfc->pool);
+    if (!frame->buf[0])
+        return AVERROR(ENOMEM);
+
+    frame->data[0] = (uint8_t*)frame->buf[0]->data;
+
+    frame->format = AV_PIX_FMT_DRM_PRIME;
+    frame->width  = hwfc->width;
+    frame->height = hwfc->height;
+
+    return 0;
+}
+
+typedef struct RKMPPDRMMapping {
+    // Address and length of each mmap()ed region.
+    int nb_regions;
+    int sync_flags;
+    int object[AV_DRM_MAX_PLANES];
+    void *address[AV_DRM_MAX_PLANES];
+    size_t length[AV_DRM_MAX_PLANES];
+    int unmap[AV_DRM_MAX_PLANES];
+} RKMPPDRMMapping;
+
+static void rkmpp_unmap_frame(AVHWFramesContext *hwfc,
+                              HWMapDescriptor *hwmap)
+{
+    AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    RKMPPDRMMapping *map = hwmap->priv;
+
+    for (int i = 0; i < map->nb_regions; i++) {
+#if HAVE_LINUX_DMA_BUF_H
+        struct dma_buf_sync sync = { .flags = DMA_BUF_SYNC_END | map->sync_flags };
+        if (hwctx->flags & MPP_BUFFER_FLAGS_CACHABLE)
+            ioctl(map->object[i], DMA_BUF_IOCTL_SYNC, &sync);
+#endif
+        if (map->address[i] && map->unmap[i])
+            munmap(map->address[i], map->length[i]);
+    }
+
+    av_free(map);
+}
+
+static int rkmpp_map_frame(AVHWFramesContext *hwfc,
+                           AVFrame *dst, const AVFrame *src, int flags)
+{
+    AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    const AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)src->data[0];
+#if HAVE_LINUX_DMA_BUF_H
+    struct dma_buf_sync sync_start = { 0 };
+#endif
+    RKMPPDRMMapping *map;
+    int err, i, p, plane;
+    int mmap_prot;
+    void *addr;
+
+    map = av_mallocz(sizeof(*map));
+    if (!map)
+        return AVERROR(ENOMEM);
+
+    mmap_prot = 0;
+    if (flags & AV_HWFRAME_MAP_READ)
+        mmap_prot |= PROT_READ;
+    if (flags & AV_HWFRAME_MAP_WRITE)
+        mmap_prot |= PROT_WRITE;
+
+#if HAVE_LINUX_DMA_BUF_H
+    if (flags & AV_HWFRAME_MAP_READ)
+        map->sync_flags |= DMA_BUF_SYNC_READ;
+    if (flags & AV_HWFRAME_MAP_WRITE)
+        map->sync_flags |= DMA_BUF_SYNC_WRITE;
+    sync_start.flags = DMA_BUF_SYNC_START | map->sync_flags;
+#endif
+
+    if (desc->objects[0].format_modifier != DRM_FORMAT_MOD_LINEAR) {
+        av_log(hwfc, AV_LOG_ERROR, "Transfer non-linear DRM_PRIME frame is not supported!\n");
+        return AVERROR(ENOSYS);
+    }
+
+    av_assert0(desc->nb_objects <= AV_DRM_MAX_PLANES);
+    for (i = 0; i < desc->nb_objects; i++) {
+        if (desc->objects[i].ptr) {
+            addr = desc->objects[i].ptr;
+            map->unmap[i] = 0;
+        } else {
+            addr = mmap(NULL, desc->objects[i].size, mmap_prot, MAP_SHARED,
+                        desc->objects[i].fd, 0);
+            if (addr == MAP_FAILED) {
+                err = AVERROR(errno);
+                av_log(hwfc, AV_LOG_ERROR, "Failed to map RKMPP object %d to "
+                       "memory: %d.\n", desc->objects[i].fd, errno);
+                goto fail;
+            }
+            map->unmap[i] = 1;
+        }
+
+        map->address[i] = addr;
+        map->length[i]  = desc->objects[i].size;
+        map->object[i] = desc->objects[i].fd;
+
+#if HAVE_LINUX_DMA_BUF_H
+        /* We're not checking for errors here because the kernel may not
+         * support the ioctl, in which case its okay to carry on */
+        if (hwctx->flags & MPP_BUFFER_FLAGS_CACHABLE)
+            ioctl(desc->objects[i].fd, DMA_BUF_IOCTL_SYNC, &sync_start);
+#endif
+    }
+    map->nb_regions = i;
+
+    plane = 0;
+    for (i = 0; i < desc->nb_layers; i++) {
+        const AVDRMLayerDescriptor *layer = &desc->layers[i];
+        for (p = 0; p < layer->nb_planes; p++) {
+            dst->data[plane] =
+                (uint8_t*)map->address[layer->planes[p].object_index] +
+                                       layer->planes[p].offset;
+            dst->linesize[plane] =     layer->planes[p].pitch;
+            ++plane;
+        }
+    }
+    av_assert0(plane <= AV_DRM_MAX_PLANES);
+
+    dst->width  = src->width;
+    dst->height = src->height;
+
+    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,
+                                &rkmpp_unmap_frame, map);
+    if (err < 0)
+        goto fail;
+
+    return 0;
+
+fail:
+    for (i = 0; i < desc->nb_objects; i++) {
+        if (map->address[i] && map->unmap[i])
+            munmap(map->address[i], map->length[i]);
+    }
+    av_free(map);
+    return err;
+}
+
+static int rkmpp_transfer_get_formats(AVHWFramesContext *ctx,
+                                      enum AVHWFrameTransferDirection dir,
+                                      enum AVPixelFormat **formats)
+{
+    enum AVPixelFormat *pix_fmts;
+
+    pix_fmts = av_malloc_array(2, sizeof(*pix_fmts));
+    if (!pix_fmts)
+        return AVERROR(ENOMEM);
+
+    pix_fmts[0] = ctx->sw_format;
+    pix_fmts[1] = AV_PIX_FMT_NONE;
+
+    *formats = pix_fmts;
+    return 0;
+}
+
+static int rkmpp_transfer_data_from(AVHWFramesContext *hwfc,
+                                    AVFrame *dst, const AVFrame *src)
+{
+    AVFrame *map;
+    int err;
+
+    if (dst->width > hwfc->width || dst->height > hwfc->height)
+        return AVERROR(EINVAL);
+
+    map = av_frame_alloc();
+    if (!map)
+        return AVERROR(ENOMEM);
+    map->format = dst->format;
+
+    err = rkmpp_map_frame(hwfc, map, src, AV_HWFRAME_MAP_READ);
+    if (err)
+        goto fail;
+
+    map->width  = dst->width;
+    map->height = dst->height;
+
+    err = av_frame_copy(dst, map);
+    if (err)
+        goto fail;
+
+    err = 0;
+fail:
+    av_frame_free(&map);
+    return err;
+}
+
+static int rkmpp_transfer_data_to(AVHWFramesContext *hwfc,
+                                  AVFrame *dst, const AVFrame *src)
+{
+    AVFrame *map;
+    int err;
+
+    if (src->width > hwfc->width || src->height > hwfc->height)
+        return AVERROR(EINVAL);
+
+    map = av_frame_alloc();
+    if (!map)
+        return AVERROR(ENOMEM);
+    map->format = src->format;
+
+    err = rkmpp_map_frame(hwfc, map, dst, AV_HWFRAME_MAP_WRITE |
+                                          AV_HWFRAME_MAP_OVERWRITE);
+    if (err)
+        goto fail;
+
+    map->width  = src->width;
+    map->height = src->height;
+
+    err = av_frame_copy(map, src);
+    if (err)
+        goto fail;
+
+    err = 0;
+fail:
+    av_frame_free(&map);
+    return err;
+}
+
+static int rkmpp_map_from(AVHWFramesContext *hwfc, AVFrame *dst,
+                          const AVFrame *src, int flags)
+{
+    int err;
+
+    if (hwfc->sw_format != dst->format)
+        return AVERROR(ENOSYS);
+
+    err = rkmpp_map_frame(hwfc, dst, src, flags);
+    if (err)
+        return err;
+
+    err = av_frame_copy_props(dst, src);
+    if (err)
+        return err;
+
+    return 0;
+}
+
+const HWContextType ff_hwcontext_type_rkmpp = {
+    .type                   = AV_HWDEVICE_TYPE_RKMPP,
+    .name                   = "RKMPP",
+
+    .device_hwctx_size      = sizeof(AVRKMPPDeviceContext),
+    .frames_hwctx_size      = sizeof(AVRKMPPFramesContext),
+
+    .device_create          = &rkmpp_device_create,
+
+    .frames_get_constraints = &rkmpp_frames_get_constraints,
+
+    .frames_get_buffer      = &rkmpp_get_buffer,
+    .frames_init            = &rkmpp_frames_init,
+    .frames_uninit          = &rkmpp_frames_uninit,
+    .transfer_get_formats   = &rkmpp_transfer_get_formats,
+    .transfer_data_to       = &rkmpp_transfer_data_to,
+    .transfer_data_from     = &rkmpp_transfer_data_from,
+    .map_from               = &rkmpp_map_from,
+
+    .pix_fmts = (const enum AVPixelFormat[]) {
+        AV_PIX_FMT_DRM_PRIME,
+        AV_PIX_FMT_NONE
+    },
+};
diff --git a/libavutil/hwcontext_rkmpp.h b/libavutil/hwcontext_rkmpp.h
new file mode 100644
index 00000000000..796debd316d
--- /dev/null
+++ b/libavutil/hwcontext_rkmpp.h
@@ -0,0 +1,91 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_HWCONTEXT_RKMPP_H
+#define AVUTIL_HWCONTEXT_RKMPP_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <drm_fourcc.h>
+#include <rockchip/rk_mpi.h>
+
+#include "hwcontext_drm.h"
+
+#ifndef DRM_FORMAT_P010
+#define DRM_FORMAT_P010         fourcc_code('P', '0', '1', '0')
+#endif
+#ifndef DRM_FORMAT_NV15
+#define DRM_FORMAT_NV15         fourcc_code('N', 'V', '1', '5')
+#endif
+#ifndef DRM_FORMAT_NV20
+#define DRM_FORMAT_NV20         fourcc_code('N', 'V', '2', '0')
+#endif
+#ifndef DRM_FORMAT_YUV420_8BIT
+#define DRM_FORMAT_YUV420_8BIT  fourcc_code('Y', 'U', '0', '8')
+#endif
+#ifndef DRM_FORMAT_YUV420_10BIT
+#define DRM_FORMAT_YUV420_10BIT fourcc_code('Y', 'U', '1', '0')
+#endif
+#ifndef DRM_FORMAT_Y210
+#define DRM_FORMAT_Y210         fourcc_code('Y', '2', '1', '0')
+#endif
+
+#ifndef DRM_FORMAT_MOD_VENDOR_ARM
+#define DRM_FORMAT_MOD_VENDOR_ARM 0x08
+#endif
+#ifndef DRM_FORMAT_MOD_ARM_TYPE_AFBC
+#define DRM_FORMAT_MOD_ARM_TYPE_AFBC 0x00
+#endif
+
+#define drm_is_afbc(mod) \
+        ((mod >> 52) == (DRM_FORMAT_MOD_ARM_TYPE_AFBC | \
+                (DRM_FORMAT_MOD_VENDOR_ARM << 4)))
+
+/**
+ * RKMPP-specific data associated with a frame pool.
+ *
+ * Allocated as AVHWFramesContext.hwctx.
+ */
+typedef struct AVRKMPPFramesContext {
+    /**
+     * MPP buffer group.
+     */
+    MppBufferGroup buf_group;
+
+    /**
+     * The descriptors of all frames in the pool after creation.
+     * Only valid if AVHWFramesContext.initial_pool_size was positive.
+     * These are intended to be used as the buffer of RKMPP decoder.
+     */
+    AVDRMFrameDescriptor *frames;
+    int                nb_frames;
+} AVRKMPPFramesContext;
+
+/**
+ * RKMPP device details.
+ *
+ * Allocated as AVHWDeviceContext.hwctx
+ */
+typedef struct AVRKMPPDeviceContext {
+    /**
+     * MPP buffer allocation flags.
+     */
+    int flags;
+} AVRKMPPDeviceContext;
+
+#endif /* AVUTIL_HWCONTEXT_RKMPP_H */

From 78421570bf7c22d920f5a256942bf39420e5d34d Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 27 Dec 2023 23:42:12 +0800
Subject: [PATCH 006/103] lavf/rkrga: add RKRGA scale, vpp and overlay filter

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure                      |   10 +
 libavfilter/Makefile           |    5 +
 libavfilter/allfilters.c       |    3 +
 libavfilter/rkrga_common.c     | 1179 ++++++++++++++++++++++++++++++++
 libavfilter/rkrga_common.h     |  127 ++++
 libavfilter/vf_overlay_rkrga.c |  363 ++++++++++
 libavfilter/vf_vpp_rkrga.c     |  477 +++++++++++++
 7 files changed, 2164 insertions(+)
 create mode 100644 libavfilter/rkrga_common.c
 create mode 100644 libavfilter/rkrga_common.h
 create mode 100644 libavfilter/vf_overlay_rkrga.c
 create mode 100644 libavfilter/vf_vpp_rkrga.c

diff --git a/configure b/configure
index 76c2188e109..541c4ee1143 100755
--- a/configure
+++ b/configure
@@ -346,6 +346,7 @@ External library support:
   --enable-omx             enable OpenMAX IL code [no]
   --enable-omx-rpi         enable OpenMAX IL code for Raspberry Pi [no]
   --enable-rkmpp           enable Rockchip Media Process Platform code [no]
+  --enable-rkrga           enable Rockchip 2D Raster Graphic Acceleration code [no]
   --disable-v4l2-m2m       disable V4L2 mem2mem code [autodetect]
   --disable-vaapi          disable Video Acceleration API (mainly Unix/Intel) code [autodetect]
   --disable-vdpau          disable Nvidia Video Decode and Presentation API for Unix code [autodetect]
@@ -1824,6 +1825,7 @@ EXTERNAL_LIBRARY_VERSION3_LIST="
     libvo_amrwbenc
     mbedtls
     rkmpp
+    rkrga
 "
 
 EXTERNAL_LIBRARY_GPLV3_LIST="
@@ -3765,6 +3767,7 @@ overlay_qsv_filter_deps="libmfx"
 overlay_qsv_filter_select="qsvvpp"
 overlay_vaapi_filter_deps="vaapi VAProcPipelineCaps_blend_flags"
 overlay_vulkan_filter_deps="vulkan spirv_compiler"
+overlay_rkrga_filter_deps="rkrga"
 owdenoise_filter_deps="gpl"
 pad_opencl_filter_deps="opencl"
 pan_filter_deps="swresample"
@@ -3786,6 +3789,7 @@ scale2ref_filter_deps="swscale"
 scale_filter_deps="swscale"
 scale_qsv_filter_deps="libmfx"
 scale_qsv_filter_select="qsvvpp"
+scale_rkrga_filter_deps="rkrga"
 scdet_filter_select="scene_sad"
 select_filter_select="scene_sad"
 sharpness_vaapi_filter_deps="vaapi"
@@ -3829,6 +3833,7 @@ scale_vt_filter_deps="videotoolbox"
 scale_vulkan_filter_deps="vulkan spirv_compiler"
 vpp_qsv_filter_deps="libmfx"
 vpp_qsv_filter_select="qsvvpp"
+vpp_rkrga_filter_deps="rkrga"
 xfade_opencl_filter_deps="opencl"
 xfade_vulkan_filter_deps="vulkan spirv_compiler"
 yadif_cuda_filter_deps="ffnvcodec"
@@ -6908,6 +6913,11 @@ enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp rockchip/rk
                                { enabled libdrm ||
                                  die "ERROR: rkmpp requires --enable-libdrm"; }
                              }
+enabled rkrga             && require rkrga rga/RgaApi.h c_RkRgaBlit -lrga &&
+                             { require rkrga rga/im2d.h querystring -lrga &&
+                               { enabled rkmpp ||
+                                 die "ERROR: rkrga requires --enable-rkmpp"; }
+                             }
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
 
 
diff --git a/libavfilter/Makefile b/libavfilter/Makefile
index 603b532ad05..e4da0527544 100644
--- a/libavfilter/Makefile
+++ b/libavfilter/Makefile
@@ -30,6 +30,7 @@ OBJS-$(HAVE_THREADS)                         += pthread.o
 
 # subsystems
 OBJS-$(CONFIG_QSVVPP)                        += qsvvpp.o
+OBJS-$(CONFIG_RKRGA)                         += rkrga_common.o
 OBJS-$(CONFIG_SCENE_SAD)                     += scene_sad.o
 OBJS-$(CONFIG_DNN)                           += dnn_filter_common.o
 include $(SRC_PATH)/libavfilter/dnn/Makefile
@@ -412,6 +413,7 @@ OBJS-$(CONFIG_OVERLAY_OPENCL_FILTER)         += vf_overlay_opencl.o opencl.o \
 OBJS-$(CONFIG_OVERLAY_QSV_FILTER)            += vf_overlay_qsv.o framesync.o
 OBJS-$(CONFIG_OVERLAY_VAAPI_FILTER)          += vf_overlay_vaapi.o framesync.o vaapi_vpp.o
 OBJS-$(CONFIG_OVERLAY_VULKAN_FILTER)         += vf_overlay_vulkan.o vulkan.o vulkan_filter.o
+OBJS-$(CONFIG_OVERLAY_RKRGA_FILTER)          += vf_overlay_rkrga.o framesync.o
 OBJS-$(CONFIG_OWDENOISE_FILTER)              += vf_owdenoise.o
 OBJS-$(CONFIG_PAD_FILTER)                    += vf_pad.o
 OBJS-$(CONFIG_PAD_OPENCL_FILTER)             += vf_pad_opencl.o opencl.o opencl/pad.o
@@ -461,6 +463,7 @@ OBJS-$(CONFIG_SCALE_QSV_FILTER)              += vf_vpp_qsv.o
 OBJS-$(CONFIG_SCALE_VAAPI_FILTER)            += vf_scale_vaapi.o scale_eval.o vaapi_vpp.o
 OBJS-$(CONFIG_SCALE_VT_FILTER)               += vf_scale_vt.o scale_eval.o
 OBJS-$(CONFIG_SCALE_VULKAN_FILTER)           += vf_scale_vulkan.o vulkan.o vulkan_filter.o
+OBJS-$(CONFIG_SCALE_RKRGA_FILTER)            += vf_vpp_rkrga.o scale_eval.o
 OBJS-$(CONFIG_SCALE2REF_FILTER)              += vf_scale.o scale_eval.o
 OBJS-$(CONFIG_SCALE2REF_NPP_FILTER)          += vf_scale_npp.o scale_eval.o
 OBJS-$(CONFIG_SCDET_FILTER)                  += vf_scdet.o
@@ -550,6 +553,7 @@ OBJS-$(CONFIG_VIF_FILTER)                    += vf_vif.o framesync.o
 OBJS-$(CONFIG_VIGNETTE_FILTER)               += vf_vignette.o
 OBJS-$(CONFIG_VMAFMOTION_FILTER)             += vf_vmafmotion.o framesync.o
 OBJS-$(CONFIG_VPP_QSV_FILTER)                += vf_vpp_qsv.o
+OBJS-$(CONFIG_VPP_RKRGA_FILTER)              += vf_vpp_rkrga.o scale_eval.o
 OBJS-$(CONFIG_VSTACK_FILTER)                 += vf_stack.o framesync.o
 OBJS-$(CONFIG_W3FDIF_FILTER)                 += vf_w3fdif.o
 OBJS-$(CONFIG_WAVEFORM_FILTER)               += vf_waveform.o
@@ -648,6 +652,7 @@ SKIPHEADERS-$(CONFIG_LCMS2)                  += fflcms2.h
 SKIPHEADERS-$(CONFIG_LIBVIDSTAB)             += vidstabutils.h
 
 SKIPHEADERS-$(CONFIG_QSVVPP)                 += qsvvpp.h stack_internal.h
+SKIPHEADERS-$(CONFIG_RKRGA)                  += rkrga_common.h
 SKIPHEADERS-$(CONFIG_OPENCL)                 += opencl.h
 SKIPHEADERS-$(CONFIG_VAAPI)                  += vaapi_vpp.h stack_internal.h
 SKIPHEADERS-$(CONFIG_VULKAN)                 += vulkan.h vulkan_filter.h
diff --git a/libavfilter/allfilters.c b/libavfilter/allfilters.c
index aa49703c6e3..a154a77daa7 100644
--- a/libavfilter/allfilters.c
+++ b/libavfilter/allfilters.c
@@ -387,6 +387,7 @@ extern const AVFilter ff_vf_overlay_qsv;
 extern const AVFilter ff_vf_overlay_vaapi;
 extern const AVFilter ff_vf_overlay_vulkan;
 extern const AVFilter ff_vf_overlay_cuda;
+extern const AVFilter ff_vf_overlay_rkrga;
 extern const AVFilter ff_vf_owdenoise;
 extern const AVFilter ff_vf_pad;
 extern const AVFilter ff_vf_pad_opencl;
@@ -432,6 +433,7 @@ extern const AVFilter ff_vf_scale_qsv;
 extern const AVFilter ff_vf_scale_vaapi;
 extern const AVFilter ff_vf_scale_vt;
 extern const AVFilter ff_vf_scale_vulkan;
+extern const AVFilter ff_vf_scale_rkrga;
 extern const AVFilter ff_vf_scale2ref;
 extern const AVFilter ff_vf_scale2ref_npp;
 extern const AVFilter ff_vf_scdet;
@@ -517,6 +519,7 @@ extern const AVFilter ff_vf_vif;
 extern const AVFilter ff_vf_vignette;
 extern const AVFilter ff_vf_vmafmotion;
 extern const AVFilter ff_vf_vpp_qsv;
+extern const AVFilter ff_vf_vpp_rkrga;
 extern const AVFilter ff_vf_vstack;
 extern const AVFilter ff_vf_w3fdif;
 extern const AVFilter ff_vf_waveform;
diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
new file mode 100644
index 00000000000..14c46f7238f
--- /dev/null
+++ b/libavfilter/rkrga_common.c
@@ -0,0 +1,1179 @@
+/*
+ * Copyright (c) 2023 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Rockchip RGA (2D Raster Graphic Acceleration) base function
+ */
+
+#include "libavutil/common.h"
+#include "libavutil/pixdesc.h"
+
+#include "internal.h"
+#include "video.h"
+
+#include "rkrga_common.h"
+
+typedef struct RGAAsyncFrame {
+    RGAFrame *src;
+    RGAFrame *dst;
+    RGAFrame *pat;
+} RGAAsyncFrame;
+
+typedef struct RGAFormatMap {
+    enum AVPixelFormat    pix_fmt;
+    enum _Rga_SURF_FORMAT rga_fmt;
+} RGAFormatMap;
+
+#define YUV_FORMATS \
+    { AV_PIX_FMT_GRAY8,    RK_FORMAT_YCbCr_400 },        /* RGA2 only */ \
+    { AV_PIX_FMT_YUV420P,  RK_FORMAT_YCbCr_420_P },      /* RGA2 only */ \
+    { AV_PIX_FMT_YUV422P,  RK_FORMAT_YCbCr_422_P },      /* RGA2 only */ \
+    { AV_PIX_FMT_NV12,     RK_FORMAT_YCbCr_420_SP }, \
+    { AV_PIX_FMT_NV21,     RK_FORMAT_YCrCb_420_SP }, \
+    { AV_PIX_FMT_NV16,     RK_FORMAT_YCbCr_422_SP }, \
+    { AV_PIX_FMT_P010,     RK_FORMAT_YCbCr_420_SP_10B }, /* RGA3 only */ \
+    { AV_PIX_FMT_NV15,     RK_FORMAT_YCbCr_420_SP_10B }, /* RGA2 only input, aka P010 compact */ \
+    { AV_PIX_FMT_NV20,     RK_FORMAT_YCbCr_422_SP_10B }, \
+    { AV_PIX_FMT_YUYV422,  RK_FORMAT_YUYV_422 }, \
+    { AV_PIX_FMT_YVYU422,  RK_FORMAT_YVYU_422 }, \
+    { AV_PIX_FMT_UYVY422,  RK_FORMAT_UYVY_422 },
+
+#define RGB_FORMATS \
+    { AV_PIX_FMT_RGB555LE, RK_FORMAT_BGRA_5551 },        /* RGA2 only */ \
+    { AV_PIX_FMT_BGR555LE, RK_FORMAT_RGBA_5551 },        /* RGA2 only */ \
+    { AV_PIX_FMT_RGB565LE, RK_FORMAT_BGR_565 }, \
+    { AV_PIX_FMT_BGR565LE, RK_FORMAT_RGB_565 }, \
+    { AV_PIX_FMT_RGB24,    RK_FORMAT_RGB_888 }, \
+    { AV_PIX_FMT_BGR24,    RK_FORMAT_BGR_888 }, \
+    { AV_PIX_FMT_RGBA,     RK_FORMAT_RGBA_8888 }, \
+    { AV_PIX_FMT_RGB0,     RK_FORMAT_RGBA_8888 },        /* RK_FORMAT_RGBX_8888 triggers RGA2 on multicore RGA */ \
+    { AV_PIX_FMT_BGRA,     RK_FORMAT_BGRA_8888 }, \
+    { AV_PIX_FMT_BGR0,     RK_FORMAT_BGRA_8888 },        /* RK_FORMAT_BGRX_8888 triggers RGA2 on multicore RGA */ \
+    { AV_PIX_FMT_ARGB,     RK_FORMAT_ARGB_8888 },        /* RGA3 only input */ \
+    { AV_PIX_FMT_0RGB,     RK_FORMAT_ARGB_8888 },        /* RGA3 only input */ \
+    { AV_PIX_FMT_ABGR,     RK_FORMAT_ABGR_8888 },        /* RGA3 only input */ \
+    { AV_PIX_FMT_0BGR,     RK_FORMAT_ABGR_8888 },        /* RGA3 only input */
+
+static const RGAFormatMap supported_formats_main[] = {
+    YUV_FORMATS
+    RGB_FORMATS
+};
+
+static const RGAFormatMap supported_formats_overlay[] = {
+    RGB_FORMATS
+};
+#undef YUV_FORMATS
+#undef RGB_FORMATS
+
+static int map_av_to_rga_format(enum AVPixelFormat in_format,
+                                enum _Rga_SURF_FORMAT *out_format, int is_overlay)
+{
+    int i;
+
+    if (is_overlay)
+        goto overlay;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats_main); i++) {
+        if (supported_formats_main[i].pix_fmt == in_format) {
+            if (out_format)
+                *out_format = supported_formats_main[i].rga_fmt;
+            return 1;
+        }
+    }
+    return 0;
+
+overlay:
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats_overlay); i++) {
+        if (supported_formats_overlay[i].pix_fmt == in_format) {
+            if (out_format)
+                *out_format = supported_formats_overlay[i].rga_fmt;
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static int get_pixel_stride(const AVDRMObjectDescriptor *object,
+                            const AVDRMLayerDescriptor *layer,
+                            int is_rgb, int is_planar,
+                            float bytes_pp, int *ws, int *hs)
+{
+    const AVDRMPlaneDescriptor *plane0, *plane1;
+    const int is_packed_fmt = is_rgb || (!is_rgb && !is_planar);
+
+    if (!object || !layer || !ws || !hs || bytes_pp <= 0)
+        return AVERROR(EINVAL);
+
+    plane0 = &layer->planes[0];
+    plane1 = &layer->planes[1];
+
+    *ws = is_packed_fmt ?
+        (plane0->pitch / bytes_pp) :
+        plane0->pitch;
+    *hs = is_packed_fmt ?
+        ALIGN_DOWN(object->size / plane0->pitch, is_rgb ? 1 : 2) :
+        (plane1->offset / plane0->pitch);
+
+    return (*ws > 0 && *hs > 0) ? 0 : AVERROR(EINVAL);
+}
+
+/* Canonical formats: https://dri.freedesktop.org/docs/drm/gpu/afbc.html */
+static uint32_t get_drm_afbc_format(enum AVPixelFormat pix_fmt)
+{
+    switch (pix_fmt) {
+    case AV_PIX_FMT_NV12:     return DRM_FORMAT_YUV420_8BIT;
+    case AV_PIX_FMT_NV15:     return DRM_FORMAT_YUV420_10BIT;
+    case AV_PIX_FMT_NV16:     return DRM_FORMAT_YUYV;
+    case AV_PIX_FMT_NV20:     return DRM_FORMAT_Y210;
+    case AV_PIX_FMT_RGB565LE: return DRM_FORMAT_RGB565;
+    case AV_PIX_FMT_BGR565LE: return DRM_FORMAT_BGR565;
+    case AV_PIX_FMT_RGB24:    return DRM_FORMAT_RGB888;
+    case AV_PIX_FMT_BGR24:    return DRM_FORMAT_BGR888;
+    case AV_PIX_FMT_RGBA:     return DRM_FORMAT_ABGR8888;
+    case AV_PIX_FMT_RGB0:     return DRM_FORMAT_XBGR8888;
+    case AV_PIX_FMT_BGRA:     return DRM_FORMAT_ARGB8888;
+    case AV_PIX_FMT_BGR0:     return DRM_FORMAT_XRGB8888;
+    default:                  return DRM_FORMAT_INVALID;
+    }
+}
+
+static int is_pixel_stride_rga3_compat(int ws, int hs,
+                                       enum _Rga_SURF_FORMAT fmt)
+{
+    switch (fmt) {
+    case RK_FORMAT_YCbCr_420_SP:
+    case RK_FORMAT_YCrCb_420_SP:
+    case RK_FORMAT_YCbCr_422_SP:     return !(ws % 16) && !(hs % 2);
+    case RK_FORMAT_YCbCr_420_SP_10B:
+    case RK_FORMAT_YCbCr_422_SP_10B: return !(ws % 64) && !(hs % 2);
+    case RK_FORMAT_YUYV_422:
+    case RK_FORMAT_YVYU_422:
+    case RK_FORMAT_UYVY_422:         return !(ws % 8) && !(hs % 2);
+    case RK_FORMAT_RGB_565:
+    case RK_FORMAT_BGR_565:          return !(ws % 8);
+    case RK_FORMAT_RGB_888:
+    case RK_FORMAT_BGR_888:          return !(ws % 16);
+    case RK_FORMAT_RGBA_8888:
+    case RK_FORMAT_BGRA_8888:
+    case RK_FORMAT_ARGB_8888:
+    case RK_FORMAT_ABGR_8888:        return !(ws % 4);
+    default:                         return 0;
+    }
+}
+
+static void clear_unused_frames(RGAFrame *list)
+{
+    while (list) {
+        if (list->queued == 1 && !list->locked) {
+            av_frame_free(&list->frame);
+            list->queued = 0;
+        }
+        list = list->next;
+    }
+}
+
+static void clear_frame_list(RGAFrame **list)
+{
+    while (*list) {
+        RGAFrame *frame = NULL;
+
+        frame = *list;
+        *list = (*list)->next;
+        av_frame_free(&frame->frame);
+        av_freep(&frame);
+    }
+}
+
+static RGAFrame *get_free_frame(RGAFrame **list)
+{
+    RGAFrame *out = *list;
+
+    for (; out; out = out->next) {
+        if (!out->queued) {
+            out->queued = 1;
+            break;
+        }
+    }
+
+    if (!out) {
+        out = av_mallocz(sizeof(*out));
+        if (!out) {
+            av_log(NULL, AV_LOG_ERROR, "Cannot alloc new output frame\n");
+            return NULL;
+        }
+        out->queued = 1;
+        out->next   = *list;
+        *list       = out;
+    }
+
+    return out;
+}
+
+static void set_colorspace_info(RGAFrameInfo *in_info, const AVFrame *in,
+                                RGAFrameInfo *out_info, AVFrame *out,
+                                int *color_space_mode)
+{
+    if (!in_info || !out_info || !in || !out || !color_space_mode)
+        return;
+
+    *color_space_mode = 0;
+
+    /* rgb2yuv */
+    if ((in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB) &&
+        !(out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB)) {
+        /* rgb full -> yuv full/limit */
+        if (in->color_range == AVCOL_RANGE_JPEG) {
+            switch (in->colorspace) {
+            case AVCOL_SPC_BT709:
+                out->colorspace   = AVCOL_SPC_BT709;
+                *color_space_mode = 0xb << 8; /* rgb2yuv_709_limit */
+                break;
+            case AVCOL_SPC_BT470BG:
+                out->colorspace   = AVCOL_SPC_BT470BG;
+                *color_space_mode = 2 << 2; /* IM_RGB_TO_YUV_BT601_LIMIT */
+                break;
+            }
+        }
+        if (*color_space_mode) {
+            out->color_trc       = AVCOL_TRC_UNSPECIFIED;
+            out->color_primaries = AVCOL_PRI_UNSPECIFIED;
+            out->color_range     = AVCOL_RANGE_MPEG;
+        }
+    }
+
+    /* yuv2rgb */
+    if (!(in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB) &&
+        (out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB)) {
+        /* yuv full/limit -> rgb full */
+        switch (in->color_range) {
+        case AVCOL_RANGE_MPEG:
+            if (in->colorspace == AVCOL_SPC_BT709) {
+                out->colorspace   = AVCOL_SPC_BT709;
+                *color_space_mode = 3 << 0; /* IM_YUV_TO_RGB_BT709_LIMIT */
+            }
+            if (in->colorspace == AVCOL_SPC_BT470BG) {
+                out->colorspace   = AVCOL_SPC_BT470BG;
+                *color_space_mode = 1 << 0; /* IM_YUV_TO_RGB_BT601_LIMIT */
+            }
+            break;
+        case AVCOL_RANGE_JPEG:
+#if 0
+            if (in->colorspace == AVCOL_SPC_BT709) {
+                out->colorspace   = AVCOL_SPC_BT709;
+                *color_space_mode = 0xc << 8; /* yuv2rgb_709_full */
+            }
+#endif
+            if (in->colorspace == AVCOL_SPC_BT470BG) {
+                out->colorspace   = AVCOL_SPC_BT470BG;
+                *color_space_mode = 2 << 0; /* IM_YUV_TO_RGB_BT601_FULL */
+            }
+            break;
+        }
+        if (*color_space_mode) {
+            out->color_trc       = AVCOL_TRC_UNSPECIFIED;
+            out->color_primaries = AVCOL_PRI_UNSPECIFIED;
+            out->color_range     = AVCOL_RANGE_JPEG;
+        }
+    }
+}
+
+static int verify_rga_frame_info_io_dynamic(AVFilterContext *avctx,
+                                            RGAFrameInfo *in, RGAFrameInfo *out)
+{
+    RKRGAContext *r = avctx->priv;
+
+    if (!in || !out)
+        return AVERROR(EINVAL);
+
+    if (r->is_rga2_used && !r->has_rga2) {
+        av_log(avctx, AV_LOG_ERROR, "RGA2 is requested but not available\n");
+        return AVERROR(ENOSYS);
+    }
+    if (r->is_rga2_used &&
+        (in->pix_fmt == AV_PIX_FMT_P010 ||
+         out->pix_fmt == AV_PIX_FMT_P010)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' is not supported if RGA2 is requested\n",
+               av_get_pix_fmt_name(AV_PIX_FMT_P010));
+        return AVERROR(ENOSYS);
+    }
+    if (r->is_rga2_used &&
+        (out->pix_fmt == AV_PIX_FMT_NV15 ||
+         out->pix_fmt == AV_PIX_FMT_NV20)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' as output is not supported if RGA2 is requested\n",
+               av_get_pix_fmt_name(out->pix_fmt));
+        return AVERROR(ENOSYS);
+    }
+    if (r->is_rga2_used && in->crop && in->pix_desc->comp[0].depth >= 10) {
+        av_log(avctx, AV_LOG_ERROR, "Cropping 10-bit '%s' input is not supported if RGA2 is requested\n",
+               av_get_pix_fmt_name(in->pix_fmt));
+        return AVERROR(ENOSYS);
+    }
+    if (r->is_rga2_used &&
+        (out->act_w > 4096 || out->act_h > 4096)) {
+        av_log(avctx, AV_LOG_ERROR, "Max supported output size of RGA2 is 4096x4096\n");
+        return AVERROR(EINVAL);
+    }
+
+    return 0;
+}
+
+static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
+                              AVFrame *picref, int do_overlay, int pat_preproc)
+{
+    RGAFrame        *rga_frame;
+    AVFilterContext *ctx = inlink->dst;
+    rga_info_t info = { .mmuFlag = 1, };
+    int nb_link = FF_INLINK_IDX(inlink);
+    RGAFrameInfo *in_info = &r->in_rga_frame_infos[nb_link];
+    RGAFrameInfo *out_info = &r->out_rga_frame_info;
+    int w_stride = 0, h_stride = 0;
+    int ret;
+    const AVDRMFrameDescriptor *desc;
+    const AVDRMLayerDescriptor *layer;
+    const AVDRMPlaneDescriptor *plane0;
+    RGAFrame **frame_list = NULL;
+    int is_afbc = 0;
+
+    if (pat_preproc && !nb_link)
+        return NULL;
+
+    frame_list = nb_link ?
+        (pat_preproc ? &r->pat_preproc_frame_list : &r->pat_frame_list) : &r->src_frame_list;
+
+    clear_unused_frames(*frame_list);
+
+    rga_frame = get_free_frame(frame_list);
+    if (!rga_frame)
+        return NULL;
+
+    if (picref->format != AV_PIX_FMT_DRM_PRIME) {
+        av_log(ctx, AV_LOG_ERROR, "RGA gets a wrong frame\n");
+        return NULL;
+    }
+    rga_frame->frame = av_frame_clone(picref);
+
+    desc = (AVDRMFrameDescriptor *)rga_frame->frame->data[0];
+    if (desc->objects[0].fd < 0)
+        return NULL;
+
+    ret = get_pixel_stride(&desc->objects[0],
+                           &desc->layers[0],
+                           (in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
+                           (in_info->pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
+                           in_info->bytes_pp, &w_stride, &h_stride);
+    if (ret < 0 || !w_stride || !h_stride)
+        return NULL;
+
+    info.fd           = desc->objects[0].fd;
+    info.format       = in_info->rga_fmt;
+    info.in_fence_fd  = -1;
+    info.out_fence_fd = -1;
+
+    if (in_info->uncompact_10b_msb)
+        info.is_10b_compact = info.is_10b_endian = 1;
+
+    if (!nb_link) {
+        info.rotation = in_info->rotate_mode;
+        info.blend    = (do_overlay && !pat_preproc) ? in_info->blend_mode : 0;
+    }
+
+    is_afbc = drm_is_afbc(desc->objects[0].format_modifier);
+
+    if (is_afbc && (r->is_rga2_used || out_info->scheduler_core == 0x4)) {
+        av_log(ctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported by RGA2\n",
+               av_get_pix_fmt_name(in_info->pix_fmt));
+        return NULL;
+    }
+
+    /* verify inputs pixel stride */
+    if (out_info->scheduler_core > 0 &&
+        out_info->scheduler_core == (out_info->scheduler_core & 0x3)) {
+        if (!is_afbc && !is_pixel_stride_rga3_compat(w_stride, h_stride, in_info->rga_fmt)) {
+            r->is_rga2_used = 1;
+            av_log(ctx, AV_LOG_WARNING, "Input pixel stride (%dx%d) format %s is not supported by RGA3\n",
+                   w_stride, h_stride, av_get_pix_fmt_name(in_info->pix_fmt));
+        }
+
+        if ((ret = verify_rga_frame_info_io_dynamic(ctx, in_info, out_info)) < 0)
+            return NULL;
+
+        if (r->is_rga2_used)
+            out_info->scheduler_core = 0x4;
+    }
+
+    if (pat_preproc) {
+        RGAFrameInfo *in0_info = &r->in_rga_frame_infos[0];
+        rga_set_rect(&info.rect, 0, 0,
+                     FFMIN((in0_info->act_w - in_info->overlay_x), in_info->act_w),
+                     FFMIN((in0_info->act_h - in_info->overlay_y), in_info->act_h),
+                     w_stride, h_stride, in_info->rga_fmt);
+    } else
+        rga_set_rect(&info.rect, in_info->act_x, in_info->act_y,
+                     in_info->act_w, in_info->act_h,
+                     w_stride, h_stride, in_info->rga_fmt);
+
+    layer = &desc->layers[0];
+    plane0 = &layer->planes[0];
+    if (is_afbc) {
+        int afbc_offset_y = 0;
+        int hor_stride = plane0->pitch;
+        uint32_t drm_afbc_fmt = get_drm_afbc_format(in_info->pix_fmt);
+
+        if (layer->planes[0].offset > 0) {
+            afbc_offset_y = layer->planes[0].offset / hor_stride;
+            info.rect.yoffset += afbc_offset_y;
+        }
+
+        if (drm_afbc_fmt == layer->format) {
+            info.rect.wstride = FFALIGN(inlink->w, RK_RGA_AFBC_STRIDE_ALIGN);
+            info.rect.hstride = FFALIGN(inlink->h + afbc_offset_y, RK_RGA_AFBC_STRIDE_ALIGN);
+        } else {
+            av_log(ctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported\n",
+                   av_get_pix_fmt_name(in_info->pix_fmt));
+            return NULL;
+        }
+
+        info.rd_mode = 1 << 1; /* IM_FBC_MODE */
+    }
+
+    rga_frame->info = info;
+
+    return rga_frame;
+}
+
+static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
+                             const AVFrame *in, int pat_preproc)
+{
+    AVFilterContext *ctx = outlink->src;
+    AVFilterLink *inlink = ctx->inputs[0];
+    RGAFrame        *out_frame;
+    int              ret;
+    rga_info_t info = { .mmuFlag = 1, };
+    RGAFrameInfo *in0_info = &r->in_rga_frame_infos[0];
+    RGAFrameInfo *in1_info = ctx->nb_inputs > 1 ? &r->in_rga_frame_infos[1] : NULL;
+    RGAFrameInfo *out_info = pat_preproc ? in1_info : &r->out_rga_frame_info;
+    AVBufferRef *hw_frame_ctx = pat_preproc ? r->pat_preproc_hwframes_ctx : outlink->hw_frames_ctx;
+    int w_stride = 0, h_stride = 0;
+    AVDRMFrameDescriptor *desc;
+    AVDRMLayerDescriptor *layer;
+    RGAFrame **frame_list = NULL;
+
+    if (!out_info || !hw_frame_ctx)
+        return NULL;
+
+    frame_list = pat_preproc ? &r->pat_frame_list : &r->dst_frame_list;
+
+    clear_unused_frames(*frame_list);
+
+    out_frame = get_free_frame(frame_list);
+    if (!out_frame)
+        return NULL;
+
+    out_frame->frame = av_frame_alloc();
+    if (!out_frame->frame)
+        return NULL;
+
+    if (in && (ret = av_frame_copy_props(out_frame->frame, in)) < 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to copy metadata fields from in to out: %d\n", ret);
+        goto fail;
+    }
+
+    if ((ret = av_hwframe_get_buffer(hw_frame_ctx, out_frame->frame, 0)) < 0) {
+        av_log(ctx, AV_LOG_ERROR, "Cannot allocate an internal frame: %d\n", ret);
+        goto fail;
+    }
+
+    desc = (AVDRMFrameDescriptor *)out_frame->frame->data[0];
+    if (desc->objects[0].fd < 0)
+        goto fail;
+
+    ret = get_pixel_stride(&desc->objects[0],
+                           &desc->layers[0],
+                           (out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
+                           (out_info->pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
+                           out_info->bytes_pp, &w_stride, &h_stride);
+    if (ret < 0 || !w_stride || !h_stride)
+        goto fail;
+
+    info.fd           = desc->objects[0].fd;
+    info.format       = out_info->rga_fmt;
+    info.core         = out_info->scheduler_core;
+    info.in_fence_fd  = -1;
+    info.out_fence_fd = -1;
+    info.sync_mode    = RGA_BLIT_ASYNC;
+
+    if (out_info->uncompact_10b_msb)
+        info.is_10b_compact = info.is_10b_endian = 1;
+
+    if (!pat_preproc)
+        set_colorspace_info(in0_info, in, out_info, out_frame->frame, &info.color_space_mode);
+
+    if (pat_preproc)
+        rga_set_rect(&info.rect, in1_info->overlay_x, in1_info->overlay_y,
+                     FFMIN((in0_info->act_w - in1_info->overlay_x), in1_info->act_w),
+                     FFMIN((in0_info->act_h - in1_info->overlay_y), in1_info->act_h),
+                     w_stride, h_stride, in1_info->rga_fmt);
+    else
+        rga_set_rect(&info.rect, out_info->act_x, out_info->act_y,
+                     out_info->act_w, out_info->act_h,
+                     w_stride, h_stride, out_info->rga_fmt);
+
+    if (r->is_rga2_used || out_info->scheduler_core == 0x4) {
+        if (pat_preproc && (info.rect.width > 4096 || info.rect.height > 4096)) {
+            av_log(ctx, AV_LOG_ERROR, "Max supported output size of RGA2 is 4096x4096\n");
+            goto fail;
+        }
+        if (r->afbc_out && !pat_preproc) {
+            av_log(ctx, AV_LOG_WARNING, "Output format '%s' with AFBC modifier is not supported by RGA2\n",
+                   av_get_pix_fmt_name(out_info->pix_fmt));
+            r->afbc_out = 0;
+        }
+    }
+
+    if (r->afbc_out && !pat_preproc) {
+        uint32_t drm_afbc_fmt = get_drm_afbc_format(out_info->pix_fmt);
+
+        if (drm_afbc_fmt == DRM_FORMAT_INVALID) {
+            av_log(ctx, AV_LOG_WARNING, "Output format '%s' with AFBC modifier is not supported\n",
+                   av_get_pix_fmt_name(out_info->pix_fmt));
+            r->afbc_out = 0;
+            goto exit;
+        }
+
+        desc->objects[0].format_modifier =
+            DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
+
+        layer = &desc->layers[0];
+        layer->nb_planes = 1;
+        layer->format = drm_afbc_fmt;
+
+        /* Inverted RGB/BGR order in FBCE */
+        switch (info.rect.format) {
+        case RK_FORMAT_RGBA_8888:
+            info.rect.format = RK_FORMAT_BGRA_8888;
+            break;
+        case RK_FORMAT_BGRA_8888:
+            info.rect.format = RK_FORMAT_RGBA_8888;
+            break;
+        }
+
+        info.rect.wstride = FFALIGN(pat_preproc ? inlink->w : outlink->w, RK_RGA_AFBC_STRIDE_ALIGN);
+        info.rect.hstride = FFALIGN(pat_preproc ? inlink->h : outlink->h, RK_RGA_AFBC_STRIDE_ALIGN);
+        info.rd_mode = 1 << 1; /* IM_FBC_MODE */
+    }
+
+exit:
+    out_frame->info = info;
+
+    return out_frame;
+
+fail:
+    if (out_frame && out_frame->frame)
+        av_frame_free(&out_frame->frame);
+
+    return NULL;
+}
+
+static av_cold int init_hwframes_ctx(AVFilterContext *avctx)
+{
+    RKRGAContext      *r       = avctx->priv;
+    AVFilterLink      *inlink  = avctx->inputs[0];
+    AVFilterLink      *outlink = avctx->outputs[0];
+    AVHWFramesContext *hwfc_in;
+    AVHWFramesContext *hwfc_out;
+    AVBufferRef       *hwfc_out_ref;
+    int                ret;
+
+    if (!inlink->hw_frames_ctx)
+        return AVERROR(EINVAL);
+
+    hwfc_in = (AVHWFramesContext *)inlink->hw_frames_ctx->data;
+    hwfc_out_ref = av_hwframe_ctx_alloc(hwfc_in->device_ref);
+    if (!hwfc_out_ref)
+        return AVERROR(ENOMEM);
+
+    hwfc_out = (AVHWFramesContext *)hwfc_out_ref->data;
+    hwfc_out->format    = AV_PIX_FMT_DRM_PRIME;
+    hwfc_out->sw_format = r->out_sw_format;
+    hwfc_out->width     = outlink->w;
+    hwfc_out->height    = outlink->h;
+
+    ret = av_hwframe_ctx_init(hwfc_out_ref);
+    if (ret < 0) {
+        av_buffer_unref(&hwfc_out_ref);
+        av_log(avctx, AV_LOG_ERROR, "Error creating frames_ctx for output pad: %d\n", ret);
+        return ret;
+    }
+
+    av_buffer_unref(&outlink->hw_frames_ctx);
+    outlink->hw_frames_ctx = hwfc_out_ref;
+
+    return 0;
+}
+
+static av_cold int init_pat_preproc_hwframes_ctx(AVFilterContext *avctx)
+{
+    RKRGAContext      *r = avctx->priv;
+    AVFilterLink      *inlink0 = avctx->inputs[0];
+    AVFilterLink      *inlink1 = avctx->inputs[1];
+    AVHWFramesContext *hwfc_in0, *hwfc_in1;
+    AVHWFramesContext *hwfc_pat;
+    AVBufferRef       *hwfc_pat_ref;
+    int                ret;
+
+    if (!inlink0->hw_frames_ctx || !inlink1->hw_frames_ctx)
+        return AVERROR(EINVAL);
+
+    hwfc_in0 = (AVHWFramesContext *)inlink0->hw_frames_ctx->data;
+    hwfc_in1 = (AVHWFramesContext *)inlink1->hw_frames_ctx->data;
+    hwfc_pat_ref = av_hwframe_ctx_alloc(hwfc_in0->device_ref);
+    if (!hwfc_pat_ref)
+        return AVERROR(ENOMEM);
+
+    hwfc_pat = (AVHWFramesContext *)hwfc_pat_ref->data;
+    hwfc_pat->format    = AV_PIX_FMT_DRM_PRIME;
+    hwfc_pat->sw_format = hwfc_in1->sw_format;
+    hwfc_pat->width     = inlink0->w;
+    hwfc_pat->height    = inlink0->h;
+
+    ret = av_hwframe_ctx_init(hwfc_pat_ref);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Error creating frames_ctx for pat preproc: %d\n", ret);
+        av_buffer_unref(&hwfc_pat_ref);
+        return ret;
+    }
+
+    av_buffer_unref(&r->pat_preproc_hwframes_ctx);
+    r->pat_preproc_hwframes_ctx = hwfc_pat_ref;
+
+    return 0;
+}
+
+static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
+                                         RGAFrameInfo *src, RGAFrameInfo *dst, RGAFrameInfo *pat)
+{
+    RKRGAContext *r = avctx->priv;
+    float scale_ratio_min, scale_ratio_max;
+    float scale_ratio_w, scale_ratio_h;
+    int ret;
+
+    if (!src || !dst)
+        return AVERROR(EINVAL);
+
+    scale_ratio_w = (float)dst->act_w / (float)src->act_w;
+    scale_ratio_h = (float)dst->act_h / (float)src->act_h;
+
+    /* P010 requires RGA3 */
+    if (!r->has_rga3 &&
+        (src->pix_fmt == AV_PIX_FMT_P010 ||
+         dst->pix_fmt == AV_PIX_FMT_P010)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' is only supported by RGA3\n",
+               av_get_pix_fmt_name(AV_PIX_FMT_P010));
+        return AVERROR(ENOSYS);
+    }
+    /* Input formats that requires RGA2 */
+    if (!r->has_rga2 &&
+        (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
+         src->pix_fmt == AV_PIX_FMT_YUV420P ||
+         src->pix_fmt == AV_PIX_FMT_YUV422P ||
+         src->pix_fmt == AV_PIX_FMT_RGB555LE ||
+         src->pix_fmt == AV_PIX_FMT_BGR555LE)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' as input is only supported by RGA2\n",
+               av_get_pix_fmt_name(src->pix_fmt));
+        return AVERROR(ENOSYS);
+    }
+    /* Output formats that requires RGA2 */
+    if (!r->has_rga2 &&
+        (dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
+         dst->pix_fmt == AV_PIX_FMT_YUV420P ||
+         dst->pix_fmt == AV_PIX_FMT_YUV422P ||
+         dst->pix_fmt == AV_PIX_FMT_RGB555LE ||
+         dst->pix_fmt == AV_PIX_FMT_BGR555LE ||
+         dst->pix_fmt == AV_PIX_FMT_ARGB ||
+         dst->pix_fmt == AV_PIX_FMT_0RGB ||
+         dst->pix_fmt == AV_PIX_FMT_ABGR ||
+         dst->pix_fmt == AV_PIX_FMT_0BGR)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' as output is only supported by RGA2\n",
+               av_get_pix_fmt_name(dst->pix_fmt));
+        return AVERROR(ENOSYS);
+    }
+    /* P010 requires RGA3 but it can't handle certain formats */
+    if (src->pix_fmt == AV_PIX_FMT_P010 &&
+        (dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
+         dst->pix_fmt == AV_PIX_FMT_YUV420P ||
+         dst->pix_fmt == AV_PIX_FMT_YUV422P ||
+         dst->pix_fmt == AV_PIX_FMT_RGB555LE ||
+         dst->pix_fmt == AV_PIX_FMT_BGR555LE ||
+         dst->pix_fmt == AV_PIX_FMT_ARGB ||
+         dst->pix_fmt == AV_PIX_FMT_0RGB ||
+         dst->pix_fmt == AV_PIX_FMT_ABGR ||
+         dst->pix_fmt == AV_PIX_FMT_0BGR)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' to '%s' is not supported\n",
+               av_get_pix_fmt_name(src->pix_fmt),
+               av_get_pix_fmt_name(dst->pix_fmt));
+        return AVERROR(ENOSYS);
+    }
+    /* RGA3 only format to RGA2 only format is not supported */
+    if (dst->pix_fmt == AV_PIX_FMT_P010 &&
+        (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
+         src->pix_fmt == AV_PIX_FMT_YUV420P ||
+         src->pix_fmt == AV_PIX_FMT_YUV422P ||
+         src->pix_fmt == AV_PIX_FMT_RGB555LE ||
+         src->pix_fmt == AV_PIX_FMT_BGR555LE)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' to '%s' is not supported\n",
+               av_get_pix_fmt_name(src->pix_fmt),
+               av_get_pix_fmt_name(dst->pix_fmt));
+        return AVERROR(ENOSYS);
+    }
+
+    if (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
+        src->pix_fmt == AV_PIX_FMT_YUV420P ||
+        src->pix_fmt == AV_PIX_FMT_YUV422P ||
+        src->pix_fmt == AV_PIX_FMT_RGB555LE ||
+        src->pix_fmt == AV_PIX_FMT_BGR555LE ||
+        dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
+        dst->pix_fmt == AV_PIX_FMT_YUV420P ||
+        dst->pix_fmt == AV_PIX_FMT_YUV422P ||
+        dst->pix_fmt == AV_PIX_FMT_RGB555LE ||
+        dst->pix_fmt == AV_PIX_FMT_BGR555LE ||
+        dst->pix_fmt == AV_PIX_FMT_ARGB ||
+        dst->pix_fmt == AV_PIX_FMT_0RGB ||
+        dst->pix_fmt == AV_PIX_FMT_ABGR ||
+        dst->pix_fmt == AV_PIX_FMT_0BGR) {
+        r->is_rga2_used = 1;
+    }
+
+    r->is_rga2_used = r->is_rga2_used || !r->has_rga3;
+    if (r->has_rga3) {
+        if (scale_ratio_w < 0.125f ||
+            scale_ratio_w > 8.0f ||
+            scale_ratio_h < 0.125f ||
+            scale_ratio_h > 8.0f) {
+            r->is_rga2_used = 1;
+        }
+        if (src->act_w < 68 ||
+            src->act_w > 8176 ||
+            src->act_h > 8176 ||
+            dst->act_w < 68) {
+            r->is_rga2_used = 1;
+        }
+        if (pat && (pat->act_w < 68 ||
+             pat->act_w > 8176 ||
+             pat->act_h > 8176)) {
+            r->is_rga2_used = 1;
+        }
+    }
+
+    if ((ret = verify_rga_frame_info_io_dynamic(avctx, src, dst)) < 0)
+        return ret;
+
+    if (r->is_rga2_used)
+        r->scheduler_core = 0x4;
+
+    /* Prioritize RGA3 on multicore RGA hw to avoid dma32 & algorithm quirks as much as possible */
+    if (r->has_rga3 && r->has_rga2e && !r->is_rga2_used &&
+        (r->scheduler_core == 0 || avctx->nb_inputs > 1 ||
+         scale_ratio_w != 1.0f || scale_ratio_h != 1.0f ||
+         src->crop || src->uncompact_10b_msb || dst->uncompact_10b_msb)) {
+        r->scheduler_core = 0x3;
+    }
+
+    scale_ratio_max = 16.0f;
+    if ((r->is_rga2_used && r->has_rga2l) ||
+        (!r->is_rga2_used && r->has_rga3 && !r->has_rga2) ||
+        (r->scheduler_core > 0 && r->scheduler_core == (r->scheduler_core & 0x3))) {
+        scale_ratio_max = 8.0f;
+    }
+    scale_ratio_min = 1.0f / scale_ratio_max;
+
+    if (scale_ratio_w < scale_ratio_min || scale_ratio_w > scale_ratio_max ||
+        scale_ratio_h < scale_ratio_min || scale_ratio_h > scale_ratio_max) {
+        av_log(avctx, AV_LOG_ERROR, "RGA scale ratio (%.04fx%.04f) exceeds %.04f ~ %.04f.\n",
+               scale_ratio_w, scale_ratio_h, scale_ratio_min, scale_ratio_max);
+        return AVERROR(EINVAL);
+    }
+
+    return 0;
+}
+
+static av_cold int fill_rga_frame_info_by_link(AVFilterContext *avctx,
+                                               RGAFrameInfo *info,
+                                               AVFilterLink *link,
+                                               int nb_link, int is_inlink)
+{
+    AVHWFramesContext *hwfc;
+    RKRGAContext *r = avctx->priv;
+
+    if (!link->hw_frames_ctx || link->format != AV_PIX_FMT_DRM_PRIME)
+        return AVERROR(EINVAL);
+
+    hwfc = (AVHWFramesContext *)link->hw_frames_ctx->data;
+
+    if (!map_av_to_rga_format(hwfc->sw_format, &info->rga_fmt, (is_inlink && nb_link > 0))) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported '%s' pad %d format: '%s'\n",
+               (is_inlink ? "input" : "output"), nb_link,
+               av_get_pix_fmt_name(hwfc->sw_format));
+        return AVERROR(ENOSYS);
+    }
+
+    info->pix_fmt  = hwfc->sw_format;
+    info->pix_desc = av_pix_fmt_desc_get(info->pix_fmt);
+    info->bytes_pp = av_get_padded_bits_per_pixel(info->pix_desc) / 8.0f;
+
+    info->act_x    = 0;
+    info->act_y    = 0;
+    info->act_w    = link->w;
+    info->act_h    = link->h;
+
+    /* The w/h of RGA YUV image needs to be 2 aligned */
+    if (!(info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB)) {
+        info->act_w = ALIGN_DOWN(info->act_w, RK_RGA_YUV_ALIGN);
+        info->act_h = ALIGN_DOWN(info->act_h, RK_RGA_YUV_ALIGN);
+    }
+
+    info->uncompact_10b_msb = info->pix_fmt == AV_PIX_FMT_P010;
+
+    if (link->w * link->h > (3840 * 2160 * 3))
+        r->async_depth = FFMIN(r->async_depth, 1);
+
+    return 0;
+}
+
+av_cold int ff_rkrga_init(AVFilterContext *avctx, RKRGAParam *param)
+{
+    RKRGAContext *r = avctx->priv;
+    int i, ret;
+    const char *rga_ver = querystring(RGA_VERSION);
+
+    r->got_frame = 0;
+
+    r->has_rga2  = !!strstr(rga_ver, "RGA_2");
+    r->has_rga2l = !!strstr(rga_ver, "RGA_2_lite");
+    r->has_rga2e = !!strstr(rga_ver, "RGA_2_Enhance");
+    r->has_rga3  = !!strstr(rga_ver, "RGA_3");
+
+    if (!(r->has_rga2 || r->has_rga3)) {
+        av_log(avctx, AV_LOG_ERROR, "No RGA2/RGA3 hw available\n");
+        return AVERROR(ENOSYS);
+    }
+
+    /* RGA core */
+    if (r->scheduler_core && !(r->has_rga2 && r->has_rga3)) {
+        av_log(avctx, AV_LOG_WARNING, "Scheduler core cannot be set on non-multicore RGA hw, ignoring\n");
+        r->scheduler_core = 0;
+    }
+    if (r->scheduler_core && r->scheduler_core != (r->scheduler_core & 0x7)) {
+        av_log(avctx, AV_LOG_WARNING, "Invalid scheduler core set, ignoring\n");
+        r->scheduler_core = 0;
+    }
+    if (r->scheduler_core && r->scheduler_core == (r->scheduler_core & 0x3))
+        r->has_rga2 = r->has_rga2l = r->has_rga2e = 0;
+    if (r->scheduler_core == 0x4)
+        r->has_rga3 = 0;
+
+    r->filter_frame = param->filter_frame;
+    if (!r->filter_frame)
+         r->filter_frame = ff_filter_frame;
+    r->out_sw_format = param->out_sw_format;
+
+    /* OUT hwfc */
+    ret = init_hwframes_ctx(avctx);
+    if (ret < 0)
+        goto fail;
+
+    /* IN RGAFrameInfo */
+    r->in_rga_frame_infos = av_calloc(avctx->nb_inputs, sizeof(*r->in_rga_frame_infos));
+    if (!r->in_rga_frame_infos) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    for (i = 0; i < avctx->nb_inputs; i++) {
+        ret = fill_rga_frame_info_by_link(avctx, &r->in_rga_frame_infos[i], avctx->inputs[i], i, 1);
+        if (ret < 0)
+            goto fail;
+    }
+    if (avctx->nb_inputs == 1) {
+        r->in_rga_frame_infos[0].rotate_mode = param->in_rotate_mode;
+
+        if (param->in_crop) {
+            /* The x/y/w/h of RGA YUV image needs to be 2 aligned */
+            if (!(r->in_rga_frame_infos[0].pix_desc->flags & AV_PIX_FMT_FLAG_RGB)) {
+                param->in_crop_x = ALIGN_DOWN(param->in_crop_x, RK_RGA_YUV_ALIGN);
+                param->in_crop_y = ALIGN_DOWN(param->in_crop_y, RK_RGA_YUV_ALIGN);
+                param->in_crop_w = ALIGN_DOWN(param->in_crop_w, RK_RGA_YUV_ALIGN);
+                param->in_crop_h = ALIGN_DOWN(param->in_crop_h, RK_RGA_YUV_ALIGN);
+            }
+            r->in_rga_frame_infos[0].crop = 1;
+            r->in_rga_frame_infos[0].act_x = param->in_crop_x;
+            r->in_rga_frame_infos[0].act_y = param->in_crop_y;
+            r->in_rga_frame_infos[0].act_w = param->in_crop_w;
+            r->in_rga_frame_infos[0].act_h = param->in_crop_h;
+        }
+    }
+    if (avctx->nb_inputs > 1) {
+        const int premultiplied_alpha = r->in_rga_frame_infos[1].pix_desc->flags & AV_PIX_FMT_FLAG_ALPHA;
+
+        /* IM_ALPHA_BLEND_DST_OVER */
+        if (param->in_global_alpha > 0 && param->in_global_alpha < 0xff) {
+            r->in_rga_frame_infos[0].blend_mode = premultiplied_alpha ? (0x4 | (1 << 12)) : 0x4;
+            r->in_rga_frame_infos[0].blend_mode |= (param->in_global_alpha & 0xff) << 16; /* fg_global_alpha */
+            r->in_rga_frame_infos[0].blend_mode |= 0xff << 24;                            /* bg_global_alpha */
+        } else {
+            r->in_rga_frame_infos[0].blend_mode = premultiplied_alpha ? 0x504 : 0x501;
+            r->in_rga_frame_infos[0].blend_mode |= (0xff << 16) | (0xff << 24);
+        }
+
+        r->in_rga_frame_infos[1].overlay_x = FFMAX(param->overlay_x, 0);
+        r->in_rga_frame_infos[1].overlay_y = FFMAX(param->overlay_y, 0);
+
+        r->is_overlay_offset_valid = (param->overlay_x < r->in_rga_frame_infos[0].act_w - 2) &&
+            (param->overlay_y < r->in_rga_frame_infos[0].act_h - 2);
+        if (r->is_overlay_offset_valid)
+            init_pat_preproc_hwframes_ctx(avctx);
+    }
+
+    /* OUT RGAFrameInfo */
+    ret = fill_rga_frame_info_by_link(avctx, &r->out_rga_frame_info, avctx->outputs[0], 0, 0);
+    if (ret < 0)
+        goto fail;
+
+    /* Pre-check RGAFrameInfo */
+    ret = verify_rga_frame_info(avctx, &r->in_rga_frame_infos[0],
+                                &r->out_rga_frame_info,
+                                (avctx->nb_inputs > 1 ? &r->in_rga_frame_infos[1] : NULL));
+    if (ret < 0)
+        goto fail;
+
+    r->out_rga_frame_info.scheduler_core = r->scheduler_core;
+
+    /* keep fifo size at least 1. Even when async_depth is 0, fifo is used. */
+    r->async_fifo  = av_fifo_alloc2(r->async_depth + 1, sizeof(RGAAsyncFrame), 0);
+    if (!r->async_fifo) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    return 0;
+
+fail:
+    ff_rkrga_close(avctx);
+    return ret;
+}
+
+static void set_rga_async_frame_lock_status(RGAAsyncFrame *frame, int lock)
+{
+    int status = !!lock;
+
+    if (!frame)
+        return;
+
+    if (frame->src)
+        frame->src->locked = status;
+    if (frame->dst)
+        frame->dst->locked = status;
+    if (frame->pat)
+        frame->pat->locked = status;
+}
+
+av_cold int ff_rkrga_close(AVFilterContext *avctx)
+{
+    RKRGAContext *r = avctx->priv;
+
+    clear_frame_list(&r->src_frame_list);
+    clear_frame_list(&r->dst_frame_list);
+    clear_frame_list(&r->pat_frame_list);
+
+    clear_frame_list(&r->pat_preproc_frame_list);
+
+    av_fifo_freep2(&r->async_fifo);
+
+    av_buffer_unref(&r->pat_preproc_hwframes_ctx);
+
+    return 0;
+}
+
+static int call_rkrga_blit(AVFilterContext *avctx,
+                          rga_info_t *src_info,
+                          rga_info_t *dst_info,
+                          rga_info_t *pat_info)
+{
+    int ret;
+
+    if (!src_info || !dst_info)
+        return AVERROR(EINVAL);
+
+#define PRINT_RGA_INFO(ctx, info, name) do { \
+    if (info && name) \
+        av_log(ctx, AV_LOG_DEBUG, "RGA %s | fd:%d mmu:%d rd_mode:%d | x:%d y:%d w:%d h:%d ws:%d hs:%d fmt:0x%x\n", \
+               name, info->fd, info->mmuFlag, (info->rd_mode >> 1), info->rect.xoffset, info->rect.yoffset, \
+               info->rect.width, info->rect.height, info->rect.wstride, info->rect.hstride, (info->rect.format >> 8)); \
+} while (0)
+
+    PRINT_RGA_INFO(avctx, src_info, "src");
+    PRINT_RGA_INFO(avctx, dst_info, "dst");
+    PRINT_RGA_INFO(avctx, pat_info, "pat");
+#undef PRINT_RGA_INFO
+
+    if ((ret = c_RkRgaBlit(src_info, dst_info, pat_info)) != 0) {
+        av_log(avctx, AV_LOG_ERROR, "RGA blit failed: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+    if (dst_info->sync_mode == RGA_BLIT_ASYNC &&
+        dst_info->out_fence_fd <= 0) {
+        av_log(avctx, AV_LOG_ERROR, "RGA async blit returned invalid fence_fd: %d\n",
+               dst_info->out_fence_fd);
+        return AVERROR_EXTERNAL;
+    }
+
+    return 0;
+}
+
+int ff_rkrga_filter_frame(RKRGAContext *r,
+                          AVFilterLink *inlink_src, AVFrame *picref_src,
+                          AVFilterLink *inlink_pat, AVFrame *picref_pat)
+{
+    AVFilterContext  *ctx = inlink_src->dst;
+    AVFilterLink *outlink = ctx->outputs[0];
+    RGAAsyncFrame aframe;
+    RGAFrame *src_frame = NULL;
+    RGAFrame *dst_frame = NULL;
+    RGAFrame *pat_frame = NULL;
+    int ret, filter_ret;
+    int do_overlay = ctx->nb_inputs > 1 &&
+                     r->is_overlay_offset_valid &&
+                     inlink_pat && picref_pat;
+
+    /* Sync & Drain */
+    while (r->eof && av_fifo_read(r->async_fifo, &aframe, 1) >= 0) {
+        if (imsync(aframe.dst->info.out_fence_fd) != IM_STATUS_SUCCESS)
+            av_log(ctx, AV_LOG_WARNING, "RGA sync failed\n");
+
+        set_rga_async_frame_lock_status(&aframe, 0);
+
+        filter_ret = r->filter_frame(outlink, aframe.dst->frame);
+        if (filter_ret < 0) {
+            av_frame_free(&aframe.dst->frame);
+            return filter_ret;
+        }
+        aframe.dst->queued--;
+        r->got_frame = 1;
+        aframe.dst->frame = NULL;
+    }
+
+    if (!picref_src)
+        return 0;
+
+    /* SRC */
+    if (!(src_frame = submit_frame(r, inlink_src, picref_src, do_overlay, 0))) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to submit frame on input: %d\n",
+               FF_INLINK_IDX(inlink_src));
+        return AVERROR(ENOMEM);
+    }
+
+    /* DST */
+    if (!(dst_frame = query_frame(r, outlink, src_frame->frame, 0))) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to query an output frame\n");
+        return AVERROR(ENOMEM);
+    }
+
+    /* PAT */
+    if (do_overlay) {
+        RGAFrameInfo *in0_info = &r->in_rga_frame_infos[0];
+        RGAFrameInfo *in1_info = &r->in_rga_frame_infos[1];
+        RGAFrameInfo *out_info = &r->out_rga_frame_info;
+        RGAFrame *pat_in = NULL;
+        RGAFrame *pat_out = NULL;
+
+        /* translate PAT from top-left to (x,y) on a new image with the same size of SRC */
+        if (in1_info->act_w != in0_info->act_w ||
+            in1_info->act_h != in0_info->act_h ||
+            in1_info->overlay_x > 0 ||
+            in1_info->overlay_y > 0) {
+            if (!(pat_in = submit_frame(r, inlink_pat, picref_pat, 0, 1))) {
+                av_log(ctx, AV_LOG_ERROR, "Failed to submit frame on input: %d\n",
+                       FF_INLINK_IDX(inlink_pat));
+                return AVERROR(ENOMEM);
+            }
+            if (!(pat_out = query_frame(r, outlink, picref_pat, 1))) {
+                av_log(ctx, AV_LOG_ERROR, "Failed to query an output frame\n");
+                return AVERROR(ENOMEM);
+            }
+            dst_frame->info.core = out_info->scheduler_core;
+
+            pat_out->info.priority = 1;
+            pat_out->info.core = dst_frame->info.core;
+            pat_out->info.sync_mode = RGA_BLIT_SYNC;
+
+            /* Sync Blit Pre-Proc */
+            ret = call_rkrga_blit(ctx, &pat_in->info, &pat_out->info, NULL);
+            if (ret < 0)
+                return ret;
+
+            pat_out->info.rect.xoffset = 0;
+            pat_out->info.rect.yoffset = 0;
+            pat_out->info.rect.width   = in0_info->act_w;
+            pat_out->info.rect.height  = in0_info->act_h;
+
+            pat_frame = pat_out;
+        }
+
+        if (!pat_frame && !(pat_frame = submit_frame(r, inlink_pat, picref_pat, 0, 0))) {
+            av_log(ctx, AV_LOG_ERROR, "Failed to submit frame on input: %d\n",
+                   FF_INLINK_IDX(inlink_pat));
+            return AVERROR(ENOMEM);
+        }
+        dst_frame->info.core = out_info->scheduler_core;
+    }
+
+    /* Async Blit */
+    ret = call_rkrga_blit(ctx,
+                          &src_frame->info,
+                          &dst_frame->info,
+                          pat_frame ? &pat_frame->info : NULL);
+    if (ret < 0)
+        return ret;
+
+    dst_frame->queued++;
+    aframe = (RGAAsyncFrame){ src_frame, dst_frame, pat_frame };
+    set_rga_async_frame_lock_status(&aframe, 1);
+    av_fifo_write(r->async_fifo, &aframe, 1);
+
+    /* Sync & Retrieve */
+    if (av_fifo_can_read(r->async_fifo) > r->async_depth) {
+        av_fifo_read(r->async_fifo, &aframe, 1);
+        if (imsync(aframe.dst->info.out_fence_fd) != IM_STATUS_SUCCESS) {
+            av_log(ctx, AV_LOG_ERROR, "RGA sync failed\n");
+            return AVERROR_EXTERNAL;
+        }
+        set_rga_async_frame_lock_status(&aframe, 0);
+
+        filter_ret = r->filter_frame(outlink, aframe.dst->frame);
+        if (filter_ret < 0) {
+            av_frame_free(&aframe.dst->frame);
+            return filter_ret;
+        }
+        aframe.dst->queued--;
+        r->got_frame = 1;
+        aframe.dst->frame = NULL;
+    }
+
+    return 0;
+}
diff --git a/libavfilter/rkrga_common.h b/libavfilter/rkrga_common.h
new file mode 100644
index 00000000000..2ce2cebc190
--- /dev/null
+++ b/libavfilter/rkrga_common.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2023 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Rockchip RGA (2D Raster Graphic Acceleration) base function
+ */
+
+#ifndef AVFILTER_RKRGA_COMMON_H
+#define AVFILTER_RKRGA_COMMON_H
+
+#include <rga/RgaApi.h>
+#include <rga/im2d.h>
+
+#include "avfilter.h"
+#include "libavutil/fifo.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_rkmpp.h"
+
+#define ALIGN_DOWN(a, b) ((a) & ~((b)-1))
+#define RK_RGA_YUV_ALIGN         2
+#define RK_RGA_AFBC_STRIDE_ALIGN 16
+
+#define FF_INLINK_IDX(link)  ((int)((link)->dstpad - (link)->dst->input_pads))
+#define FF_OUTLINK_IDX(link) ((int)((link)->srcpad - (link)->src->output_pads))
+
+typedef struct RGAFrame {
+    AVFrame          *frame;
+    rga_info_t        info;
+    struct RGAFrame  *next;
+    int               queued;
+    int               locked;
+} RGAFrame;
+
+typedef struct RGAFrameInfo {
+    enum _Rga_SURF_FORMAT     rga_fmt;
+    enum AVPixelFormat        pix_fmt;
+    const AVPixFmtDescriptor *pix_desc;
+    float                     bytes_pp;
+    int                       act_x;
+    int                       act_y;
+    int                       act_w;
+    int                       act_h;
+    int                       uncompact_10b_msb;
+    int                       rotate_mode;
+    int                       blend_mode;
+    int                       crop;
+    int                       scheduler_core;
+    int                       overlay_x;
+    int                       overlay_y;
+} RGAFrameInfo;
+
+typedef struct RKRGAContext {
+    const AVClass      *class;
+
+    int (*filter_frame) (AVFilterLink *outlink, AVFrame *frame);
+    enum AVPixelFormat  out_sw_format;
+
+    RGAFrame           *src_frame_list;
+    RGAFrame           *dst_frame_list;
+    RGAFrame           *pat_frame_list;
+
+    AVBufferRef        *pat_preproc_hwframes_ctx;
+    RGAFrame           *pat_preproc_frame_list;
+
+    RGAFrameInfo       *in_rga_frame_infos;
+    RGAFrameInfo        out_rga_frame_info;
+
+    int scheduler_core;
+    int async_depth;
+    int afbc_out;
+
+    int has_rga2;
+    int has_rga2l;
+    int has_rga2e;
+    int has_rga3;
+    int is_rga2_used;
+    int is_overlay_offset_valid;
+
+    int eof;
+    int got_frame;
+
+    AVFifo *async_fifo;
+} RKRGAContext;
+
+typedef struct RKRGAParam {
+    int (*filter_frame)(AVFilterLink *outlink, AVFrame *frame);
+
+    enum AVPixelFormat out_sw_format;
+
+    int in_rotate_mode;
+    int in_global_alpha;
+
+    int in_crop;
+    int in_crop_x;
+    int in_crop_y;
+    int in_crop_w;
+    int in_crop_h;
+
+    int overlay_x;
+    int overlay_y;
+} RKRGAParam;
+
+int ff_rkrga_init(AVFilterContext *avctx, RKRGAParam *param);
+int ff_rkrga_close(AVFilterContext *avctx);
+int ff_rkrga_filter_frame(RKRGAContext *r,
+                          AVFilterLink *inlink_src, AVFrame *picref_src,
+                          AVFilterLink *inlink_pat, AVFrame *picref_pat);
+
+#endif /* AVFILTER_RKRGA_COMMON_H */
diff --git a/libavfilter/vf_overlay_rkrga.c b/libavfilter/vf_overlay_rkrga.c
new file mode 100644
index 00000000000..03803523c78
--- /dev/null
+++ b/libavfilter/vf_overlay_rkrga.c
@@ -0,0 +1,363 @@
+/*
+ * Copyright (c) 2023 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Rockchip RGA (2D Raster Graphic Acceleration) video compositor
+ */
+
+#include "libavutil/common.h"
+#include "libavutil/eval.h"
+#include "libavutil/internal.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+
+#include "filters.h"
+#include "framesync.h"
+
+#include "rkrga_common.h"
+
+enum var_name {
+    VAR_MAIN_W,    VAR_MW,
+    VAR_MAIN_H,    VAR_MH,
+    VAR_OVERLAY_W, VAR_OW,
+    VAR_OVERLAY_H, VAR_OH,
+    VAR_OVERLAY_X, VAR_OX,
+    VAR_OVERLAY_Y, VAR_OY,
+    VAR_VARS_NB
+};
+
+typedef struct RGAOverlayContext {
+    RKRGAContext rga;
+
+    FFFrameSync fs;
+
+    double var_values[VAR_VARS_NB];
+    char *overlay_ox, *overlay_oy;
+    int global_alpha;
+    enum AVPixelFormat format;
+} RGAOverlayContext;
+
+static const char *const var_names[] = {
+    "main_w",    "W", /* input width of the main layer */
+    "main_h",    "H", /* input height of the main layer */
+    "overlay_w", "w", /* input width of the overlay layer */
+    "overlay_h", "h", /* input height of the overlay layer */
+    "overlay_x", "x", /* x position of the overlay layer inside of main */
+    "overlay_y", "y", /* y position of the overlay layer inside of main */
+    NULL
+};
+
+static int eval_expr(AVFilterContext *ctx)
+{
+    RGAOverlayContext *r = ctx->priv;
+    double   *var_values = r->var_values;
+    int              ret = 0;
+    AVExpr *ox_expr = NULL, *oy_expr = NULL;
+    AVExpr *ow_expr = NULL, *oh_expr = NULL;
+
+#define PASS_EXPR(e, s) {\
+    ret = av_expr_parse(&e, s, var_names, NULL, NULL, NULL, NULL, 0, ctx); \
+    if (ret < 0) {\
+        av_log(ctx, AV_LOG_ERROR, "Error when passing '%s'.\n", s);\
+        goto release;\
+    }\
+}
+    PASS_EXPR(ox_expr, r->overlay_ox);
+    PASS_EXPR(oy_expr, r->overlay_oy);
+    PASS_EXPR(ow_expr, "overlay_w");
+    PASS_EXPR(oh_expr, "overlay_h");
+#undef PASS_EXPR
+
+    var_values[VAR_OVERLAY_W] =
+    var_values[VAR_OW]        = av_expr_eval(ow_expr, var_values, NULL);
+    var_values[VAR_OVERLAY_H] =
+    var_values[VAR_OH]        = av_expr_eval(oh_expr, var_values, NULL);
+
+    /* calc again in case ow is relative to oh */
+    var_values[VAR_OVERLAY_W] =
+    var_values[VAR_OW]        = av_expr_eval(ow_expr, var_values, NULL);
+
+    var_values[VAR_OVERLAY_X] =
+    var_values[VAR_OX]        = av_expr_eval(ox_expr, var_values, NULL);
+    var_values[VAR_OVERLAY_Y] =
+    var_values[VAR_OY]        = av_expr_eval(oy_expr, var_values, NULL);
+
+    /* calc again in case ox is relative to oy */
+    var_values[VAR_OVERLAY_X] =
+    var_values[VAR_OX]        = av_expr_eval(ox_expr, var_values, NULL);
+
+release:
+    av_expr_free(ox_expr);
+    av_expr_free(oy_expr);
+    av_expr_free(ow_expr);
+    av_expr_free(oh_expr);
+
+    return ret;
+}
+
+static av_cold int set_size_info(AVFilterContext *ctx,
+                                 AVFilterLink *inlink_main,
+                                 AVFilterLink *inlink_overlay,
+                                 AVFilterLink *outlink)
+{
+    RGAOverlayContext *r = ctx->priv;
+    int ret;
+
+    if (inlink_main->w < 2 || inlink_main->w > 8192 ||
+        inlink_main->h < 2 || inlink_main->h > 8192 ||
+        inlink_overlay->w < 2 || inlink_overlay->w > 8192 ||
+        inlink_overlay->h < 2 || inlink_overlay->h > 8192) {
+        av_log(ctx, AV_LOG_ERROR, "Supported input size is range from 2x2 ~ 8192x8192\n");
+        return AVERROR(EINVAL);
+    }
+
+    r->var_values[VAR_MAIN_W]    =
+    r->var_values[VAR_MW]        = inlink_main->w;
+    r->var_values[VAR_MAIN_H]    =
+    r->var_values[VAR_MH]        = inlink_main->h;
+
+    r->var_values[VAR_OVERLAY_W] = inlink_overlay->w;
+    r->var_values[VAR_OVERLAY_H] = inlink_overlay->h;
+
+    if ((ret = eval_expr(ctx)) < 0)
+        return ret;
+
+    outlink->w = r->var_values[VAR_MW];
+    outlink->h = r->var_values[VAR_MH];
+    if (outlink->w < 2 || outlink->w > 8128 ||
+        outlink->h < 2 || outlink->h > 8128) {
+        av_log(ctx, AV_LOG_ERROR, "Supported output size is range from 2x2 ~ 8128x8128\n");
+        return AVERROR(EINVAL);
+    }
+
+    if (inlink_main->sample_aspect_ratio.num)
+        outlink->sample_aspect_ratio = av_mul_q((AVRational){outlink->h * inlink_main->w,
+                                                             outlink->w * inlink_main->h},
+                                                inlink_main->sample_aspect_ratio);
+    else
+        outlink->sample_aspect_ratio = inlink_main->sample_aspect_ratio;
+
+    return 0;
+}
+
+static av_cold int rgaoverlay_config_props(AVFilterLink *outlink)
+{
+    AVFilterContext *ctx = outlink->src;
+    RGAOverlayContext *r = ctx->priv;
+    AVFilterLink *inlink_main    = ctx->inputs[0];
+    AVFilterLink *inlink_overlay = ctx->inputs[1];
+    AVHWFramesContext *frames_ctx_main;
+    AVHWFramesContext *frames_ctx_overlay;
+    enum AVPixelFormat in_format_main;
+    enum AVPixelFormat in_format_overlay;
+    enum AVPixelFormat out_format;
+    int ret;
+
+    RKRGAParam param = { NULL };
+
+    if (!inlink_main->hw_frames_ctx) {
+        av_log(ctx, AV_LOG_ERROR, "No hw context provided on main input\n");
+        return AVERROR(EINVAL);
+    }
+    frames_ctx_main = (AVHWFramesContext *)inlink_main->hw_frames_ctx->data;
+    in_format_main  = frames_ctx_main->sw_format;
+    out_format      = (r->format == AV_PIX_FMT_NONE) ? in_format_main : r->format;
+
+    if (!inlink_overlay->hw_frames_ctx) {
+        av_log(ctx, AV_LOG_ERROR, "No hw context provided on overlay input\n");
+        return AVERROR(EINVAL);
+    }
+    frames_ctx_overlay = (AVHWFramesContext *)inlink_overlay->hw_frames_ctx->data;
+    in_format_overlay  = frames_ctx_overlay->sw_format;
+
+    ret = set_size_info(ctx, inlink_main, inlink_overlay, outlink);
+    if (ret < 0)
+        return ret;
+
+    param.filter_frame    = NULL;
+    param.out_sw_format   = out_format;
+    param.in_global_alpha = r->global_alpha;
+    param.overlay_x       = r->var_values[VAR_OX];
+    param.overlay_y       = r->var_values[VAR_OY];
+
+    ret = ff_rkrga_init(ctx, &param);
+    if (ret < 0)
+        return ret;
+
+    av_log(ctx, AV_LOG_VERBOSE, "w:%d h:%d fmt:%s + w:%d h:%d fmt:%s (x:%d y:%d) -> w:%d h:%d fmt:%s\n",
+           inlink_main->w, inlink_main->h, av_get_pix_fmt_name(in_format_main),
+           inlink_overlay->w, inlink_overlay->h, av_get_pix_fmt_name(in_format_overlay),
+           param.overlay_x, param.overlay_y, outlink->w, outlink->h, av_get_pix_fmt_name(out_format));
+
+    ret = ff_framesync_init_dualinput(&r->fs, ctx);
+    if (ret < 0)
+        return ret;
+
+    r->fs.time_base = outlink->time_base = inlink_main->time_base;
+
+    ret = ff_framesync_configure(&r->fs);
+    if (ret < 0)
+        return ret;
+
+    return 0;
+}
+
+static int rgaoverlay_on_event(FFFrameSync *fs)
+{
+    AVFilterContext *ctx         = fs->parent;
+    AVFilterLink *inlink_main    = ctx->inputs[0];
+    AVFilterLink *inlink_overlay = ctx->inputs[1];
+    AVFrame *in_main = NULL, *in_overlay = NULL;
+    int ret;
+
+    RGAOverlayContext *r = ctx->priv;
+
+    ret = ff_framesync_get_frame(fs, 0, &in_main, 0);
+    if (ret < 0)
+        return ret;
+    ret = ff_framesync_get_frame(fs, 1, &in_overlay, 0);
+    if (ret < 0)
+        return ret;
+
+    if (!in_main)
+        return AVERROR_BUG;
+
+    return ff_rkrga_filter_frame(&r->rga,
+                                 inlink_main, in_main,
+                                 inlink_overlay, in_overlay);
+}
+
+static av_cold int rgaoverlay_init(AVFilterContext *ctx)
+{
+    RGAOverlayContext *r = ctx->priv;
+
+    r->fs.on_event = &rgaoverlay_on_event;
+
+    return 0;
+}
+
+static av_cold void rgaoverlay_uninit(AVFilterContext *ctx)
+{
+    RGAOverlayContext *r = ctx->priv;
+
+    ff_framesync_uninit(&r->fs);
+
+    ff_rkrga_close(ctx);
+}
+
+static int rgaoverlay_activate(AVFilterContext *ctx)
+{
+    RGAOverlayContext *r = ctx->priv;
+    AVFilterLink *inlink_main    = ctx->inputs[0];
+    AVFilterLink *inlink_overlay = ctx->inputs[1];
+    AVFilterLink *outlink        = ctx->outputs[0];
+    int i, ret;
+
+    ret = ff_framesync_activate(&r->fs);
+    if (ret < 0)
+        return ret;
+
+    if (r->fs.eof) {
+        r->rga.eof = 1;
+        goto eof;
+    }
+
+    if (!r->rga.got_frame) {
+        for (i = 0; i < ctx->nb_inputs; i++) {
+            if (!ff_inlink_check_available_frame(ctx->inputs[i])) {
+                FF_FILTER_FORWARD_WANTED(outlink, ctx->inputs[i]);
+            }
+        }
+        return FFERROR_NOT_READY;
+    } else
+        r->rga.got_frame = 0;
+
+    return 0;
+
+eof:
+    ff_rkrga_filter_frame(&r->rga,
+                          inlink_main, NULL,
+                          inlink_overlay, NULL);
+    ff_outlink_set_status(outlink, AVERROR_EOF, AV_NOPTS_VALUE);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(RGAOverlayContext, x)
+#define FLAGS (AV_OPT_FLAG_FILTERING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
+
+static const AVOption rgaoverlay_options[] = {
+    { "x", "Overlay x position", OFFSET(overlay_ox), AV_OPT_TYPE_STRING, { .str = "0" }, 0, 0, .flags = FLAGS },
+    { "y", "Overlay y position", OFFSET(overlay_oy), AV_OPT_TYPE_STRING, { .str = "0" }, 0, 0, .flags = FLAGS },
+    { "alpha", "Overlay global alpha", OFFSET(global_alpha), AV_OPT_TYPE_INT, { .i64 = 255 }, 0, 255, .flags = FLAGS },
+    { "format", "Output video pixel format", OFFSET(format), AV_OPT_TYPE_PIXEL_FMT, { .i64 = AV_PIX_FMT_NONE }, INT_MIN, INT_MAX, .flags = FLAGS },
+    { "eof_action", "Action to take when encountering EOF from secondary input ",
+        OFFSET(fs.opt_eof_action), AV_OPT_TYPE_INT, { .i64 = EOF_ACTION_REPEAT },
+        EOF_ACTION_REPEAT, EOF_ACTION_PASS, .flags = FLAGS, "eof_action" },
+        { "repeat", "Repeat the previous frame.",   0, AV_OPT_TYPE_CONST, { .i64 = EOF_ACTION_REPEAT }, .flags = FLAGS, "eof_action" },
+        { "endall", "End both streams.",            0, AV_OPT_TYPE_CONST, { .i64 = EOF_ACTION_ENDALL }, .flags = FLAGS, "eof_action" },
+        { "pass",   "Pass through the main input.", 0, AV_OPT_TYPE_CONST, { .i64 = EOF_ACTION_PASS },   .flags = FLAGS, "eof_action" },
+    { "shortest", "Force termination when the shortest input terminates", OFFSET(fs.opt_shortest), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, FLAGS },
+    { "repeatlast", "Repeat overlay of the last overlay frame", OFFSET(fs.opt_repeatlast), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, FLAGS },
+    { "core", "Set multicore RGA scheduler core [use with caution]", OFFSET(rga.scheduler_core), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, 0, INT_MAX, FLAGS, "core" },
+        { "default",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, "core" },
+        { "rga3_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE0 */
+        { "rga3_core1", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE1 */
+        { "rga2_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 4 }, 0, 0, FLAGS, "core" }, /* RGA2_SCHEDULER_CORE0 */
+    { "async_depth", "Set the internal parallelization depth", OFFSET(rga.async_depth), AV_OPT_TYPE_INT, { .i64 = 2 }, 0, 4, .flags = FLAGS },
+    { "afbc", "Enable AFBC (Arm Frame Buffer Compression) to save bandwidth", OFFSET(rga.afbc_out), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },
+    { NULL },
+};
+
+FRAMESYNC_DEFINE_CLASS(rgaoverlay, RGAOverlayContext, fs);
+
+static const AVFilterPad rgaoverlay_inputs[] = {
+    {
+        .name             = "main",
+        .type             = AVMEDIA_TYPE_VIDEO,
+    },
+    {
+        .name             = "overlay",
+        .type             = AVMEDIA_TYPE_VIDEO,
+    },
+};
+
+static const AVFilterPad rgaoverlay_outputs[] = {
+    {
+        .name             = "default",
+        .type             = AVMEDIA_TYPE_VIDEO,
+        .config_props     = rgaoverlay_config_props,
+    },
+};
+
+const AVFilter ff_vf_overlay_rkrga = {
+    .name           = "overlay_rkrga",
+    .description    = NULL_IF_CONFIG_SMALL("Rockchip RGA (2D Raster Graphic Acceleration) video compositor"),
+    .priv_size      = sizeof(RGAOverlayContext),
+    .priv_class     = &rgaoverlay_class,
+    .init           = rgaoverlay_init,
+    .uninit         = rgaoverlay_uninit,
+    .activate       = rgaoverlay_activate,
+    FILTER_INPUTS(rgaoverlay_inputs),
+    FILTER_OUTPUTS(rgaoverlay_outputs),
+    FILTER_SINGLE_PIXFMT(AV_PIX_FMT_DRM_PRIME),
+    .preinit        = rgaoverlay_framesync_preinit,
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
new file mode 100644
index 00000000000..3c9c2e1c218
--- /dev/null
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -0,0 +1,477 @@
+/*
+ * Copyright (c) 2023 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Rockchip RGA (2D Raster Graphic Acceleration) video post-process (scale/crop/transpose)
+ */
+
+#include "config_components.h"
+
+#include "libavutil/common.h"
+#include "libavutil/eval.h"
+#include "libavutil/internal.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+
+#include "filters.h"
+#include "scale_eval.h"
+#include "transpose.h"
+
+#include "rkrga_common.h"
+
+typedef struct RGAVppContext {
+    RKRGAContext rga;
+
+    enum AVPixelFormat format;
+    int transpose;
+    int force_original_aspect_ratio;
+    int force_divisible_by;
+    int scheduler_core;
+
+    int in_rotate_mode;
+
+    char *ow, *oh;
+    char *cx, *cy, *cw, *ch;
+    int crop;
+
+    int act_x, act_y;
+    int act_w, act_h;
+} RGAVppContext;
+
+static const char *const var_names[] = {
+    "iw", "in_w",
+    "ih", "in_h",
+    "ow", "out_w", "w",
+    "oh", "out_h", "h",
+    "cw",
+    "ch",
+    "cx",
+    "cy",
+    "a", "dar",
+    "sar",
+    NULL
+};
+
+enum var_name {
+    VAR_IW, VAR_IN_W,
+    VAR_IH, VAR_IN_H,
+    VAR_OW, VAR_OUT_W, VAR_W,
+    VAR_OH, VAR_OUT_H, VAR_H,
+    VAR_CW,
+    VAR_CH,
+    VAR_CX,
+    VAR_CY,
+    VAR_A, VAR_DAR,
+    VAR_SAR,
+    VAR_VARS_NB
+};
+
+static av_cold int eval_expr(AVFilterContext *ctx,
+                             int *ret_w, int *ret_h,
+                             int *ret_cx, int *ret_cy,
+                             int *ret_cw, int *ret_ch)
+{
+#define PASS_EXPR(e, s) {\
+    if (s) {\
+        ret = av_expr_parse(&e, s, var_names, NULL, NULL, NULL, NULL, 0, ctx); \
+        if (ret < 0) {                                                  \
+            av_log(ctx, AV_LOG_ERROR, "Error when passing '%s'.\n", s); \
+            goto release;                                               \
+        }                                                               \
+    }\
+}
+#define CALC_EXPR(e, v, i, d) {\
+    if (e)\
+        i = v = av_expr_eval(e, var_values, NULL);      \
+    else\
+        i = v = d;\
+}
+    RGAVppContext *r = ctx->priv;
+    double  var_values[VAR_VARS_NB] = { NAN };
+    AVExpr *w_expr  = NULL, *h_expr  = NULL;
+    AVExpr *cw_expr = NULL, *ch_expr = NULL;
+    AVExpr *cx_expr = NULL, *cy_expr = NULL;
+    int     ret = 0;
+
+    PASS_EXPR(cw_expr, r->cw);
+    PASS_EXPR(ch_expr, r->ch);
+
+    PASS_EXPR(w_expr, r->ow);
+    PASS_EXPR(h_expr, r->oh);
+
+    PASS_EXPR(cx_expr, r->cx);
+    PASS_EXPR(cy_expr, r->cy);
+
+    var_values[VAR_IW] =
+    var_values[VAR_IN_W] = ctx->inputs[0]->w;
+
+    var_values[VAR_IH] =
+    var_values[VAR_IN_H] = ctx->inputs[0]->h;
+
+    var_values[VAR_A] = (double)var_values[VAR_IN_W] / var_values[VAR_IN_H];
+    var_values[VAR_SAR] = ctx->inputs[0]->sample_aspect_ratio.num ?
+        (double)ctx->inputs[0]->sample_aspect_ratio.num / ctx->inputs[0]->sample_aspect_ratio.den : 1;
+    var_values[VAR_DAR] = var_values[VAR_A] * var_values[VAR_SAR];
+
+    /* crop params */
+    CALC_EXPR(cw_expr, var_values[VAR_CW], *ret_cw, var_values[VAR_IW]);
+    CALC_EXPR(ch_expr, var_values[VAR_CH], *ret_ch, var_values[VAR_IH]);
+
+    /* calc again in case cw is relative to ch */
+    CALC_EXPR(cw_expr, var_values[VAR_CW], *ret_cw, var_values[VAR_IW]);
+
+    CALC_EXPR(w_expr,
+              var_values[VAR_OUT_W] = var_values[VAR_OW] = var_values[VAR_W],
+              *ret_w, var_values[VAR_CW]);
+    CALC_EXPR(h_expr,
+              var_values[VAR_OUT_H] = var_values[VAR_OH] = var_values[VAR_H],
+              *ret_h, var_values[VAR_CH]);
+
+    /* calc again in case ow is relative to oh */
+    CALC_EXPR(w_expr,
+              var_values[VAR_OUT_W] = var_values[VAR_OW] = var_values[VAR_W],
+              *ret_w, var_values[VAR_CW]);
+
+    CALC_EXPR(cx_expr, var_values[VAR_CX], *ret_cx, (var_values[VAR_IW] - var_values[VAR_OW]) / 2);
+    CALC_EXPR(cy_expr, var_values[VAR_CY], *ret_cy, (var_values[VAR_IH] - var_values[VAR_OH]) / 2);
+
+    /* calc again in case cx is relative to cy */
+    CALC_EXPR(cx_expr, var_values[VAR_CX], *ret_cx, (var_values[VAR_IW] - var_values[VAR_OW]) / 2);
+
+    r->crop = (*ret_cw != var_values[VAR_IW]) || (*ret_ch != var_values[VAR_IH]);
+
+release:
+    av_expr_free(w_expr);
+    av_expr_free(h_expr);
+    av_expr_free(cw_expr);
+    av_expr_free(ch_expr);
+    av_expr_free(cx_expr);
+    av_expr_free(cy_expr);
+#undef PASS_EXPR
+#undef CALC_EXPR
+
+    return ret;
+}
+
+static av_cold int set_size_info(AVFilterContext *ctx,
+                                 AVFilterLink *inlink,
+                                 AVFilterLink *outlink)
+{
+    RGAVppContext *r = ctx->priv;
+    int w, h, ret;
+
+    if (inlink->w < 2 || inlink->w > 8192 ||
+        inlink->h < 2 || inlink->h > 8192) {
+        av_log(ctx, AV_LOG_ERROR, "Supported input size is range from 2x2 ~ 8192x8192\n");
+        return AVERROR(EINVAL);
+    }
+
+    if ((ret = eval_expr(ctx, &w, &h, &r->act_x, &r->act_y, &r->act_w, &r->act_h)) < 0)
+        return ret;
+
+    r->act_x = FFMAX(FFMIN(r->act_x, inlink->w), 0);
+    r->act_y = FFMAX(FFMIN(r->act_y, inlink->h), 0);
+    r->act_w = FFMAX(FFMIN(r->act_w, inlink->w), 0);
+    r->act_h = FFMAX(FFMIN(r->act_h, inlink->h), 0);
+
+    r->act_x = FFMIN(r->act_x, inlink->w - r->act_w);
+    r->act_y = FFMIN(r->act_y, inlink->h - r->act_h);
+    r->act_w = FFMIN(r->act_w, inlink->w - r->act_x);
+    r->act_h = FFMIN(r->act_h, inlink->h - r->act_y);
+
+    ff_scale_adjust_dimensions(inlink, &w, &h,
+                               r->force_original_aspect_ratio, r->force_divisible_by);
+
+    if (((int64_t)h * inlink->w) > INT_MAX ||
+        ((int64_t)w * inlink->h) > INT_MAX) {
+        av_log(ctx, AV_LOG_ERROR, "Rescaled value for width or height is too big.\n");
+        return AVERROR(EINVAL);
+    }
+
+    outlink->w = w;
+    outlink->h = h;
+    if (outlink->w < 2 || outlink->w > 8128 ||
+        outlink->h < 2 || outlink->h > 8128) {
+        av_log(ctx, AV_LOG_ERROR, "Supported output size is range from 2x2 ~ 8128x8128\n");
+        return AVERROR(EINVAL);
+    }
+
+    if (inlink->sample_aspect_ratio.num)
+        outlink->sample_aspect_ratio = av_mul_q((AVRational){outlink->h * inlink->w,
+                                                             outlink->w * inlink->h},
+                                                inlink->sample_aspect_ratio);
+    else
+        outlink->sample_aspect_ratio = inlink->sample_aspect_ratio;
+
+    if (r->transpose >= 0) {
+        switch (r->transpose) {
+        case TRANSPOSE_CCLOCK_FLIP:
+            r->in_rotate_mode = 0x07 | (0x01 << 4); /* HAL_TRANSFORM_ROT_270 | (HAL_TRANSFORM_FLIP_H << 4) */
+            FFSWAP(int, outlink->w, outlink->h);
+            FFSWAP(int, outlink->sample_aspect_ratio.num, outlink->sample_aspect_ratio.den);
+            break;
+        case TRANSPOSE_CLOCK:
+            r->in_rotate_mode = 0x04; /* HAL_TRANSFORM_ROT_90 */
+            FFSWAP(int, outlink->w, outlink->h);
+            FFSWAP(int, outlink->sample_aspect_ratio.num, outlink->sample_aspect_ratio.den);
+            break;
+        case TRANSPOSE_CCLOCK:
+            r->in_rotate_mode = 0x07; /* HAL_TRANSFORM_ROT_270 */
+            FFSWAP(int, outlink->w, outlink->h);
+            FFSWAP(int, outlink->sample_aspect_ratio.num, outlink->sample_aspect_ratio.den);
+            break;
+        case TRANSPOSE_CLOCK_FLIP:
+            r->in_rotate_mode = 0x04 | (0x01 << 4); /* HAL_TRANSFORM_ROT_90 | (HAL_TRANSFORM_FLIP_H << 4) */
+            FFSWAP(int, outlink->w, outlink->h);
+            FFSWAP(int, outlink->sample_aspect_ratio.num, outlink->sample_aspect_ratio.den);
+            break;
+        case TRANSPOSE_REVERSAL:
+            r->in_rotate_mode = 0x03; /* HAL_TRANSFORM_ROT_180 */
+            break;
+        case TRANSPOSE_HFLIP:
+            r->in_rotate_mode = 0x01; /* HAL_TRANSFORM_FLIP_H */
+            break;
+        case TRANSPOSE_VFLIP:
+            r->in_rotate_mode = 0x02; /* HAL_TRANSFORM_FLIP_V */
+            break;
+        default:
+            av_log(ctx, AV_LOG_ERROR, "Failed to set transpose mode to %d\n", r->transpose);
+            return AVERROR(EINVAL);
+        }
+    }
+
+    return 0;
+}
+
+static av_cold int rgavpp_config_props(AVFilterLink *outlink)
+{
+    AVFilterContext *ctx = outlink->src;
+    RGAVppContext     *r = ctx->priv;
+    AVFilterLink *inlink = ctx->inputs[0];
+    AVHWFramesContext *in_frames_ctx;
+    enum AVPixelFormat in_format;
+    enum AVPixelFormat out_format;
+    RKRGAParam param = { NULL };
+    int ret;
+
+    if (!inlink->hw_frames_ctx) {
+        av_log(ctx, AV_LOG_ERROR, "No hw context provided on input\n");
+        return AVERROR(EINVAL);
+    }
+    in_frames_ctx = (AVHWFramesContext *)inlink->hw_frames_ctx->data;
+    in_format     = in_frames_ctx->sw_format;
+    out_format    = (r->format == AV_PIX_FMT_NONE) ? in_format : r->format;
+
+    ret = set_size_info(ctx, inlink, outlink);
+    if (ret < 0)
+        return ret;
+
+    param.filter_frame   = NULL;
+    param.out_sw_format  = out_format;
+    param.in_rotate_mode = r->in_rotate_mode;
+    param.in_crop        = r->crop;
+    param.in_crop_x      = r->act_x;
+    param.in_crop_y      = r->act_y;
+    param.in_crop_w      = r->act_w;
+    param.in_crop_h      = r->act_h;
+
+    ret = ff_rkrga_init(ctx, &param);
+    if (ret < 0)
+        return ret;
+
+    av_log(ctx, AV_LOG_VERBOSE, "w:%d h:%d fmt:%s -> w:%d h:%d fmt:%s\n",
+           inlink->w, inlink->h, av_get_pix_fmt_name(in_format),
+           outlink->w, outlink->h, av_get_pix_fmt_name(out_format));
+
+    return 0;
+}
+
+static int rgavpp_activate(AVFilterContext *ctx)
+{
+    AVFilterLink  *inlink = ctx->inputs[0];
+    AVFilterLink *outlink = ctx->outputs[0];
+    RGAVppContext      *r = ctx->priv;
+    AVFrame *in = NULL;
+    int ret, status = 0;
+    int64_t pts = AV_NOPTS_VALUE;
+
+    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);
+
+    if (!r->rga.eof) {
+        ret = ff_inlink_consume_frame(inlink, &in);
+        if (ret < 0)
+            return ret;
+
+        if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {
+            if (status == AVERROR_EOF) {
+                r->rga.eof = 1;
+            }
+        }
+    }
+
+    if (in || r->rga.eof) {
+        ret = ff_rkrga_filter_frame(&r->rga, inlink, in, NULL, NULL);
+        av_frame_free(&in);
+        if (ret < 0)
+            return ret;
+        else if (!r->rga.got_frame)
+            goto not_ready;
+
+        if (r->rga.eof)
+            goto eof;
+
+        if (r->rga.got_frame) {
+            r->rga.got_frame = 0;
+            return 0;
+        }
+    }
+
+not_ready:
+    if (r->rga.eof)
+        goto eof;
+
+    FF_FILTER_FORWARD_WANTED(outlink, inlink);
+    return FFERROR_NOT_READY;
+
+eof:
+    pts = av_rescale_q(pts, inlink->time_base, outlink->time_base);
+    ff_outlink_set_status(outlink, status, pts);
+    return 0;
+}
+
+static av_cold int rgavpp_init(AVFilterContext *ctx)
+{
+    return 0;
+}
+
+static av_cold void rgavpp_uninit(AVFilterContext *ctx)
+{
+    ff_rkrga_close(ctx);
+}
+
+#define OFFSET(x) offsetof(RGAVppContext, x)
+#define FLAGS (AV_OPT_FLAG_FILTERING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
+
+#define RKRGA_VPP_COMMON_OPTS \
+    { "force_original_aspect_ratio", "Decrease or increase w/h if necessary to keep the original AR", OFFSET(force_original_aspect_ratio), AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 2, FLAGS, "force_oar" }, \
+        { "disable",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, "force_oar" }, \
+        { "decrease", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "force_oar" }, \
+        { "increase", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, "force_oar" }, \
+    { "force_divisible_by", "Enforce that the output resolution is divisible by a defined integer when force_original_aspect_ratio is used", OFFSET(force_divisible_by), AV_OPT_TYPE_INT, { .i64 = 2 }, 1, 256, FLAGS }, \
+    { "core", "Set multicore RGA scheduler core [use with caution]", OFFSET(rga.scheduler_core), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, 0, INT_MAX, FLAGS, "core" }, \
+        { "default",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, "core" }, \
+        { "rga3_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE0 */ \
+        { "rga3_core1", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE1 */ \
+        { "rga2_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 4 }, 0, 0, FLAGS, "core" }, /* RGA2_SCHEDULER_CORE0 */ \
+    { "async_depth", "Set the internal parallelization depth", OFFSET(rga.async_depth), AV_OPT_TYPE_INT, { .i64 = 2 }, 0, 4, .flags = FLAGS }, \
+    { "afbc", "Enable AFBC (Arm Frame Buffer Compression) to save bandwidth", OFFSET(rga.afbc_out), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },
+
+static const AVFilterPad rgavpp_inputs[] = {
+    {
+        .name             = "default",
+        .type             = AVMEDIA_TYPE_VIDEO,
+    },
+};
+
+static const AVFilterPad rgavpp_outputs[] = {
+    {
+        .name             = "default",
+        .type             = AVMEDIA_TYPE_VIDEO,
+        .config_props     = rgavpp_config_props,
+    },
+};
+
+#if CONFIG_SCALE_RKRGA_FILTER
+
+static const AVOption rgascale_options[] = {
+    { "w",  "Output video width",  OFFSET(ow), AV_OPT_TYPE_STRING, { .str = "iw" }, 0, 0, FLAGS },
+    { "h",  "Output video height", OFFSET(oh), AV_OPT_TYPE_STRING, { .str = "ih" }, 0, 0, FLAGS },
+    { "format", "Output video pixel format", OFFSET(format), AV_OPT_TYPE_PIXEL_FMT, { .i64 = AV_PIX_FMT_NONE }, INT_MIN, INT_MAX, .flags = FLAGS },
+    RKRGA_VPP_COMMON_OPTS
+    { NULL },
+};
+
+static av_cold int rgascale_preinit(AVFilterContext *ctx)
+{
+    RGAVppContext *r = ctx->priv;
+
+    r->transpose = -1;
+    return 0;
+}
+
+AVFILTER_DEFINE_CLASS(rgascale);
+
+const AVFilter ff_vf_scale_rkrga = {
+    .name           = "scale_rkrga",
+    .description    = NULL_IF_CONFIG_SMALL("Rockchip RGA (2D Raster Graphic Acceleration) video resizer and format converter"),
+    .priv_size      = sizeof(RGAVppContext),
+    .priv_class     = &rgascale_class,
+    .preinit        = rgascale_preinit,
+    .init           = rgavpp_init,
+    .uninit         = rgavpp_uninit,
+    FILTER_INPUTS(rgavpp_inputs),
+    FILTER_OUTPUTS(rgavpp_outputs),
+    FILTER_SINGLE_PIXFMT(AV_PIX_FMT_DRM_PRIME),
+    .activate       = rgavpp_activate,
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
+
+#endif
+
+#if CONFIG_VPP_RKRGA_FILTER
+
+static const AVOption rgavpp_options[] = {
+    { "w",  "Output video width",                  OFFSET(ow), AV_OPT_TYPE_STRING, { .str = "cw" }, 0, 0, FLAGS },
+    { "h",  "Output video height",                 OFFSET(oh), AV_OPT_TYPE_STRING, { .str = "w*ch/cw" }, 0, 0, FLAGS },
+    { "cw", "Set the width crop area expression",  OFFSET(cw), AV_OPT_TYPE_STRING, { .str = "iw" }, 0, 0, FLAGS },
+    { "ch", "Set the height crop area expression", OFFSET(ch), AV_OPT_TYPE_STRING, { .str = "ih" }, 0, 0, FLAGS },
+    { "cx", "Set the x crop area expression",      OFFSET(cx), AV_OPT_TYPE_STRING, { .str = "(in_w-out_w)/2" }, 0, 0, FLAGS },
+    { "cy", "Set the y crop area expression",      OFFSET(cy), AV_OPT_TYPE_STRING, { .str = "(in_h-out_h)/2" }, 0, 0, FLAGS },
+    { "format", "Output video pixel format", OFFSET(format), AV_OPT_TYPE_PIXEL_FMT, { .i64 = AV_PIX_FMT_NONE }, INT_MIN, INT_MAX, .flags = FLAGS },
+    { "transpose", "Set transpose direction", OFFSET(transpose), AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 6, FLAGS, "transpose" },
+        { "cclock_hflip", "Rotate counter-clockwise with horizontal flip", 0, AV_OPT_TYPE_CONST, { .i64 = TRANSPOSE_CCLOCK_FLIP }, 0, 0, FLAGS, "transpose" },
+        { "clock",        "Rotate clockwise",                              0, AV_OPT_TYPE_CONST, { .i64 = TRANSPOSE_CLOCK       }, 0, 0, FLAGS, "transpose" },
+        { "cclock",       "Rotate counter-clockwise",                      0, AV_OPT_TYPE_CONST, { .i64 = TRANSPOSE_CCLOCK      }, 0, 0, FLAGS, "transpose" },
+        { "clock_hflip",  "Rotate clockwise with horizontal flip",         0, AV_OPT_TYPE_CONST, { .i64 = TRANSPOSE_CLOCK_FLIP  }, 0, 0, FLAGS, "transpose" },
+        { "reversal",     "Rotate by half-turn",                           0, AV_OPT_TYPE_CONST, { .i64 = TRANSPOSE_REVERSAL    }, 0, 0, FLAGS, "transpose" },
+        { "hflip",        "Flip horizontally",                             0, AV_OPT_TYPE_CONST, { .i64 = TRANSPOSE_HFLIP       }, 0, 0, FLAGS, "transpose" },
+        { "vflip",        "Flip vertically",                               0, AV_OPT_TYPE_CONST, { .i64 = TRANSPOSE_VFLIP       }, 0, 0, FLAGS, "transpose" },
+    RKRGA_VPP_COMMON_OPTS
+    { NULL },
+};
+
+AVFILTER_DEFINE_CLASS(rgavpp);
+
+const AVFilter ff_vf_vpp_rkrga = {
+    .name           = "vpp_rkrga",
+    .description    = NULL_IF_CONFIG_SMALL("Rockchip RGA (2D Raster Graphic Acceleration) video post-process (scale/crop/transpose)"),
+    .priv_size      = sizeof(RGAVppContext),
+    .priv_class     = &rgavpp_class,
+    .init           = rgavpp_init,
+    .uninit         = rgavpp_uninit,
+    FILTER_INPUTS(rgavpp_inputs),
+    FILTER_OUTPUTS(rgavpp_outputs),
+    FILTER_SINGLE_PIXFMT(AV_PIX_FMT_DRM_PRIME),
+    .activate       = rgavpp_activate,
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
+
+#endif

From 45400899c066b58e9dfe68e330b15ead7e128413 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 28 Dec 2023 01:52:02 +0800
Subject: [PATCH 007/103] lavc/rkmppdec: refactor RKMPP decoders and extend
 codecs

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure              |    9 +-
 libavcodec/Makefile    |    5 +
 libavcodec/allcodecs.c |    5 +
 libavcodec/rkmppdec.c  | 1169 +++++++++++++++++++++++++---------------
 libavcodec/rkmppdec.h  |  153 ++++++
 5 files changed, 903 insertions(+), 438 deletions(-)
 create mode 100644 libavcodec/rkmppdec.h

diff --git a/configure b/configure
index 541c4ee1143..a0c9e09bee5 100755
--- a/configure
+++ b/configure
@@ -1954,6 +1954,7 @@ HWACCEL_LIBRARY_LIST="
     mmal
     omx
     opencl
+    rkmpp
 "
 
 DOCUMENT_LIST="
@@ -3215,8 +3216,10 @@ av1_mediacodec_decoder_deps="mediacodec"
 av1_mediacodec_encoder_deps="mediacodec"
 av1_nvenc_encoder_deps="nvenc NV_ENC_PIC_PARAMS_AV1"
 av1_nvenc_encoder_select="atsc_a53"
+av1_rkmpp_decoder_deps="rkmpp"
 h263_v4l2m2m_decoder_deps="v4l2_m2m h263_v4l2_m2m"
 h263_v4l2m2m_encoder_deps="v4l2_m2m h263_v4l2_m2m"
+h263_rkmpp_decoder_deps="rkmpp"
 h264_amf_encoder_deps="amf"
 h264_crystalhd_decoder_select="crystalhd h264_mp4toannexb_bsf h264_parser"
 h264_cuvid_decoder_deps="cuvid"
@@ -3266,6 +3269,7 @@ mjpeg_vaapi_encoder_select="cbs_jpeg jpegtables vaapi_encode"
 mp3_mf_encoder_deps="mediafoundation"
 mpeg1_cuvid_decoder_deps="cuvid"
 mpeg1_v4l2m2m_decoder_deps="v4l2_m2m mpeg1_v4l2_m2m"
+mpeg1_rkmpp_decoder_deps="rkmpp"
 mpeg2_crystalhd_decoder_select="crystalhd"
 mpeg2_cuvid_decoder_deps="cuvid"
 mpeg2_mmal_decoder_deps="mmal"
@@ -3274,6 +3278,7 @@ mpeg2_qsv_decoder_select="qsvdec"
 mpeg2_qsv_encoder_select="qsvenc"
 mpeg2_vaapi_encoder_select="cbs_mpeg2 vaapi_encode"
 mpeg2_v4l2m2m_decoder_deps="v4l2_m2m mpeg2_v4l2_m2m"
+mpeg2_rkmpp_decoder_deps="rkmpp"
 mpeg4_crystalhd_decoder_select="crystalhd"
 mpeg4_cuvid_decoder_deps="cuvid"
 mpeg4_mediacodec_decoder_deps="mediacodec"
@@ -3282,6 +3287,8 @@ mpeg4_mmal_decoder_deps="mmal"
 mpeg4_omx_encoder_deps="omx"
 mpeg4_v4l2m2m_decoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 mpeg4_v4l2m2m_encoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
+mpeg4_rkmpp_decoder_deps="rkmpp"
+mpeg4_rkmpp_decoder_select="mpeg4_unpack_bframes_bsf"
 msmpeg4_crystalhd_decoder_select="crystalhd"
 vc1_crystalhd_decoder_select="crystalhd"
 vc1_cuvid_decoder_deps="cuvid"
@@ -3881,7 +3888,7 @@ cws2fws_extralibs="zlib_extralibs"
 
 # libraries, in any order
 avcodec_deps="avutil"
-avcodec_suggest="libm stdatomic"
+avcodec_suggest="libm stdatomic rkrga"
 avdevice_deps="avformat avcodec avutil"
 avdevice_suggest="libm stdatomic"
 avfilter_deps="avutil"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index ec57e53e300..8925dd12bca 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -256,6 +256,7 @@ OBJS-$(CONFIG_AV1_MEDIACODEC_ENCODER)  += mediacodecenc.o
 OBJS-$(CONFIG_AV1_NVENC_ENCODER)       += nvenc_av1.o nvenc.o
 OBJS-$(CONFIG_AV1_QSV_ENCODER)         += qsvenc_av1.o
 OBJS-$(CONFIG_AV1_VAAPI_ENCODER)       += vaapi_encode_av1.o av1_levels.o
+OBJS-$(CONFIG_AV1_RKMPP_DECODER)       += rkmppdec.o
 OBJS-$(CONFIG_AVRN_DECODER)            += avrndec.o
 OBJS-$(CONFIG_AVRP_DECODER)            += r210dec.o
 OBJS-$(CONFIG_AVRP_ENCODER)            += r210enc.o
@@ -398,6 +399,7 @@ OBJS-$(CONFIG_H263_ENCODER)            += mpeg4video.o  \
                                           h263.o ituh263enc.o h263data.o
 OBJS-$(CONFIG_H263_V4L2M2M_DECODER)    += v4l2_m2m_dec.o
 OBJS-$(CONFIG_H263_V4L2M2M_ENCODER)    += v4l2_m2m_enc.o
+OBJS-$(CONFIG_H263_RKMPP_DECODER)      += rkmppdec.o
 OBJS-$(CONFIG_H264_DECODER)            += h264dec.o h264_cabac.o h264_cavlc.o \
                                           h264_direct.o h264_loopfilter.o  \
                                           h264_mb.o h264_picture.o \
@@ -530,6 +532,7 @@ OBJS-$(CONFIG_MPEG1VIDEO_DECODER)      += mpeg12dec.o mpeg12.o mpeg12data.o
 OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o
 OBJS-$(CONFIG_MPEG1_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG1_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
+OBJS-$(CONFIG_MPEG1_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPEG2_MMAL_DECODER)      += mmaldec.o
 OBJS-$(CONFIG_MPEG2_QSV_DECODER)       += qsvdec.o
 OBJS-$(CONFIG_MPEG2_QSV_ENCODER)       += qsvenc_mpeg2.o
@@ -539,6 +542,7 @@ OBJS-$(CONFIG_MPEG2_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG2_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG2_VAAPI_ENCODER)     += vaapi_encode_mpeg2.o
 OBJS-$(CONFIG_MPEG2_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
+OBJS-$(CONFIG_MPEG2_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPEG4_DECODER)           += mpeg4videodsp.o xvididct.o
 OBJS-$(CONFIG_MPEG4_ENCODER)           += mpeg4videoenc.o
 OBJS-$(CONFIG_MPEG4_CUVID_DECODER)     += cuviddec.o
@@ -547,6 +551,7 @@ OBJS-$(CONFIG_MPEG4_MEDIACODEC_ENCODER) += mediacodecenc.o
 OBJS-$(CONFIG_MPEG4_OMX_ENCODER)       += omx.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_ENCODER)   += v4l2_m2m_enc.o
+OBJS-$(CONFIG_MPEG4_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPL2_DECODER)            += mpl2dec.o ass.o
 OBJS-$(CONFIG_MSA1_DECODER)            += mss3.o
 OBJS-$(CONFIG_MSCC_DECODER)            += mscc.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 5136a566f1b..16d707cb17a 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -150,6 +150,7 @@ extern const FFCodec ff_h263i_decoder;
 extern const FFCodec ff_h263p_encoder;
 extern const FFCodec ff_h263p_decoder;
 extern const FFCodec ff_h263_v4l2m2m_decoder;
+extern const FFCodec ff_h263_rkmpp_decoder;
 extern const FFCodec ff_h264_decoder;
 extern const FFCodec ff_h264_crystalhd_decoder;
 extern const FFCodec ff_h264_v4l2m2m_decoder;
@@ -212,13 +213,16 @@ extern const FFCodec ff_mpeg4_decoder;
 extern const FFCodec ff_mpeg4_crystalhd_decoder;
 extern const FFCodec ff_mpeg4_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg4_mmal_decoder;
+extern const FFCodec ff_mpeg4_rkmpp_decoder;
 extern const FFCodec ff_mpegvideo_decoder;
 extern const FFCodec ff_mpeg1_v4l2m2m_decoder;
+extern const FFCodec ff_mpeg1_rkmpp_decoder;
 extern const FFCodec ff_mpeg2_mmal_decoder;
 extern const FFCodec ff_mpeg2_crystalhd_decoder;
 extern const FFCodec ff_mpeg2_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg2_qsv_decoder;
 extern const FFCodec ff_mpeg2_mediacodec_decoder;
+extern const FFCodec ff_mpeg2_rkmpp_decoder;
 extern const FFCodec ff_msa1_decoder;
 extern const FFCodec ff_mscc_decoder;
 extern const FFCodec ff_msmpeg4v1_decoder;
@@ -846,6 +850,7 @@ extern const FFCodec ff_av1_qsv_decoder;
 extern const FFCodec ff_av1_qsv_encoder;
 extern const FFCodec ff_av1_amf_encoder;
 extern const FFCodec ff_av1_vaapi_encoder;
+extern const FFCodec ff_av1_rkmpp_decoder;
 extern const FFCodec ff_libopenh264_encoder;
 extern const FFCodec ff_libopenh264_decoder;
 extern const FFCodec ff_h264_amf_encoder;
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 5768568b002..e8478b2150c 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -1,6 +1,7 @@
 /*
- * RockChip MPP Video Decoder
  * Copyright (c) 2017 Lionel CHAZALLON
+ * Copyright (c) 2023 Huseyin BIYIK
+ * Copyright (c) 2023 NyanMisaka
  *
  * This file is part of FFmpeg.
  *
@@ -19,571 +20,865 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include <drm_fourcc.h>
-#include <pthread.h>
-#include <rockchip/mpp_buffer.h>
-#include <rockchip/rk_mpi.h>
-#include <time.h>
-#include <unistd.h>
-
-#include "avcodec.h"
-#include "codec_internal.h"
-#include "decode.h"
-#include "hwconfig.h"
-#include "libavutil/buffer.h"
-#include "libavutil/common.h"
-#include "libavutil/frame.h"
-#include "libavutil/hwcontext.h"
-#include "libavutil/hwcontext_drm.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/log.h"
-
-#define RECEIVE_FRAME_TIMEOUT   100
-#define FRAMEGROUP_MAX_FRAMES   16
-#define INPUT_MAX_PACKETS       4
-
-typedef struct {
-    MppCtx ctx;
-    MppApi *mpi;
-    MppBufferGroup frame_group;
-
-    char first_packet;
-    char eos_reached;
-
-    AVBufferRef *frames_ref;
-    AVBufferRef *device_ref;
-} RKMPPDecoder;
-
-typedef struct {
-    AVClass *av_class;
-    AVBufferRef *decoder_ref;
-} RKMPPDecodeContext;
-
-typedef struct {
-    MppFrame frame;
-    AVBufferRef *decoder_ref;
-} RKMPPFrameContext;
-
-static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
+/**
+ * @file
+ * Rockchip MPP (Media Process Platform) video decoder
+ */
+
+#include "config.h"
+#include "config_components.h"
+
+#include "rkmppdec.h"
+
+#if CONFIG_RKRGA
+#include <rga/im2d.h>
+#endif
+
+static MppCodingType rkmpp_get_coding_type(AVCodecContext *avctx)
 {
     switch (avctx->codec_id) {
+    case AV_CODEC_ID_H263:          return MPP_VIDEO_CodingH263;
     case AV_CODEC_ID_H264:          return MPP_VIDEO_CodingAVC;
     case AV_CODEC_ID_HEVC:          return MPP_VIDEO_CodingHEVC;
+    case AV_CODEC_ID_AV1:           return MPP_VIDEO_CodingAV1;
     case AV_CODEC_ID_VP8:           return MPP_VIDEO_CodingVP8;
     case AV_CODEC_ID_VP9:           return MPP_VIDEO_CodingVP9;
+    case AV_CODEC_ID_MPEG1VIDEO:    /* fallthrough */
+    case AV_CODEC_ID_MPEG2VIDEO:    return MPP_VIDEO_CodingMPEG2;
+    case AV_CODEC_ID_MPEG4:         return MPP_VIDEO_CodingMPEG4;
     default:                        return MPP_VIDEO_CodingUnused;
     }
 }
 
-static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
+static uint32_t rkmpp_get_drm_format(MppFrameFormat mpp_fmt)
 {
-    switch (mppformat) {
+    switch (mpp_fmt & MPP_FRAME_FMT_MASK) {
     case MPP_FMT_YUV420SP:          return DRM_FORMAT_NV12;
-#ifdef DRM_FORMAT_NV12_10
-    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV12_10;
-#endif
-    default:                        return 0;
+    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV15;
+    case MPP_FMT_YUV422SP:          return DRM_FORMAT_NV16;
+    case MPP_FMT_YUV422SP_10BIT:    return DRM_FORMAT_NV20;
+    default:                        return DRM_FORMAT_INVALID;
     }
 }
 
-static int rkmpp_write_data(AVCodecContext *avctx, uint8_t *buffer, int size, int64_t pts)
+static uint32_t rkmpp_get_drm_afbc_format(MppFrameFormat mpp_fmt)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret;
-    MppPacket packet;
-
-    // create the MPP packet
-    ret = mpp_packet_init(&packet, buffer, size);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP packet (code = %d)\n", ret);
-        return AVERROR_UNKNOWN;
-    }
-
-    mpp_packet_set_pts(packet, pts);
-
-    if (!buffer)
-        mpp_packet_set_eos(packet);
-
-    ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
-    if (ret != MPP_OK) {
-        if (ret == MPP_ERR_BUFFER_FULL) {
-            av_log(avctx, AV_LOG_DEBUG, "Buffer full writing %d bytes to decoder\n", size);
-            ret = AVERROR(EAGAIN);
-        } else
-            ret = AVERROR_UNKNOWN;
+    switch (mpp_fmt & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP:          return DRM_FORMAT_YUV420_8BIT;
+    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_YUV420_10BIT;
+    case MPP_FMT_YUV422SP:          return DRM_FORMAT_YUYV;
+    case MPP_FMT_YUV422SP_10BIT:    return DRM_FORMAT_Y210;
+    default:                        return DRM_FORMAT_INVALID;
     }
-    else
-        av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", size);
-
-    mpp_packet_deinit(&packet);
-
-    return ret;
 }
 
-static int rkmpp_close_decoder(AVCodecContext *avctx)
+static uint32_t rkmpp_get_av_format(MppFrameFormat mpp_fmt)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    av_buffer_unref(&rk_context->decoder_ref);
-    return 0;
+    switch (mpp_fmt & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP:          return AV_PIX_FMT_NV12;
+    case MPP_FMT_YUV420SP_10BIT:    return AV_PIX_FMT_NV15;
+    case MPP_FMT_YUV422SP:          return AV_PIX_FMT_NV16;
+    case MPP_FMT_YUV422SP_10BIT:    return AV_PIX_FMT_NV20;
+    default:                        return AV_PIX_FMT_NONE;
+    }
 }
 
-static void rkmpp_release_decoder(void *opaque, uint8_t *data)
+static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
 {
-    RKMPPDecoder *decoder = (RKMPPDecoder *)data;
+    RKMPPDecContext *r = avctx->priv_data;
 
-    if (decoder->mpi) {
-        decoder->mpi->reset(decoder->ctx);
-        mpp_destroy(decoder->ctx);
-        decoder->ctx = NULL;
-    }
+    r->eof = 0;
+    r->info_change = 0;
+    r->errinfo_cnt = 0;
 
-    if (decoder->frame_group) {
-        mpp_buffer_group_put(decoder->frame_group);
-        decoder->frame_group = NULL;
+    if (r->mapi) {
+        r->mapi->reset(r->mctx);
+        mpp_destroy(r->mctx);
+        r->mctx = NULL;
+    }
+    if (r->buf_group &&
+        r->buf_mode == RKMPP_DEC_PURE_EXTERNAL) {
+        mpp_buffer_group_put(r->buf_group);
+        r->buf_group = NULL;
     }
 
-    av_buffer_unref(&decoder->frames_ref);
-    av_buffer_unref(&decoder->device_ref);
+    if (r->hwframe)
+        av_buffer_unref(&r->hwframe);
+    if (r->hwdevice)
+        av_buffer_unref(&r->hwdevice);
 
-    av_free(decoder);
+    return 0;
 }
 
-static int rkmpp_init_decoder(AVCodecContext *avctx)
+static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = NULL;
-    MppCodingType codectype = MPP_VIDEO_CodingUnused;
-    int ret;
-    RK_S64 paramS64;
-    RK_S32 paramS32;
+    RKMPPDecContext *r = avctx->priv_data;
+    MppCodingType coding_type = MPP_VIDEO_CodingUnused;
+    int ret, is_fmt_supported = 0;
+    enum AVPixelFormat pix_fmts[3] = { AV_PIX_FMT_DRM_PRIME,
+                                       AV_PIX_FMT_NV12,
+                                       AV_PIX_FMT_NONE };
+
+    switch (avctx->pix_fmt) {
+    case AV_PIX_FMT_YUV420P:
+        is_fmt_supported = 1;
+        break;
+    case AV_PIX_FMT_YUV420P10:
+        is_fmt_supported =
+            avctx->codec_id == AV_CODEC_ID_H264 ||
+            avctx->codec_id == AV_CODEC_ID_HEVC ||
+            avctx->codec_id == AV_CODEC_ID_VP9 ||
+            avctx->codec_id == AV_CODEC_ID_AV1;
+        break;
+    case AV_PIX_FMT_YUV422P:
+    case AV_PIX_FMT_YUV422P10:
+        is_fmt_supported =
+            avctx->codec_id == AV_CODEC_ID_H264;
+        break;
+    default:
+        is_fmt_supported = 0;
+        break;
+    }
 
-    avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
+    if (!is_fmt_supported) {
+        av_log(avctx, AV_LOG_ERROR, "MPP doesn't support codec '%s' with pix_fmt '%s'\n",
+               avcodec_get_name(avctx->codec_id), av_get_pix_fmt_name(avctx->pix_fmt));
+        return AVERROR(ENOSYS);
+    }
 
-    // create a decoder and a ref to it
-    decoder = av_mallocz(sizeof(RKMPPDecoder));
-    if (!decoder) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
+    if ((ret = ff_get_format(avctx, pix_fmts)) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "ff_get_format failed: %d\n", ret);
+        return ret;
     }
+    avctx->pix_fmt = ret;
 
-    rk_context->decoder_ref = av_buffer_create((uint8_t *)decoder, sizeof(*decoder), rkmpp_release_decoder,
-                                               NULL, AV_BUFFER_FLAG_READONLY);
-    if (!rk_context->decoder_ref) {
-        av_free(decoder);
-        ret = AVERROR(ENOMEM);
-        goto fail;
+    if ((coding_type = rkmpp_get_coding_type(avctx)) == MPP_VIDEO_CodingUnused) {
+        av_log(avctx, AV_LOG_ERROR, "Unknown codec id: %d\n", avctx->codec_id);
+        return AVERROR(ENOSYS);
     }
 
-    av_log(avctx, AV_LOG_DEBUG, "Initializing RKMPP decoder.\n");
+    if ((ret = mpp_check_support_format(MPP_CTX_DEC, coding_type)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "MPP doesn't support codec '%s' (%d)\n",
+               avcodec_get_name(avctx->codec_id), avctx->codec_id);
+        return AVERROR(ENOSYS);
+    }
 
-    codectype = rkmpp_get_codingtype(avctx);
-    if (codectype == MPP_VIDEO_CodingUnused) {
-        av_log(avctx, AV_LOG_ERROR, "Unknown codec type (%d).\n", avctx->codec_id);
-        ret = AVERROR_UNKNOWN;
+    if ((ret = mpp_create(&r->mctx, &r->mapi)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create MPP context and api: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
         goto fail;
     }
 
-    ret = mpp_check_support_format(MPP_CTX_DEC, codectype);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Codec type (%d) unsupported by MPP\n", avctx->codec_id);
-        ret = AVERROR_UNKNOWN;
+    if ((ret = mpp_init(r->mctx, MPP_CTX_DEC, coding_type)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP context: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
         goto fail;
     }
 
-    // Create the MPP context
-    ret = mpp_create(&decoder->ctx, &decoder->mpi);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to create MPP context (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
+    if ((ret = r->mapi->control(r->mctx, MPP_DEC_SET_ENABLE_DEINTERLACE, &r->deint)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set enable deinterlace: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
         goto fail;
     }
 
-    // initialize mpp
-    ret = mpp_init(decoder->ctx, MPP_CTX_DEC, codectype);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to initialize MPP context (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
+    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME)
+        r->afbc = 0;
+
+    if (r->afbc == RKMPP_DEC_AFBC_ON_RGA) {
+#if CONFIG_RKRGA
+        const char *rga_ver = querystring(RGA_VERSION);
+        int has_rga3 = !!strstr(rga_ver, "RGA_3");
+        int is_rga3_compat = avctx->width >= 68 &&
+                             avctx->width <= 8176 &&
+                             avctx->height >= 2 &&
+                             avctx->height <= 8176;
+
+        if (!has_rga3 || !is_rga3_compat) {
+#endif
+            av_log(avctx, AV_LOG_VERBOSE, "AFBC is requested without capable RGA, ignoring\n");
+            r->afbc = RKMPP_DEC_AFBC_OFF;
+#if CONFIG_RKRGA
+        }
+#endif
     }
 
-    // make decode calls blocking with a timeout
-    paramS32 = MPP_POLL_BLOCK;
-    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK, &paramS32);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set blocking mode on MPI (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
+    if (r->afbc) {
+        MppFrameFormat afbc_fmt = MPP_FRAME_FBC_AFBC_V2;
+
+        if (avctx->codec_id == AV_CODEC_ID_H264 ||
+            avctx->codec_id == AV_CODEC_ID_HEVC ||
+            avctx->codec_id == AV_CODEC_ID_VP9 ||
+            avctx->codec_id == AV_CODEC_ID_AV1) {
+            if ((ret = r->mapi->control(r->mctx, MPP_DEC_SET_OUTPUT_FORMAT, &afbc_fmt)) != MPP_OK) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to set AFBC mode: %d\n", ret);
+                ret = AVERROR_EXTERNAL;
+                goto fail;
+            }
+        } else {
+            av_log(avctx, AV_LOG_VERBOSE, "AFBC is not supported in codec '%s', ignoring\n",
+                   avcodec_get_name(avctx->codec_id));
+            r->afbc = 0;
+        }
     }
 
-    paramS64 = RECEIVE_FRAME_TIMEOUT;
-    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK_TIMEOUT, &paramS64);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set block timeout on MPI (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
+    if (avctx->hw_device_ctx) {
+        r->hwdevice = av_buffer_ref(avctx->hw_device_ctx);
+        if (!r->hwdevice) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        av_log(avctx, AV_LOG_VERBOSE, "Picked up an existing RKMPP hardware device\n");
+    } else {
+        if ((ret = av_hwdevice_ctx_create(&r->hwdevice, AV_HWDEVICE_TYPE_RKMPP, NULL, NULL, 0)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create a RKMPP hardware device: %d\n", ret);
+            goto fail;
+        }
+        av_log(avctx, AV_LOG_VERBOSE, "Created a RKMPP hardware device\n");
     }
 
-    ret = mpp_buffer_group_get_internal(&decoder->frame_group, MPP_BUFFER_TYPE_ION);
-    if (ret) {
-       av_log(avctx, AV_LOG_ERROR, "Failed to retrieve buffer group (code = %d)\n", ret);
-       ret = AVERROR_UNKNOWN;
-       goto fail;
+    return 0;
+
+fail:
+    rkmpp_decode_close(avctx);
+    return ret;
+}
+
+static int rkmpp_set_buffer_group(AVCodecContext *avctx,
+                                  enum AVPixelFormat pix_fmt,
+                                  int width, int height)
+{
+    RKMPPDecContext *r = avctx->priv_data;
+    AVHWFramesContext *hwfc = NULL;
+    int i, ret, decoder_pool_size;
+
+    if (!r->hwdevice)
+        return AVERROR(ENOMEM);
+
+    av_buffer_unref(&r->hwframe);
+
+    r->hwframe = av_hwframe_ctx_alloc(r->hwdevice);
+    if (!r->hwframe)
+        return AVERROR(ENOMEM);
+
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H264:
+    case AV_CODEC_ID_HEVC:
+        decoder_pool_size = 20;
+        break;
+    default:
+        decoder_pool_size = 10;
+        break;
     }
 
-    ret = decoder->mpi->control(decoder->ctx, MPP_DEC_SET_EXT_BUF_GROUP, decoder->frame_group);
-    if (ret) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to assign buffer group (code = %d)\n", ret);
-        ret = AVERROR_UNKNOWN;
+    hwfc = (AVHWFramesContext *)r->hwframe->data;
+    hwfc->format    = AV_PIX_FMT_DRM_PRIME;
+    hwfc->sw_format = pix_fmt;
+    hwfc->width     = FFALIGN(width,  16);
+    hwfc->height    = FFALIGN(height, 16);
+
+    if (r->buf_mode == RKMPP_DEC_HALF_INTERNAL) {
+        AVRKMPPFramesContext *rkmpp_fc = NULL;
+
+        if ((ret = av_hwframe_ctx_init(r->hwframe)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to init RKMPP frame pool\n");
+            goto fail;
+        }
+
+        rkmpp_fc = hwfc->hwctx;
+        r->buf_group = rkmpp_fc->buf_group;
+        goto attach;
+    } else if (r->buf_mode != RKMPP_DEC_PURE_EXTERNAL) {
+        ret = AVERROR(EINVAL);
         goto fail;
     }
 
-    ret = mpp_buffer_group_limit_config(decoder->frame_group, 0, FRAMEGROUP_MAX_FRAMES);
-    if (ret) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set buffer group limit (code = %d)\n", ret);
-        ret = AVERROR_UNKNOWN;
+    hwfc->initial_pool_size = decoder_pool_size + 10;
+    if (avctx->extra_hw_frames > 0)
+        hwfc->initial_pool_size += avctx->extra_hw_frames;
+
+    if ((ret = av_hwframe_ctx_init(r->hwframe)) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init RKMPP frame pool\n");
         goto fail;
     }
 
-    decoder->first_packet = 1;
+    if (r->buf_group) {
+        if ((ret = mpp_buffer_group_clear(r->buf_group)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to clear external buffer group: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto fail;
+        }
+    } else {
+        if ((ret = mpp_buffer_group_get_external(&r->buf_group, MPP_BUFFER_TYPE_DRM)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get external buffer group: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto fail;
+        }
+    }
 
-    av_log(avctx, AV_LOG_DEBUG, "RKMPP decoder initialized successfully.\n");
+    for (i = 0; i < hwfc->initial_pool_size; i++) {
+        AVRKMPPFramesContext *rkmpp_fc = hwfc->hwctx;
+        MppBufferInfo buf_info = {
+            .index = i,
+            .type  = MPP_BUFFER_TYPE_DRM,
+            .fd    = rkmpp_fc->frames[i].objects[0].fd,
+            .ptr   = rkmpp_fc->frames[i].objects[0].ptr,
+            .size  = rkmpp_fc->frames[i].objects[0].size,
+        };
+
+        if ((ret = mpp_buffer_commit(r->buf_group, &buf_info)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to commit external buffer group: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto fail;
+        }
+    }
 
-    decoder->device_ref = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_DRM);
-    if (!decoder->device_ref) {
-        ret = AVERROR(ENOMEM);
+attach:
+    if ((ret = r->mapi->control(r->mctx, MPP_DEC_SET_EXT_BUF_GROUP, r->buf_group)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to attach external buffer group: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
         goto fail;
     }
-    ret = av_hwdevice_ctx_init(decoder->device_ref);
-    if (ret < 0)
-        goto fail;
+
+    if (r->buf_mode == RKMPP_DEC_HALF_INTERNAL) {
+        int group_limit = decoder_pool_size + ((width * height > (3840 * 2160 * 3)) ? 2 : 10);
+        if (avctx->extra_hw_frames > 0)
+            group_limit += avctx->extra_hw_frames;
+        if ((ret = mpp_buffer_group_limit_config(r->buf_group, 0, group_limit)) != MPP_OK)
+            av_log(avctx, AV_LOG_WARNING, "Failed to set buffer group limit: %d\n", ret);
+    }
 
     return 0;
 
 fail:
-    av_log(avctx, AV_LOG_ERROR, "Failed to initialize RKMPP decoder.\n");
-    rkmpp_close_decoder(avctx);
+    if (r->buf_group &&
+        r->buf_mode == RKMPP_DEC_HALF_INTERNAL) {
+        mpp_buffer_group_put(r->buf_group);
+        r->buf_group = NULL;
+    }
+    av_buffer_unref(&r->hwframe);
     return ret;
 }
 
-static int rkmpp_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
+static int rkmpp_export_mastering_display(AVCodecContext *avctx, AVFrame *frame,
+                                          MppFrameMasteringDisplayMetadata mpp_mastering)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret;
+    AVMasteringDisplayMetadata *mastering = NULL;
+    AVFrameSideData *sd = NULL;
+    int mapping[3] = { 0, 1, 2 };
+    int chroma_den = 0;
+    int max_luma_den = 0;
+    int min_luma_den = 0;
+    int i;
 
-    // handle EOF
-    if (!avpkt->size) {
-        av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
-        decoder->eos_reached = 1;
-        ret = rkmpp_write_data(avctx, NULL, 0, 0);
-        if (ret)
-            av_log(avctx, AV_LOG_ERROR, "Failed to send EOS to decoder (code = %d)\n", ret);
-        return ret;
+    switch (avctx->codec_id) {
+        case AV_CODEC_ID_HEVC:
+            // HEVC uses a g,b,r ordering, which we convert to a more natural r,g,b
+            mapping[0] = 2;
+            mapping[1] = 0;
+            mapping[2] = 1;
+            chroma_den = 50000;
+            max_luma_den = 10000;
+            min_luma_den = 10000;
+            break;
+        case AV_CODEC_ID_AV1:
+            chroma_den = 1 << 16;
+            max_luma_den = 1 << 8;
+            min_luma_den = 1 << 14;
+            break;
+        default:
+            return 0;
     }
 
-    // on first packet, send extradata
-    if (decoder->first_packet) {
-        if (avctx->extradata_size) {
-            ret = rkmpp_write_data(avctx, avctx->extradata,
-                                            avctx->extradata_size,
-                                            avpkt->pts);
-            if (ret) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to write extradata to decoder (code = %d)\n", ret);
-                return ret;
-            }
-        }
-        decoder->first_packet = 0;
+    sd = av_frame_get_side_data(frame, AV_FRAME_DATA_MASTERING_DISPLAY_METADATA);
+    if (sd)
+        mastering = (AVMasteringDisplayMetadata *)sd->data;
+    else
+        mastering = av_mastering_display_metadata_create_side_data(frame);
+    if (!mastering)
+        return AVERROR(ENOMEM);
+
+    for (i = 0; i < 3; i++) {
+        const int j = mapping[i];
+        mastering->display_primaries[i][0] = av_make_q(mpp_mastering.display_primaries[j][0], chroma_den);
+        mastering->display_primaries[i][1] = av_make_q(mpp_mastering.display_primaries[j][1], chroma_den);
     }
+    mastering->white_point[0] = av_make_q(mpp_mastering.white_point[0], chroma_den);
+    mastering->white_point[1] = av_make_q(mpp_mastering.white_point[1], chroma_den);
 
-    // now send packet
-    ret = rkmpp_write_data(avctx, avpkt->data, avpkt->size, avpkt->pts);
-    if (ret && ret!=AVERROR(EAGAIN))
-        av_log(avctx, AV_LOG_ERROR, "Failed to write data to decoder (code = %d)\n", ret);
+    mastering->max_luminance = av_make_q(mpp_mastering.max_luminance, max_luma_den);
+    mastering->min_luminance = av_make_q(mpp_mastering.min_luminance, min_luma_den);
 
-    return ret;
+    mastering->has_luminance = 1;
+    mastering->has_primaries = 1;
+
+    return 0;
 }
 
-static void rkmpp_release_frame(void *opaque, uint8_t *data)
+static int rkmpp_export_content_light(AVFrame *frame,
+                                      MppFrameContentLightMetadata mpp_light)
 {
-    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
-    AVBufferRef *framecontextref = (AVBufferRef *)opaque;
-    RKMPPFrameContext *framecontext = (RKMPPFrameContext *)framecontextref->data;
+    AVContentLightMetadata *light = NULL;
 
-    mpp_frame_deinit(&framecontext->frame);
-    av_buffer_unref(&framecontext->decoder_ref);
-    av_buffer_unref(&framecontextref);
+    AVFrameSideData *sd = av_frame_get_side_data(frame, AV_FRAME_DATA_CONTENT_LIGHT_LEVEL);
+    if (sd)
+        light = (AVContentLightMetadata *)sd->data;
+    else
+        light = av_content_light_metadata_create_side_data(frame);
+    if (!light)
+        return AVERROR(ENOMEM);
+
+    light->MaxCLL  = mpp_light.MaxCLL;
+    light->MaxFALL = mpp_light.MaxFALL;
 
-    av_free(desc);
+    return 0;
 }
 
-static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
+static void rkmpp_free_mpp_frame(void *opaque, uint8_t *data)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    RKMPPFrameContext *framecontext = NULL;
-    AVBufferRef *framecontextref = NULL;
-    int ret;
-    MppFrame mppframe = NULL;
-    MppBuffer buffer = NULL;
-    AVDRMFrameDescriptor *desc = NULL;
-    AVDRMLayerDescriptor *layer = NULL;
-    int mode;
-    MppFrameFormat mppformat;
-    uint32_t drmformat;
-
-    ret = decoder->mpi->decode_get_frame(decoder->ctx, &mppframe);
-    if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to get a frame from MPP (code = %d)\n", ret);
-        goto fail;
-    }
-
-    if (mppframe) {
-        // Check whether we have a special frame or not
-        if (mpp_frame_get_info_change(mppframe)) {
-            AVHWFramesContext *hwframes;
+    MppFrame mpp_frame = (MppFrame)opaque;
+    mpp_frame_deinit(&mpp_frame);
+}
 
-            av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), format=%d\n",
-                                        (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),
-                                        (int)mpp_frame_get_fmt(mppframe));
+static void rkmpp_free_drm_desc(void *opaque, uint8_t *data)
+{
+    AVDRMFrameDescriptor *drm_desc = (AVDRMFrameDescriptor *)opaque;
+    av_free(drm_desc);
+}
 
-            avctx->width = mpp_frame_get_width(mppframe);
-            avctx->height = mpp_frame_get_height(mppframe);
+static int frame_create_buf(AVFrame *frame,
+                            uint8_t* data, int size,
+                            void (*free)(void *opaque, uint8_t *data),
+                            void *opaque, int flags)
+{
+    int i;
 
-            decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
+    for (i = 0; i < AV_NUM_DATA_POINTERS; i++) {
+        if (!frame->buf[i]) {
+            frame->buf[i] = av_buffer_create(data, size, free, opaque, flags);
+            return frame->buf[i] ? 0 : AVERROR(ENOMEM);
+        }
+    }
+    return AVERROR(EINVAL);
+}
 
-            av_buffer_unref(&decoder->frames_ref);
+static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mpp_frame)
+{
+    RKMPPDecContext *r = avctx->priv_data;
+    AVDRMFrameDescriptor *desc = NULL;
+    AVDRMLayerDescriptor *layer = NULL;
+    MppBuffer mpp_buf = NULL;
+    MppFrameFormat mpp_fmt = MPP_FMT_BUTT;
+    int mpp_frame_mode = 0;
+    int ret, is_afbc = 0;
+
+    if (!frame || !mpp_frame)
+        return AVERROR(ENOMEM);
+
+    mpp_buf = mpp_frame_get_buffer(mpp_frame);
+    if (!mpp_buf)
+        return AVERROR(EAGAIN);
+
+    desc = av_mallocz(sizeof(*desc));
+    if (!desc)
+        return AVERROR(ENOMEM);
+
+    desc->nb_objects = 1;
+    desc->objects[0].fd   = mpp_buffer_get_fd(mpp_buf);
+    desc->objects[0].ptr  = mpp_buffer_get_ptr(mpp_buf);
+    desc->objects[0].size = mpp_buffer_get_size(mpp_buf);
+
+    mpp_fmt = mpp_frame_get_fmt(mpp_frame);
+    is_afbc = mpp_fmt & MPP_FRAME_FBC_MASK;
+
+    if (is_afbc)
+        desc->objects[0].format_modifier =
+            DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
+
+    desc->nb_layers = 1;
+    layer = &desc->layers[0];
+    layer->format = is_afbc ? rkmpp_get_drm_afbc_format(mpp_fmt)
+                            : rkmpp_get_drm_format(mpp_fmt);
+
+    layer->nb_planes = is_afbc ? 1 : 2;
+    layer->planes[0].object_index = 0;
+    layer->planes[0].offset =
+        is_afbc ? mpp_frame_get_offset_y(mpp_frame) * mpp_frame_get_hor_stride(mpp_frame) : 0;
+    layer->planes[0].pitch = mpp_frame_get_hor_stride(mpp_frame);
+
+    layer->planes[1].object_index = 0;
+    layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mpp_frame);
+    layer->planes[1].pitch = layer->planes[0].pitch;
+
+    if ((ret = frame_create_buf(frame, mpp_frame, mpp_frame_get_buf_size(mpp_frame),
+                                rkmpp_free_mpp_frame, mpp_frame, AV_BUFFER_FLAG_READONLY)) < 0)
+        return ret;
 
-            decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);
-            if (!decoder->frames_ref) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    if ((ret = frame_create_buf(frame, (uint8_t *)desc, sizeof(*desc),
+                                rkmpp_free_drm_desc, desc, AV_BUFFER_FLAG_READONLY)) < 0)
+        return ret;
 
-            mppformat = mpp_frame_get_fmt(mppframe);
-            drmformat = rkmpp_get_frameformat(mppformat);
+    frame->data[0] = (uint8_t *)desc;
 
-            hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
-            hwframes->format    = AV_PIX_FMT_DRM_PRIME;
-            hwframes->sw_format = drmformat == DRM_FORMAT_NV12 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_NONE;
-            hwframes->width     = avctx->width;
-            hwframes->height    = avctx->height;
-            ret = av_hwframe_ctx_init(decoder->frames_ref);
-            if (ret < 0)
-                goto fail;
+    frame->hw_frames_ctx = av_buffer_ref(r->hwframe);
+    if (!frame->hw_frames_ctx)
+        return AVERROR(ENOMEM);
 
-            // here decoder is fully initialized, we need to feed it again with data
-            ret = AVERROR(EAGAIN);
-            goto fail;
-        } else if (mpp_frame_get_eos(mppframe)) {
-            av_log(avctx, AV_LOG_DEBUG, "Received a EOS frame.\n");
-            decoder->eos_reached = 1;
-            ret = AVERROR_EOF;
-            goto fail;
-        } else if (mpp_frame_get_discard(mppframe)) {
-            av_log(avctx, AV_LOG_DEBUG, "Received a discard frame.\n");
-            ret = AVERROR(EAGAIN);
-            goto fail;
-        } else if (mpp_frame_get_errinfo(mppframe)) {
-            av_log(avctx, AV_LOG_ERROR, "Received a errinfo frame.\n");
-            ret = AVERROR_UNKNOWN;
-            goto fail;
-        }
+    if ((ret = ff_decode_frame_props(avctx, frame)) < 0)
+        return ret;
 
-        // here we should have a valid frame
-        av_log(avctx, AV_LOG_DEBUG, "Received a frame.\n");
-
-        // setup general frame fields
-        frame->format           = AV_PIX_FMT_DRM_PRIME;
-        frame->width            = mpp_frame_get_width(mppframe);
-        frame->height           = mpp_frame_get_height(mppframe);
-        frame->pts              = mpp_frame_get_pts(mppframe);
-        frame->color_range      = mpp_frame_get_color_range(mppframe);
-        frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);
-        frame->color_trc        = mpp_frame_get_color_trc(mppframe);
-        frame->colorspace       = mpp_frame_get_colorspace(mppframe);
-
-        mode = mpp_frame_get_mode(mppframe);
-        if ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED)
-            frame->flags |= AV_FRAME_FLAG_INTERLACED;
-        if ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST)
-            frame->flags |= AV_FRAME_FLAG_TOP_FIELD_FIRST;
-
-        mppformat = mpp_frame_get_fmt(mppframe);
-        drmformat = rkmpp_get_frameformat(mppformat);
-
-        // now setup the frame buffer info
-        buffer = mpp_frame_get_buffer(mppframe);
-        if (buffer) {
-            desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
-            if (!desc) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    frame->width  = avctx->width;
+    frame->height = avctx->height;
+    frame->pts    = MPP_PTS_TO_PTS(mpp_frame_get_pts(mpp_frame), avctx->pkt_timebase);
+
+    mpp_frame_mode = mpp_frame_get_mode(mpp_frame);
+    if ((mpp_frame_mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED)
+        frame->flags |= AV_FRAME_FLAG_INTERLACED;
+    if ((mpp_frame_mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST)
+        frame->flags |= AV_FRAME_FLAG_TOP_FIELD_FIRST;
+
+    if (avctx->codec_id == AV_CODEC_ID_MPEG1VIDEO ||
+        avctx->codec_id == AV_CODEC_ID_MPEG2VIDEO) {
+        MppFrameRational sar = mpp_frame_get_sar(mpp_frame);
+        frame->sample_aspect_ratio = av_div_q((AVRational) { sar.num, sar.den },
+                                              (AVRational) { frame->width, frame->height });
+    }
 
-            desc->nb_objects = 1;
-            desc->objects[0].fd = mpp_buffer_get_fd(buffer);
-            desc->objects[0].size = mpp_buffer_get_size(buffer);
+    if (avctx->codec_id == AV_CODEC_ID_HEVC &&
+        (frame->color_trc == AVCOL_TRC_SMPTE2084 ||
+         frame->color_trc == AVCOL_TRC_ARIB_STD_B67)) {
+        ret = rkmpp_export_mastering_display(avctx, frame, mpp_frame_get_mastering_display(mpp_frame));
+        if (ret < 0)
+            return ret;
+        ret = rkmpp_export_content_light(frame, mpp_frame_get_content_light(mpp_frame));
+        if (ret < 0)
+            return ret;
+    }
 
-            desc->nb_layers = 1;
-            layer = &desc->layers[0];
-            layer->format = drmformat;
-            layer->nb_planes = 2;
+    return 0;
+}
 
-            layer->planes[0].object_index = 0;
-            layer->planes[0].offset = 0;
-            layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
+static void rkmpp_export_avctx_color_props(AVCodecContext *avctx, MppFrame mpp_frame)
+{
+    int val;
+
+    if (!avctx || !mpp_frame)
+        return;
+
+    if (avctx->color_primaries == AVCOL_PRI_RESERVED0)
+        avctx->color_primaries = AVCOL_PRI_UNSPECIFIED;
+    if ((val = mpp_frame_get_color_primaries(mpp_frame)) &&
+        val != MPP_FRAME_PRI_RESERVED0 &&
+        val != MPP_FRAME_PRI_UNSPECIFIED)
+        avctx->color_primaries = val;
+
+    if (avctx->color_trc == AVCOL_TRC_RESERVED0)
+        avctx->color_trc = AVCOL_TRC_UNSPECIFIED;
+    if ((val = mpp_frame_get_color_trc(mpp_frame)) &&
+        val != MPP_FRAME_TRC_RESERVED0 &&
+        val != MPP_FRAME_TRC_UNSPECIFIED)
+        avctx->color_trc = val;
+
+    if (avctx->colorspace == AVCOL_SPC_RESERVED)
+        avctx->colorspace = AVCOL_SPC_UNSPECIFIED;
+    if ((val = mpp_frame_get_colorspace(mpp_frame)) &&
+        val != MPP_FRAME_SPC_RESERVED &&
+        val != MPP_FRAME_SPC_UNSPECIFIED)
+        avctx->colorspace = val;
+
+    if ((val = mpp_frame_get_color_range(mpp_frame)) > MPP_FRAME_RANGE_UNSPECIFIED)
+        avctx->color_range = val;
+
+    if ((val = mpp_frame_get_chroma_location(mpp_frame)) > MPP_CHROMA_LOC_UNSPECIFIED)
+        avctx->chroma_sample_location = val;
+}
 
-            layer->planes[1].object_index = 0;
-            layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
-            layer->planes[1].pitch = layer->planes[0].pitch;
+static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
+{
+    RKMPPDecContext *r = avctx->priv_data;
+    MppFrame mpp_frame = NULL;
+    int ret;
 
-            // we also allocate a struct in buf[0] that will allow to hold additionnal information
-            // for releasing properly MPP frames and decoder
-            framecontextref = av_buffer_allocz(sizeof(*framecontext));
-            if (!framecontextref) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    if ((ret = r->mapi->control(r->mctx, MPP_SET_OUTPUT_TIMEOUT, (MppParam)&timeout)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set output timeout: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
 
-            // MPP decoder needs to be closed only when all frames have been released.
-            framecontext = (RKMPPFrameContext *)framecontextref->data;
-            framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
-            framecontext->frame = mppframe;
+    ret = r->mapi->decode_get_frame(r->mctx, &mpp_frame);
+    if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get frame: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+    if (!mpp_frame) {
+        av_log(avctx, AV_LOG_DEBUG, "Timeout getting decoded frame\n");
+        return AVERROR(EAGAIN);
+    }
+    if (mpp_frame_get_eos(mpp_frame)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a 'EOS' frame\n");
+        r->eof = 1;
+        ret = AVERROR_EOF;
+        goto exit;
+    }
+    if (mpp_frame_get_discard(mpp_frame)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a 'discard' frame\n");
+        ret = AVERROR(EAGAIN);
+        goto exit;
+    }
+    if (mpp_frame_get_errinfo(mpp_frame)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a 'errinfo' frame\n");
+        ret = (r->errinfo_cnt++ > MAX_ERRINFO_COUNT) ? AVERROR_EXTERNAL : AVERROR(EAGAIN);
+        goto exit;
+    }
 
-            frame->data[0]  = (uint8_t *)desc;
-            frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,
-                                               framecontextref, AV_BUFFER_FLAG_READONLY);
+    if (r->info_change = mpp_frame_get_info_change(mpp_frame)) {
+        int fast_parse = r->fast_parse;
+        int mpp_frame_mode = mpp_frame_get_mode(mpp_frame);
+        const MppFrameFormat mpp_fmt = mpp_frame_get_fmt(mpp_frame);
+        enum AVPixelFormat pix_fmts[3] = { AV_PIX_FMT_DRM_PRIME,
+                                           AV_PIX_FMT_NONE,
+                                           AV_PIX_FMT_NONE };
+
+        av_log(avctx, AV_LOG_VERBOSE, "Noticed an info change\n");
+
+        if (r->afbc && !(mpp_fmt & MPP_FRAME_FBC_MASK))
+            av_log(avctx, AV_LOG_VERBOSE, "AFBC is requested but not supported\n");
+
+        pix_fmts[1] = rkmpp_get_av_format(mpp_fmt & MPP_FRAME_FMT_MASK);
+        if ((ret = ff_get_format(avctx, pix_fmts)) < 0)
+            goto exit;
+
+        avctx->pix_fmt      = ret;
+        avctx->width        = mpp_frame_get_width(mpp_frame);
+        avctx->height       = mpp_frame_get_height(mpp_frame);
+        avctx->coded_width  = FFALIGN(avctx->width,  64);
+        avctx->coded_height = FFALIGN(avctx->height, 64);
+        rkmpp_export_avctx_color_props(avctx, mpp_frame);
+
+        av_log(avctx, AV_LOG_VERBOSE, "Configured with size: %dx%d | pix_fmt: %s | sw_pix_fmt: %s\n",
+               avctx->width, avctx->height,
+               av_get_pix_fmt_name(avctx->pix_fmt),
+               av_get_pix_fmt_name(avctx->sw_pix_fmt));
+
+        if ((ret = rkmpp_set_buffer_group(avctx, pix_fmts[1], avctx->width, avctx->height)) < 0)
+            goto exit;
+
+        /* Disable fast parsing for the interlaced video */
+        if (((mpp_frame_mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED ||
+             (mpp_frame_mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST) && fast_parse) {
+            av_log(avctx, AV_LOG_VERBOSE, "Fast parsing is disabled for the interlaced video\n");
+            fast_parse = 0;
+        }
+        if ((ret = r->mapi->control(r->mctx, MPP_DEC_SET_PARSER_FAST_MODE, &fast_parse)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to set parser fast mode: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto exit;
+        }
 
-            if (!frame->buf[0]) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
+        if ((ret = r->mapi->control(r->mctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to set info change ready: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto exit;
+        }
+        goto exit;
+    } else {
+        av_log(avctx, AV_LOG_DEBUG, "Received a frame\n");
+        r->errinfo_cnt = 0;
+
+        switch (avctx->pix_fmt) {
+        case AV_PIX_FMT_DRM_PRIME:
+            {
+                if ((ret = rkmpp_export_frame(avctx, frame, mpp_frame)) < 0)
+                    goto exit;
+                return 0;
             }
-
-            frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
-            if (!frame->hw_frames_ctx) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
+            break;
+        case AV_PIX_FMT_NV12:
+        case AV_PIX_FMT_NV16:
+        case AV_PIX_FMT_NV15:
+        case AV_PIX_FMT_NV20:
+            {
+                AVFrame *tmp_frame = av_frame_alloc();
+                if (!tmp_frame) {
+                    ret = AVERROR(ENOMEM);
+                    goto exit;
+                }
+                if ((ret = rkmpp_export_frame(avctx, tmp_frame, mpp_frame)) < 0)
+                    goto exit;
+
+                if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
+                    av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed: %d\n", ret);
+                    av_frame_free(&tmp_frame);
+                    goto exit;
+                }
+                if ((ret = av_hwframe_transfer_data(frame, tmp_frame, 0)) < 0) {
+                    av_log(avctx, AV_LOG_ERROR, "av_hwframe_transfer_data failed: %d\n", ret);
+                    av_frame_free(&tmp_frame);
+                    goto exit;
+                }
+                if ((ret = av_frame_copy_props(frame, tmp_frame)) < 0) {
+                    av_log(avctx, AV_LOG_ERROR, "av_frame_copy_props failed: %d\n", ret);
+                    av_frame_free(&tmp_frame);
+                    goto exit;
+                }
+                av_frame_free(&tmp_frame);
+                return 0;
             }
-
-            return 0;
-        } else {
-            av_log(avctx, AV_LOG_ERROR, "Failed to retrieve the frame buffer, frame is dropped (code = %d)\n", ret);
-            mpp_frame_deinit(&mppframe);
+            break;
+        default:
+            {
+                ret = AVERROR_BUG;
+                goto exit;
+            }
+            break;
         }
-    } else if (decoder->eos_reached) {
-        return AVERROR_EOF;
-    } else if (ret == MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_DEBUG, "Timeout when trying to get a frame from MPP\n");
     }
 
-    return AVERROR(EAGAIN);
-
-fail:
-    if (mppframe)
-        mpp_frame_deinit(&mppframe);
+exit:
+    if (mpp_frame)
+        mpp_frame_deinit(&mpp_frame);
+    return ret;
+}
 
-    if (framecontext)
-        av_buffer_unref(&framecontext->decoder_ref);
+static int rkmpp_send_eos(AVCodecContext *avctx)
+{
+    RKMPPDecContext *r = avctx->priv_data;
+    MppPacket mpp_pkt = NULL;
+    int ret;
 
-    if (framecontextref)
-        av_buffer_unref(&framecontextref);
+    if ((ret = mpp_packet_init(&mpp_pkt, NULL, 0)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init 'EOS' packet: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+    mpp_packet_set_eos(mpp_pkt);
 
-    if (desc)
-        av_free(desc);
+    do {
+        ret = r->mapi->decode_put_packet(r->mctx, mpp_pkt);
+    } while (ret != MPP_OK);
 
-    return ret;
+    mpp_packet_deinit(&mpp_pkt);
+    return 0;
 }
 
-static int rkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret = MPP_NOK;
-    AVPacket pkt = {0};
-    RK_S32 usedslots, freeslots;
-
-    if (!decoder->eos_reached) {
-        // we get the available slots in decoder
-        ret = decoder->mpi->control(decoder->ctx, MPP_DEC_GET_STREAM_COUNT, &usedslots);
-        if (ret != MPP_OK) {
-            av_log(avctx, AV_LOG_ERROR, "Failed to get decoder used slots (code = %d).\n", ret);
-            return ret;
-        }
+    RKMPPDecContext *r = avctx->priv_data;
+    MppPacket mpp_pkt = NULL;
+    int64_t pts = PTS_TO_MPP_PTS(pkt->pts, avctx->pkt_timebase);
+    int ret;
 
-        freeslots = INPUT_MAX_PACKETS - usedslots;
-        if (freeslots > 0) {
-            ret = ff_decode_get_packet(avctx, &pkt);
-            if (ret < 0 && ret != AVERROR_EOF) {
-                return ret;
-            }
+    if ((ret = mpp_packet_init(&mpp_pkt, pkt->data, pkt->size)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init packet: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+    mpp_packet_set_pts(mpp_pkt, pts);
 
-            ret = rkmpp_send_packet(avctx, &pkt);
-            av_packet_unref(&pkt);
+    if ((ret = r->mapi->decode_put_packet(r->mctx, mpp_pkt)) != MPP_OK) {
+        av_log(avctx, AV_LOG_TRACE, "Decoder buffer is full\n");
+        mpp_packet_deinit(&mpp_pkt);
+        return AVERROR(EAGAIN);
+    }
+    av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", pkt->size);
+
+    mpp_packet_deinit(&mpp_pkt);
+    return 0;
+}
+
+static int rkmpp_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    AVCodecInternal *avci = avctx->internal;
+    RKMPPDecContext *r = avctx->priv_data;
+    AVPacket *pkt = &r->last_pkt;
+    int ret_send, ret_get;
 
-            if (ret < 0) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to send packet to decoder (code = %d)\n", ret);
-                return ret;
+    if (r->info_change && !r->buf_group)
+        return AVERROR_EOF;
+
+    if (!avci->draining) {
+        if (!pkt->size) {
+            switch (ff_decode_get_packet(avctx, pkt)) {
+            case AVERROR_EOF:
+                av_log(avctx, AV_LOG_DEBUG, "Decoder draining\n");
+                ret_send = rkmpp_send_eos(avctx);
+                if (ret_send < 0)
+                    return ret_send;
+                goto get_frame;
+            case AVERROR(EAGAIN):
+                av_log(avctx, AV_LOG_TRACE, "Decoder could not get packet, retrying\n");
+                return AVERROR(EAGAIN);
             }
         }
-
-        // make sure we keep decoder full
-        if (freeslots > 1)
+send_pkt:
+        /* there is definitely a packet to send to decoder */
+        ret_send = rkmpp_send_packet(avctx, pkt);
+        if (ret_send == 0) {
+            /* send successful, continue until decoder input buffer is full */
+            av_packet_unref(pkt);
             return AVERROR(EAGAIN);
+        } else if (ret_send < 0 && ret_send != AVERROR(EAGAIN)) {
+            /* something went wrong, raise error */
+            av_log(avctx, AV_LOG_ERROR, "Decoder failed to send data: %d", ret_send);
+            return ret_send;
+        }
     }
 
-    return rkmpp_retrieve_frame(avctx, frame);
+    if (r->eof)
+        return AVERROR_EOF;
+
+get_frame:
+    /* were here only when draining and buffer is full */
+    ret_get = rkmpp_get_frame(avctx, frame, 100);
+    if (ret_get == AVERROR_EOF)
+        av_log(avctx, AV_LOG_DEBUG, "Decoder is at EOF\n");
+    /* this is not likely but lets handle it in case synchronization issues of MPP */
+    else if (ret_get == AVERROR(EAGAIN) && ret_send == AVERROR(EAGAIN))
+        goto send_pkt;
+    else if (ret_get < 0 && ret_get != AVERROR(EAGAIN))
+        av_log(avctx, AV_LOG_ERROR, "Decoder failed to get frame: %d\n", ret_get);
+
+    return ret_get;
 }
 
-static void rkmpp_flush(AVCodecContext *avctx)
+static void rkmpp_decode_flush(AVCodecContext *avctx)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret = MPP_NOK;
+    RKMPPDecContext *r = avctx->priv_data;
+    int ret;
+
+    av_log(avctx, AV_LOG_DEBUG, "Decoder flushing\n");
 
-    av_log(avctx, AV_LOG_DEBUG, "Flush.\n");
+    if ((ret = r->mapi->reset(r->mctx)) == MPP_OK) {
+        r->eof = 0;
+        r->info_change = 0;
+        r->errinfo_cnt = 0;
 
-    ret = decoder->mpi->reset(decoder->ctx);
-    if (ret == MPP_OK) {
-        decoder->first_packet = 1;
+        av_packet_unref(&r->last_pkt);
+        av_frame_unref(&r->last_frame);
     } else
-        av_log(avctx, AV_LOG_ERROR, "Failed to reset MPI (code = %d)\n", ret);
+        av_log(avctx, AV_LOG_ERROR, "Failed to reset MPP context: %d\n", ret);
 }
 
-static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
-    HW_CONFIG_INTERNAL(DRM_PRIME),
-    NULL
-};
-
-#define RKMPP_DEC_CLASS(NAME) \
-    static const AVClass rkmpp_##NAME##_dec_class = { \
-        .class_name = "rkmpp_" #NAME "_dec", \
-        .version    = LIBAVUTIL_VERSION_INT, \
-    };
-
-#define RKMPP_DEC(NAME, ID, BSFS) \
-    RKMPP_DEC_CLASS(NAME) \
-    const FFCodec ff_##NAME##_rkmpp_decoder = { \
-        .p.name         = #NAME "_rkmpp", \
-        CODEC_LONG_NAME(#NAME " (rkmpp)"), \
-        .p.type         = AVMEDIA_TYPE_VIDEO, \
-        .p.id           = ID, \
-        .priv_data_size = sizeof(RKMPPDecodeContext), \
-        .init           = rkmpp_init_decoder, \
-        .close          = rkmpp_close_decoder, \
-        FF_CODEC_RECEIVE_FRAME_CB(rkmpp_receive_frame), \
-        .flush          = rkmpp_flush, \
-        .p.priv_class   = &rkmpp_##NAME##_dec_class, \
-        .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
-        .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_DRM_PRIME, \
-                                                         AV_PIX_FMT_NONE}, \
-        .hw_configs     = rkmpp_hw_configs, \
-        .bsfs           = BSFS, \
-        .p.wrapper_name = "rkmpp", \
-        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE, \
-    };
-
-RKMPP_DEC(h264,  AV_CODEC_ID_H264,          "h264_mp4toannexb")
-RKMPP_DEC(hevc,  AV_CODEC_ID_HEVC,          "hevc_mp4toannexb")
-RKMPP_DEC(vp8,   AV_CODEC_ID_VP8,           NULL)
-RKMPP_DEC(vp9,   AV_CODEC_ID_VP9,           NULL)
+#if CONFIG_H263_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(h263, H263, NULL)
+#endif
+#if CONFIG_H264_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(h264, H264, "h264_mp4toannexb")
+#endif
+#if CONFIG_HEVC_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(hevc, HEVC, "hevc_mp4toannexb")
+#endif
+#if CONFIG_VP8_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(vp8, VP8, NULL)
+#endif
+#if CONFIG_VP9_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(vp9, VP9, NULL)
+#endif
+#if CONFIG_AV1_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(av1, AV1, NULL)
+#endif
+#if CONFIG_MPEG1_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(mpeg1, MPEG1VIDEO, NULL)
+#endif
+#if CONFIG_MPEG2_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(mpeg2, MPEG2VIDEO, NULL)
+#endif
+#if CONFIG_MPEG4_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(mpeg4, MPEG4, "mpeg4_unpack_bframes")
+#endif
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
new file mode 100644
index 00000000000..7539bedf29e
--- /dev/null
+++ b/libavcodec/rkmppdec.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright (c) 2017 Lionel CHAZALLON
+ * Copyright (c) 2023 Huseyin BIYIK
+ * Copyright (c) 2023 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Rockchip MPP (Media Process Platform) video decoder
+ */
+
+#ifndef AVCODEC_RKMPPDEC_H
+#define AVCODEC_RKMPPDEC_H
+
+#include <rockchip/rk_mpi.h>
+
+#include "codec_internal.h"
+#include "decode.h"
+#include "hwconfig.h"
+#include "internal.h"
+
+#include "libavutil/hwcontext_rkmpp.h"
+#include "libavutil/mastering_display_metadata.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+
+#define MAX_ERRINFO_COUNT 1000
+
+typedef struct RKMPPDecContext {
+    AVClass       *class;
+
+    MppApi        *mapi;
+    MppCtx         mctx;
+    MppBufferGroup buf_group;
+
+    AVBufferRef   *hwdevice;
+    AVBufferRef   *hwframe;
+
+    AVPacket       last_pkt;
+    AVFrame        last_frame;
+
+    int            eof;
+    int            info_change;
+    int            errinfo_cnt;
+
+    int            deint;
+    int            afbc;
+    int            fast_parse;
+    int            buf_mode;
+} RKMPPDecContext;
+
+enum {
+    RKMPP_DEC_AFBC_OFF    = 0,
+    RKMPP_DEC_AFBC_ON     = 1,
+    RKMPP_DEC_AFBC_ON_RGA = 2,
+};
+
+enum {
+    RKMPP_DEC_HALF_INTERNAL = 0,
+    RKMPP_DEC_PURE_EXTERNAL = 1,
+};
+
+static const AVRational mpp_tb = { 1, 1000000 };
+
+#define PTS_TO_MPP_PTS(pts, pts_tb) ((pts_tb.num && pts_tb.den) ? \
+    av_rescale_q(pts, pts_tb, mpp_tb) : pts)
+
+#define MPP_PTS_TO_PTS(mpp_pts, pts_tb) ((pts_tb.num && pts_tb.den) ? \
+    av_rescale_q(mpp_pts, mpp_tb, pts_tb) : mpp_pts)
+
+#define OFFSET(x) offsetof(RKMPPDecContext, x)
+#define VD (AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
+
+static const AVOption options[] = {
+    { "deint",      "Enable IEP (Image Enhancement Processor) for de-interlacing", OFFSET(deint), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, VD },
+    { "afbc",       "Enable AFBC (Arm Frame Buffer Compression) to save bandwidth", OFFSET(afbc), AV_OPT_TYPE_INT, { .i64 = RKMPP_DEC_AFBC_OFF }, 0, 2, VD, "afbc" },
+        { "off",    "Disable AFBC support",                    0, AV_OPT_TYPE_CONST, { .i64 = RKMPP_DEC_AFBC_OFF    }, 0, 0, VD, "afbc" },
+        { "on",     "Enable AFBC support",                     0, AV_OPT_TYPE_CONST, { .i64 = RKMPP_DEC_AFBC_ON     }, 0, 0, VD, "afbc" },
+        { "rga",    "Enable AFBC if capable RGA is available", 0, AV_OPT_TYPE_CONST, { .i64 = RKMPP_DEC_AFBC_ON_RGA }, 0, 0, VD, "afbc" },
+    { "fast_parse", "Enable fast parsing to improve decoding parallelism", OFFSET(fast_parse), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, VD },
+    { "buf_mode",   "Set the buffer mode for MPP decoder", OFFSET(buf_mode), AV_OPT_TYPE_INT, { .i64 = RKMPP_DEC_HALF_INTERNAL }, 0, 1, VD, "buf_mode" },
+        { "half",   "Half internal mode",                      0, AV_OPT_TYPE_CONST, { .i64 = RKMPP_DEC_HALF_INTERNAL }, 0, 0, VD, "buf_mode" },
+        { "ext",    "Pure external mode",                      0, AV_OPT_TYPE_CONST, { .i64 = RKMPP_DEC_PURE_EXTERNAL }, 0, 0, VD, "buf_mode" },
+    { NULL }
+};
+
+static const enum AVPixelFormat rkmpp_dec_pix_fmts[] = {
+    AV_PIX_FMT_NV12,
+    AV_PIX_FMT_NV16,
+    AV_PIX_FMT_NV15,
+    AV_PIX_FMT_NV20,
+    AV_PIX_FMT_DRM_PRIME,
+    AV_PIX_FMT_NONE,
+};
+
+static const AVCodecHWConfigInternal *const rkmpp_dec_hw_configs[] = {
+    &(const AVCodecHWConfigInternal) {
+        .public = {
+            .pix_fmt     = AV_PIX_FMT_DRM_PRIME,
+            .methods     = AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX |
+                           AV_CODEC_HW_CONFIG_METHOD_INTERNAL,
+            .device_type = AV_HWDEVICE_TYPE_RKMPP,
+        },
+        .hwaccel = NULL,
+    },
+    NULL
+};
+
+#define DEFINE_RKMPP_DECODER(x, X, bsf_name) \
+static const AVClass x##_rkmpp_decoder_class = { \
+    .class_name = #x "_rkmpp_decoder", \
+    .item_name  = av_default_item_name, \
+    .option     = options, \
+    .version    = LIBAVUTIL_VERSION_INT, \
+}; \
+const FFCodec ff_##x##_rkmpp_decoder = { \
+    .p.name         = #x "_rkmpp", \
+    CODEC_LONG_NAME("Rockchip MPP (Media Process Platform) " #X " decoder"), \
+    .p.type         = AVMEDIA_TYPE_VIDEO, \
+    .p.id           = AV_CODEC_ID_##X, \
+    .priv_data_size = sizeof(RKMPPDecContext), \
+    .p.priv_class   = &x##_rkmpp_decoder_class, \
+    .init           = rkmpp_decode_init, \
+    .close          = rkmpp_decode_close, \
+    FF_CODEC_RECEIVE_FRAME_CB(rkmpp_decode_receive_frame), \
+    .flush          = rkmpp_decode_flush, \
+    .bsfs           = bsf_name, \
+    .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | \
+                      AV_CODEC_CAP_HARDWARE, \
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | \
+                      FF_CODEC_CAP_SETS_FRAME_PROPS, \
+    .p.pix_fmts     = rkmpp_dec_pix_fmts, \
+    .hw_configs     = rkmpp_dec_hw_configs, \
+    .p.wrapper_name = "rkmpp", \
+};
+
+#endif /* AVCODEC_RKMPPDEC_H */

From d3d5921549bbc3c6643dac1fd6df49a781ae0988 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 28 Dec 2023 02:34:56 +0800
Subject: [PATCH 008/103] lavc/rkmppenc: add RKMPP H264 and HEVC encoder

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure              |   2 +
 libavcodec/Makefile    |   2 +
 libavcodec/allcodecs.c |   2 +
 libavcodec/rkmppenc.c  | 949 +++++++++++++++++++++++++++++++++++++++++
 libavcodec/rkmppenc.h  | 235 ++++++++++
 5 files changed, 1190 insertions(+)
 create mode 100644 libavcodec/rkmppenc.c
 create mode 100644 libavcodec/rkmppenc.h

diff --git a/configure b/configure
index a0c9e09bee5..31e00e26893 100755
--- a/configure
+++ b/configure
@@ -3237,6 +3237,7 @@ h264_qsv_decoder_select="h264_mp4toannexb_bsf qsvdec"
 h264_qsv_encoder_select="atsc_a53 qsvenc"
 h264_rkmpp_decoder_deps="rkmpp"
 h264_rkmpp_decoder_select="h264_mp4toannexb_bsf"
+h264_rkmpp_encoder_deps="rkmpp"
 h264_vaapi_encoder_select="atsc_a53 cbs_h264 vaapi_encode"
 h264_v4l2m2m_decoder_deps="v4l2_m2m h264_v4l2_m2m"
 h264_v4l2m2m_decoder_select="h264_mp4toannexb_bsf"
@@ -3255,6 +3256,7 @@ hevc_qsv_decoder_select="hevc_mp4toannexb_bsf qsvdec"
 hevc_qsv_encoder_select="hevcparse qsvenc"
 hevc_rkmpp_decoder_deps="rkmpp"
 hevc_rkmpp_decoder_select="hevc_mp4toannexb_bsf"
+hevc_rkmpp_encoder_deps="rkmpp"
 hevc_vaapi_encoder_deps="VAEncPictureParameterBufferHEVC"
 hevc_vaapi_encoder_select="atsc_a53 cbs_h265 vaapi_encode"
 hevc_v4l2m2m_decoder_deps="v4l2_m2m hevc_v4l2_m2m"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 8925dd12bca..9932419fa01 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -416,6 +416,7 @@ OBJS-$(CONFIG_H264_OMX_ENCODER)        += omx.o
 OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec.o
 OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
 OBJS-$(CONFIG_H264_RKMPP_DECODER)      += rkmppdec.o
+OBJS-$(CONFIG_H264_RKMPP_ENCODER)      += rkmppenc.o
 OBJS-$(CONFIG_H264_VAAPI_ENCODER)      += vaapi_encode_h264.o h264_levels.o \
                                           h2645data.o
 OBJS-$(CONFIG_H264_VIDEOTOOLBOX_ENCODER) += videotoolboxenc.o
@@ -441,6 +442,7 @@ OBJS-$(CONFIG_HEVC_QSV_DECODER)        += qsvdec.o
 OBJS-$(CONFIG_HEVC_QSV_ENCODER)        += qsvenc_hevc.o hevc_ps_enc.o       \
                                           hevc_data.o
 OBJS-$(CONFIG_HEVC_RKMPP_DECODER)      += rkmppdec.o
+OBJS-$(CONFIG_HEVC_RKMPP_ENCODER)      += rkmppenc.o
 OBJS-$(CONFIG_HEVC_VAAPI_ENCODER)      += vaapi_encode_h265.o h265_profile_level.o \
                                           h2645data.o
 OBJS-$(CONFIG_HEVC_V4L2M2M_DECODER)    += v4l2_m2m_dec.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 16d707cb17a..8c346c9e967 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -862,6 +862,7 @@ extern const FFCodec ff_h264_qsv_encoder;
 extern const FFCodec ff_h264_v4l2m2m_encoder;
 extern const FFCodec ff_h264_vaapi_encoder;
 extern const FFCodec ff_h264_videotoolbox_encoder;
+extern const FFCodec ff_h264_rkmpp_encoder;
 extern const FFCodec ff_hevc_amf_encoder;
 extern const FFCodec ff_hevc_cuvid_decoder;
 extern const FFCodec ff_hevc_mediacodec_decoder;
@@ -872,6 +873,7 @@ extern const FFCodec ff_hevc_qsv_encoder;
 extern const FFCodec ff_hevc_v4l2m2m_encoder;
 extern const FFCodec ff_hevc_vaapi_encoder;
 extern const FFCodec ff_hevc_videotoolbox_encoder;
+extern const FFCodec ff_hevc_rkmpp_encoder;
 extern const FFCodec ff_libkvazaar_encoder;
 extern const FFCodec ff_mjpeg_cuvid_decoder;
 extern const FFCodec ff_mjpeg_qsv_encoder;
diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
new file mode 100644
index 00000000000..97fa74efd32
--- /dev/null
+++ b/libavcodec/rkmppenc.c
@@ -0,0 +1,949 @@
+/*
+ * Copyright (c) 2023 Huseyin BIYIK
+ * Copyright (c) 2023 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Rockchip MPP (Media Process Platform) video encoder
+ */
+
+#include "config_components.h"
+#include "rkmppenc.h"
+
+static MppCodingType rkmpp_get_coding_type(AVCodecContext *avctx)
+{
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H264: return MPP_VIDEO_CodingAVC;
+    case AV_CODEC_ID_HEVC: return MPP_VIDEO_CodingHEVC;
+    default:               return MPP_VIDEO_CodingUnused;
+    }
+}
+
+static MppFrameFormat rkmpp_get_mpp_fmt(enum AVPixelFormat pix_fmt)
+{
+    switch (pix_fmt) {
+    case AV_PIX_FMT_YUV420P: return MPP_FMT_YUV420P;
+    case AV_PIX_FMT_YUV422P: return MPP_FMT_YUV422P;
+    case AV_PIX_FMT_YUV444P: return MPP_FMT_YUV444P;
+    case AV_PIX_FMT_NV12:    return MPP_FMT_YUV420SP;
+    case AV_PIX_FMT_NV21:    return MPP_FMT_YUV420SP_VU;
+    case AV_PIX_FMT_NV16:    return MPP_FMT_YUV422SP;
+    case AV_PIX_FMT_NV24:    return MPP_FMT_YUV444SP;
+    case AV_PIX_FMT_YUYV422: return MPP_FMT_YUV422_YUYV;
+    case AV_PIX_FMT_YVYU422: return MPP_FMT_YUV422_YVYU;
+    case AV_PIX_FMT_UYVY422: return MPP_FMT_YUV422_UYVY;
+    case AV_PIX_FMT_RGB24:   return MPP_FMT_RGB888;
+    case AV_PIX_FMT_BGR24:   return MPP_FMT_BGR888;
+    case AV_PIX_FMT_RGBA:
+    case AV_PIX_FMT_RGB0:    return MPP_FMT_RGBA8888;
+    case AV_PIX_FMT_BGRA:
+    case AV_PIX_FMT_BGR0:    return MPP_FMT_BGRA8888;
+    case AV_PIX_FMT_ARGB:
+    case AV_PIX_FMT_0RGB:    return MPP_FMT_ARGB8888;
+    case AV_PIX_FMT_ABGR:
+    case AV_PIX_FMT_0BGR:    return MPP_FMT_ABGR8888;
+    default:                 return MPP_FMT_BUTT;
+    }
+}
+
+static uint32_t rkmpp_get_drm_afbc_format(MppFrameFormat mpp_fmt)
+{
+    switch (mpp_fmt & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP: return DRM_FORMAT_YUV420_8BIT;
+    case MPP_FMT_YUV422SP: return DRM_FORMAT_YUYV;
+    default:               return DRM_FORMAT_INVALID;
+    }
+}
+
+static int get_byte_stride(const AVDRMObjectDescriptor *object,
+                           const AVDRMLayerDescriptor *layer,
+                           int is_rgb, int is_planar,
+                           int *hs, int *vs)
+{
+    const AVDRMPlaneDescriptor *plane0, *plane1;
+    const int is_packed_fmt = is_rgb || (!is_rgb && !is_planar);
+
+    if (!object || !layer || !hs || !vs)
+        return AVERROR(EINVAL);
+
+    plane0 = &layer->planes[0];
+    plane1 = &layer->planes[1];
+
+    *hs = plane0->pitch;
+    *vs = is_packed_fmt ?
+        ALIGN_DOWN(object->size / plane0->pitch, is_rgb ? 1 : 2) :
+        (plane1->offset / plane0->pitch);
+
+    return (*hs > 0 && *vs > 0) ? 0 : AVERROR(EINVAL);
+}
+
+static unsigned get_used_frame_count(MPPEncFrame *list)
+{
+    unsigned count = 0;
+
+    while (list) {
+        if (list->queued == 1 &&
+            (list->frame || list->mpp_frame))
+            ++count;
+        list = list->next;
+    }
+
+    return count;
+}
+
+static void clear_unused_frames(MPPEncFrame *list)
+{
+    while (list) {
+        if (list->queued == 1) {
+            MppFrame mpp_frame = list->mpp_frame;
+            MppBuffer mpp_buf = NULL;
+
+            if (mpp_frame)
+                mpp_buf = mpp_frame_get_buffer(mpp_frame);
+
+            if (mpp_buf &&
+                mpp_buffer_get_index(mpp_buf) < 0) {
+                mpp_buffer_put(mpp_buf);
+
+                mpp_frame_deinit(&list->mpp_frame);
+                list->mpp_frame = NULL;
+
+                av_frame_free(&list->frame);
+                list->queued = 0;
+            }
+        }
+        list = list->next;
+    }
+}
+
+static void clear_frame_list(MPPEncFrame **list)
+{
+    while (*list) {
+        MPPEncFrame *frame = NULL;
+        MppFrame mpp_frame = NULL;
+        MppBuffer mpp_buf = NULL;
+
+        frame = *list;
+        *list = (*list)->next;
+
+        mpp_frame = frame->mpp_frame;
+        if (mpp_frame) {
+            mpp_buf = mpp_frame_get_buffer(mpp_frame);
+            if (mpp_buf &&
+                mpp_buffer_get_index(mpp_buf) >= 0)
+                mpp_buffer_put(mpp_buf);
+
+            mpp_frame_deinit(&frame->mpp_frame);
+            frame->mpp_frame = NULL;
+        }
+
+        av_frame_free(&frame->frame);
+        av_freep(&frame);
+    }
+}
+
+static MPPEncFrame *get_free_frame(MPPEncFrame **list)
+{
+    MPPEncFrame *out = *list;
+
+    for (; out; out = out->next) {
+        if (!out->queued) {
+            out->queued = 1;
+            break;
+        }
+    }
+
+    if (!out) {
+        out = av_mallocz(sizeof(*out));
+        if (!out) {
+            av_log(NULL, AV_LOG_ERROR, "Cannot alloc new output frame\n");
+            return NULL;
+        }
+        out->queued = 1;
+        out->next   = *list;
+        *list       = out;
+    }
+
+    return out;
+}
+
+static int rkmpp_set_enc_cfg_prep(AVCodecContext *avctx, AVFrame *frame)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+    MppEncCfg cfg = r->mcfg;
+    MppFrameFormat mpp_fmt = r->mpp_fmt;
+    int ret;
+    int hor_stride = 0, ver_stride = 0;
+    const AVPixFmtDescriptor *pix_desc;
+    const AVDRMFrameDescriptor *drm_desc;
+
+    if (r->cfg_init)
+        return 0;
+
+    if (!frame)
+        return AVERROR(EINVAL);
+
+    drm_desc = (AVDRMFrameDescriptor *)frame->data[0];
+    if (drm_desc->objects[0].fd < 0)
+        return AVERROR(ENOMEM);
+
+    pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
+    ret = get_byte_stride(&drm_desc->objects[0],
+                          &drm_desc->layers[0],
+                          (pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
+                          (pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
+                          &hor_stride, &ver_stride);
+    if (ret < 0 || !hor_stride || !ver_stride)
+        return AVERROR(EINVAL);
+
+    mpp_enc_cfg_set_s32(cfg, "prep:width", avctx->width);
+    mpp_enc_cfg_set_s32(cfg, "prep:height", avctx->height);
+    mpp_enc_cfg_set_s32(cfg, "prep:hor_stride", hor_stride);
+    mpp_enc_cfg_set_s32(cfg, "prep:ver_stride", ver_stride);
+
+    mpp_enc_cfg_set_s32(cfg, "prep:colorspace", avctx->colorspace);
+    mpp_enc_cfg_set_s32(cfg, "prep:colorprim", avctx->color_primaries);
+    mpp_enc_cfg_set_s32(cfg, "prep:colortrc", avctx->color_trc);
+    mpp_enc_cfg_set_s32(cfg, "prep:colorrange", avctx->color_range);
+
+    if (drm_is_afbc(drm_desc->objects[0].format_modifier)) {
+        const AVDRMLayerDescriptor *layer = &drm_desc->layers[0];
+        uint32_t drm_afbc_fmt = rkmpp_get_drm_afbc_format(mpp_fmt);
+
+        if (drm_afbc_fmt != layer->format) {
+            av_log(avctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported\n",
+                   av_get_pix_fmt_name(r->pix_fmt));
+            return AVERROR(ENOSYS);
+        }
+        mpp_fmt |= MPP_FRAME_FBC_AFBC_V2;
+    }
+    mpp_enc_cfg_set_s32(cfg, "prep:format", mpp_fmt);
+
+    if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_CFG, cfg)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set config with frame: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
+    r->cfg_init = 1;
+    av_log(avctx, AV_LOG_VERBOSE, "Configured with size: %dx%d | pix_fmt: %s | sw_pix_fmt: %s\n",
+           avctx->width, avctx->height,
+           av_get_pix_fmt_name(avctx->pix_fmt), av_get_pix_fmt_name(r->pix_fmt));
+
+    return 0;
+}
+
+static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+    MppEncCfg cfg = r->mcfg;
+
+    RK_U32 rc_mode, fps_num, fps_den;
+    MppEncHeaderMode header_mode;
+    MppEncSeiMode sei_mode;
+    int max_bps, min_bps;
+    int qp_init, qp_max, qp_min, qp_max_i, qp_min_i;
+    int ret;
+
+    mpp_enc_cfg_set_s32(cfg, "prep:width", avctx->width);
+    mpp_enc_cfg_set_s32(cfg, "prep:height", avctx->height);
+    mpp_enc_cfg_set_s32(cfg, "prep:hor_stride", FFALIGN(avctx->width, 64));
+    mpp_enc_cfg_set_s32(cfg, "prep:ver_stride", FFALIGN(avctx->height, 64));
+    mpp_enc_cfg_set_s32(cfg, "prep:format", MPP_FMT_YUV420SP);
+    mpp_enc_cfg_set_s32(cfg, "prep:mirroring", 0);
+    mpp_enc_cfg_set_s32(cfg, "prep:rotation", 0);
+    mpp_enc_cfg_set_s32(cfg, "prep:flip", 0);
+
+    if (avctx->framerate.den > 0 && avctx->framerate.num > 0)
+        av_reduce(&fps_num, &fps_den, avctx->framerate.num, avctx->framerate.den, 65535);
+    else
+        av_reduce(&fps_num, &fps_den, avctx->time_base.den, avctx->time_base.num, 65535);
+
+    mpp_enc_cfg_set_s32(cfg, "rc:fps_in_flex", 0);
+    mpp_enc_cfg_set_s32(cfg, "rc:fps_in_num", fps_num);
+    mpp_enc_cfg_set_s32(cfg, "rc:fps_in_denorm", fps_den);
+    mpp_enc_cfg_set_s32(cfg, "rc:fps_out_flex", 0);
+    mpp_enc_cfg_set_s32(cfg, "rc:fps_out_num",fps_num);
+    mpp_enc_cfg_set_s32(cfg, "rc:fps_out_denorm", fps_den);
+
+    mpp_enc_cfg_set_s32(cfg, "rc:gop", FFMAX(avctx->gop_size, 1));
+
+    rc_mode = r->rc_mode;
+    if (rc_mode == MPP_ENC_RC_MODE_BUTT) {
+        if (r->qp_init >= 0)
+            rc_mode = MPP_ENC_RC_MODE_FIXQP;
+        else if (avctx->rc_max_rate > 0)
+            rc_mode = MPP_ENC_RC_MODE_VBR;
+        else
+            rc_mode = MPP_ENC_RC_MODE_CBR;
+    }
+
+    switch (rc_mode) {
+    case MPP_ENC_RC_MODE_VBR:
+        av_log(avctx, AV_LOG_VERBOSE, "Rate Control mode is set to VBR\n"); break;
+    case MPP_ENC_RC_MODE_CBR:
+        av_log(avctx, AV_LOG_VERBOSE, "Rate Control mode is set to CBR\n"); break;
+    case MPP_ENC_RC_MODE_FIXQP:
+        av_log(avctx, AV_LOG_VERBOSE, "Rate Control mode is set to CQP\n"); break;
+    case MPP_ENC_RC_MODE_AVBR:
+        av_log(avctx, AV_LOG_VERBOSE, "Rate Control mode is set to AVBR\n"); break;
+    }
+    mpp_enc_cfg_set_u32(cfg, "rc:mode", rc_mode);
+
+    switch (rc_mode) {
+    case MPP_ENC_RC_MODE_FIXQP:
+        /* do not setup bitrate on FIXQP mode */
+        min_bps = max_bps = avctx->bit_rate;
+        break;
+    case MPP_ENC_RC_MODE_VBR:
+    case MPP_ENC_RC_MODE_AVBR:
+        /* VBR mode has wide bound */
+        max_bps = (avctx->rc_max_rate > 0 && avctx->rc_max_rate >= avctx->bit_rate)
+                  ? avctx->rc_max_rate : (avctx->bit_rate * 17 / 16);
+        min_bps = (avctx->rc_min_rate > 0 && avctx->rc_min_rate <= avctx->bit_rate)
+                  ? avctx->rc_min_rate : (avctx->bit_rate * 1 / 16);
+        break;
+    case MPP_ENC_RC_MODE_CBR:
+    default:
+        /* CBR mode has narrow bound */
+        max_bps = avctx->bit_rate * 17 / 16;
+        min_bps = avctx->bit_rate * 15 / 16;
+        break;
+    }
+    mpp_enc_cfg_set_u32(cfg, "rc:bps_target", avctx->bit_rate);
+    mpp_enc_cfg_set_s32(cfg, "rc:bps_max", max_bps);
+    mpp_enc_cfg_set_s32(cfg, "rc:bps_min", min_bps);
+
+    av_log(avctx, AV_LOG_VERBOSE, "Bitrate Target/Min/Max is set to %ld/%d/%d\n",
+           avctx->bit_rate, min_bps, max_bps);
+
+    if (avctx->rc_buffer_size > 0 &&
+        (rc_mode == MPP_ENC_RC_MODE_CBR ||
+         rc_mode == MPP_ENC_RC_MODE_VBR ||
+         rc_mode == MPP_ENC_RC_MODE_AVBR)) {
+        int stats_time_in_sec = avctx->rc_buffer_size / max_bps;
+        if (stats_time_in_sec > 0) {
+            mpp_enc_cfg_set_u32(cfg, "rc:stats_time", stats_time_in_sec);
+            av_log(avctx, AV_LOG_VERBOSE, "Stats time is set to %d\n", stats_time_in_sec);
+        }
+    }
+
+    mpp_enc_cfg_set_u32(cfg, "rc:drop_mode", MPP_ENC_RC_DROP_FRM_DISABLED);
+
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H264:
+    case AV_CODEC_ID_HEVC:
+        {
+            switch (rc_mode) {
+            case MPP_ENC_RC_MODE_FIXQP:
+                qp_init = r->qp_init >= 0 ? r->qp_init : 26;
+                qp_max = qp_min = qp_max_i = qp_min_i = qp_init;
+                mpp_enc_cfg_set_s32(cfg, "rc:qp_ip", 0);
+                break;
+            case MPP_ENC_RC_MODE_CBR:
+            case MPP_ENC_RC_MODE_VBR:
+            case MPP_ENC_RC_MODE_AVBR:
+                qp_max = r->qp_max >= 0 ? r->qp_max : 48;
+                qp_min = FFMIN(r->qp_min >= 0 ? r->qp_min : 0, qp_max);
+                qp_max_i = r->qp_max_i >= 0 ? r->qp_max_i : 48;
+                qp_min_i = FFMIN(r->qp_min_i >= 0 ? r->qp_min_i : 0, qp_max_i);
+                qp_init = FFMIN3(r->qp_init >= 0 ? r->qp_init : 26, qp_max, qp_max_i);
+                mpp_enc_cfg_set_s32(cfg, "rc:qp_ip", 2);
+                break;
+            default:
+                return AVERROR(EINVAL);
+            }
+            mpp_enc_cfg_set_s32(cfg, "rc:qp_init", qp_init);
+            mpp_enc_cfg_set_s32(cfg, "rc:qp_max", qp_max);
+            mpp_enc_cfg_set_s32(cfg, "rc:qp_min", qp_min);
+            mpp_enc_cfg_set_s32(cfg, "rc:qp_max_i",qp_max_i);
+            mpp_enc_cfg_set_s32(cfg, "rc:qp_min_i", qp_min_i);
+        }
+        break;
+    default:
+        return AVERROR(EINVAL);
+    }
+
+    av_log(avctx, AV_LOG_VERBOSE, "QP Init/Max/Min/Max_I/Min_I is set to %d/%d/%d/%d/%d\n",
+           qp_init, qp_max, qp_min, qp_max_i, qp_min_i);
+
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H264:
+        {
+            avctx->profile = r->profile;
+            avctx->level = r->level;
+            mpp_enc_cfg_set_s32(cfg, "h264:profile", avctx->profile);
+            mpp_enc_cfg_set_s32(cfg, "h264:level", avctx->level);
+            mpp_enc_cfg_set_s32(cfg, "h264:cabac_en", r->coder);
+            mpp_enc_cfg_set_s32(cfg, "h264:cabac_idc", 0);
+            mpp_enc_cfg_set_s32(cfg, "h264:trans8x8",
+                                (r->dct8x8 && avctx->profile == AV_PROFILE_H264_HIGH));
+
+            switch (avctx->profile) {
+            case AV_PROFILE_H264_BASELINE:
+                av_log(avctx, AV_LOG_VERBOSE, "Profile is set to BASELINE\n"); break;
+            case AV_PROFILE_H264_MAIN:
+                av_log(avctx, AV_LOG_VERBOSE, "Profile is set to MAIN\n"); break;
+            case AV_PROFILE_H264_HIGH:
+                av_log(avctx, AV_LOG_VERBOSE, "Profile is set to HIGH\n");
+                if (r->dct8x8)
+                    av_log(avctx, AV_LOG_VERBOSE, "8x8 Transform is enabled\n");
+                break;
+            }
+            av_log(avctx, AV_LOG_VERBOSE, "Level is set to %d\n", avctx->level);
+            av_log(avctx, AV_LOG_VERBOSE, "Coder is set to %s\n", r->coder ? "CABAC" : "CAVLC");
+        }
+        break;
+    case AV_CODEC_ID_HEVC:
+        {
+            avctx->profile = AV_PROFILE_HEVC_MAIN;
+            avctx->level = r->level;
+            mpp_enc_cfg_set_s32(cfg, "h265:profile", avctx->profile);
+            mpp_enc_cfg_set_s32(cfg, "h265:level", avctx->level);
+
+            switch (avctx->profile) {
+            case AV_PROFILE_HEVC_MAIN:
+                av_log(avctx, AV_LOG_VERBOSE, "Profile is set to MAIN\n"); break;
+            case AV_PROFILE_HEVC_MAIN_10:
+                av_log(avctx, AV_LOG_VERBOSE, "Profile is set to MAIN 10\n"); break;
+            }
+            av_log(avctx, AV_LOG_VERBOSE, "Level is set to %d\n", avctx->level / 3);
+        }
+        break;
+    default:
+        return AVERROR(EINVAL);
+    }
+
+    if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_CFG, cfg)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set config: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
+    sei_mode = MPP_ENC_SEI_MODE_DISABLE;
+    if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_SEI_CFG, &sei_mode)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set SEI config: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
+    header_mode = MPP_ENC_HEADER_MODE_EACH_IDR;
+    if (avctx->codec_id == AV_CODEC_ID_H264 ||
+        avctx->codec_id == AV_CODEC_ID_HEVC) {
+        if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_HEADER_MODE, &header_mode)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to set header mode: %d\n", ret);
+            return AVERROR_EXTERNAL;
+        }
+    }
+
+    return 0;
+}
+
+static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+    MppFrame mpp_frame = NULL;
+    MppBuffer mpp_buf = NULL;
+    AVFrame *drm_frame = NULL;
+    const AVDRMFrameDescriptor *drm_desc;
+    const AVPixFmtDescriptor *pix_desc;
+    int hor_stride = 0, ver_stride = 0;
+    MppBufferInfo buf_info = { 0 };
+    MppFrameFormat mpp_fmt = r->mpp_fmt;
+    int ret, is_afbc = 0;
+
+    MPPEncFrame *mpp_enc_frame = NULL;
+
+    clear_unused_frames(r->frame_list);
+
+    mpp_enc_frame = get_free_frame(&r->frame_list);
+    if (!mpp_enc_frame)
+        return NULL;
+
+    if ((ret = mpp_frame_init(&mpp_frame)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP frame: %d\n", ret);
+        goto exit;
+    }
+    mpp_enc_frame->mpp_frame = mpp_frame;
+
+    if (!frame) {
+        av_log(avctx, AV_LOG_DEBUG, "End of stream\n");
+        mpp_frame_set_eos(mpp_frame, 1);
+        return mpp_enc_frame;
+    }
+
+    if (avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME) {
+        drm_frame = frame;
+        mpp_enc_frame->frame = av_frame_clone(drm_frame);
+    } else {
+        drm_frame = av_frame_alloc();
+        if (!drm_frame) {
+            goto exit;
+        }
+        if ((ret = av_hwframe_get_buffer(r->hwframe, drm_frame, 0)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Cannot allocate an internal frame: %d\n", ret);
+            goto exit;
+        }
+        if ((ret = av_hwframe_transfer_data(drm_frame, frame, 0)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "av_hwframe_transfer_data failed: %d\n", ret);
+            goto exit;
+        }
+        if ((ret = av_frame_copy_props(drm_frame, frame)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "av_frame_copy_props failed: %d\n", ret);
+            goto exit;
+        }
+        mpp_enc_frame->frame = drm_frame;
+    }
+
+    drm_desc = (AVDRMFrameDescriptor *)drm_frame->data[0];
+    if (drm_desc->objects[0].fd < 0)
+        goto exit;
+
+    is_afbc = drm_is_afbc(drm_desc->objects[0].format_modifier);
+    if ((r->pix_fmt == AV_PIX_FMT_YUV420P ||
+         r->pix_fmt == AV_PIX_FMT_YUV422P ||
+         is_afbc) && (drm_frame->width % 2)) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported width %d, not 2-aligned\n", drm_frame->width);
+        goto exit;
+    }
+
+    mpp_frame_set_pts(mpp_frame, PTS_TO_MPP_PTS(drm_frame->pts, avctx->time_base));
+    mpp_frame_set_width(mpp_frame, drm_frame->width);
+    mpp_frame_set_height(mpp_frame, drm_frame->height);
+
+    mpp_frame_set_colorspace(mpp_frame, avctx->colorspace);
+    mpp_frame_set_color_primaries(mpp_frame, avctx->color_primaries);
+    mpp_frame_set_color_trc(mpp_frame, avctx->color_trc);
+    mpp_frame_set_color_range(mpp_frame, avctx->color_range);
+
+    pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
+    ret = get_byte_stride(&drm_desc->objects[0],
+                          &drm_desc->layers[0],
+                          (pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
+                          (pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
+                          &hor_stride, &ver_stride);
+    if (ret < 0 || !hor_stride || !ver_stride)
+        goto exit;
+
+    mpp_frame_set_hor_stride(mpp_frame, hor_stride);
+    mpp_frame_set_ver_stride(mpp_frame, ver_stride);
+
+    buf_info.type  = MPP_BUFFER_TYPE_DRM;
+    buf_info.fd    = drm_desc->objects[0].fd;
+    buf_info.size  = drm_desc->objects[0].size;
+
+    /* mark buffer as used (idx >= 0) */
+    buf_info.index = buf_info.fd;
+
+    if ((ret = mpp_buffer_import(&mpp_buf, &buf_info)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to import MPP buffer: %d\n", ret);
+        goto exit;
+    }
+    mpp_frame_set_buffer(mpp_frame, mpp_buf);
+    mpp_frame_set_buf_size(mpp_frame, drm_desc->objects[0].size);
+
+    if (is_afbc) {
+        const AVDRMLayerDescriptor *layer = &drm_desc->layers[0];
+        uint32_t drm_afbc_fmt = rkmpp_get_drm_afbc_format(mpp_fmt);
+        int afbc_offset_y = 0;
+
+        if (drm_afbc_fmt != layer->format) {
+            av_log(avctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported\n",
+                   av_get_pix_fmt_name(r->pix_fmt));
+            goto exit;
+        }
+        mpp_fmt |= MPP_FRAME_FBC_AFBC_V2;
+
+        if (layer->planes[0].offset > 0) {
+            afbc_offset_y = layer->planes[0].offset / hor_stride;
+            mpp_frame_set_offset_y(mpp_frame, afbc_offset_y);
+        }
+    }
+    mpp_frame_set_fmt(mpp_frame, mpp_fmt);
+
+    return mpp_enc_frame;
+
+exit:
+    if (drm_frame &&
+        avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME)
+        av_frame_free(&drm_frame);
+
+    return NULL;
+}
+
+static int rkmpp_send_frame(AVCodecContext *avctx, MPPEncFrame *mpp_enc_frame)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+    AVFrame *frame = NULL;
+    MppFrame mpp_frame = NULL;
+    int ret;
+
+    if (mpp_enc_frame) {
+        frame = mpp_enc_frame->frame;
+        mpp_frame = mpp_enc_frame->mpp_frame;
+    }
+
+    if (frame && (ret = rkmpp_set_enc_cfg_prep(avctx, frame)) < 0)
+        goto exit;
+
+    if (frame && frame->pict_type == AV_PICTURE_TYPE_I) {
+        if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_IDR_FRAME, NULL)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to set IDR frame: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto exit;
+        }
+    }
+
+    if ((ret = r->mapi->encode_put_frame(r->mctx, mpp_frame)) != MPP_OK) {
+        int log_level = (ret == MPP_NOK) ? AV_LOG_DEBUG : AV_LOG_ERROR;
+        ret = (ret == MPP_NOK) ? AVERROR(EAGAIN) : AVERROR_EXTERNAL;
+        av_log(avctx, log_level, "Failed to put frame to encoder input queue: %d\n", ret);
+        goto exit;
+    } else
+        av_log(avctx, AV_LOG_DEBUG, "Wrote %ld bytes to encoder\n",
+               mpp_frame_get_buf_size(mpp_frame));
+
+exit:
+    return ret;
+}
+
+static void rkmpp_free_packet_buf(void *opaque, uint8_t *data)
+{
+    MppPacket mpp_pkt = opaque;
+    mpp_packet_deinit(&mpp_pkt);
+}
+
+static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+    MppPacket mpp_pkt = NULL;
+    MppMeta mpp_meta = NULL;
+    MppFrame mpp_frame = NULL;
+    MppBuffer mpp_buf = NULL;
+    int ret, key_frame = 0;
+
+    if ((ret = r->mapi->encode_get_packet(r->mctx, &mpp_pkt)) != MPP_OK) {
+        int log_level = (ret == MPP_NOK) ? AV_LOG_DEBUG : AV_LOG_ERROR;
+        ret = (ret == MPP_NOK) ? AVERROR(EAGAIN) : AVERROR_EXTERNAL;
+        av_log(avctx, log_level, "Failed to get packet from encoder output queue: %d\n", ret);
+        return ret;
+    }
+    if (!mpp_pkt)
+        return AVERROR(ENOMEM);
+
+    if (mpp_packet_get_eos(mpp_pkt)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received an EOS packet\n");
+        ret = AVERROR_EOF;
+        goto exit;
+    }
+    av_log(avctx, AV_LOG_DEBUG, "Received a packet\n");
+
+    packet->data = mpp_packet_get_data(mpp_pkt);
+    packet->size = mpp_packet_get_length(mpp_pkt);
+    packet->buf = av_buffer_create(packet->data, packet->size, rkmpp_free_packet_buf,
+                                   mpp_pkt, AV_BUFFER_FLAG_READONLY);
+    if (!packet->buf) {
+        ret = AVERROR(ENOMEM);
+        goto exit;
+    }
+
+    packet->time_base.num = avctx->time_base.num;
+    packet->time_base.den = avctx->time_base.den;
+    packet->pts = MPP_PTS_TO_PTS(mpp_packet_get_pts(mpp_pkt), avctx->time_base);
+    packet->dts = packet->pts;
+
+    mpp_meta = mpp_packet_get_meta(mpp_pkt);
+    if (!mpp_meta || !mpp_packet_has_meta(mpp_pkt)) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get packet meta\n");
+        ret = AVERROR_EXTERNAL;
+        goto exit;
+    }
+
+    mpp_meta_get_s32(mpp_meta, KEY_OUTPUT_INTRA, &key_frame);
+    if (key_frame)
+        packet->flags |= AV_PKT_FLAG_KEY;
+
+    if ((ret = mpp_meta_get_frame(mpp_meta, KEY_INPUT_FRAME, &mpp_frame)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get key input frame from packet meta: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
+        goto exit;
+    }
+
+    mpp_buf = mpp_frame_get_buffer(mpp_frame);
+    if (!mpp_buf)
+        return AVERROR(ENOMEM);
+
+    /* mark buffer as unused (idx < 0) */
+    mpp_buffer_set_index(mpp_buf, -1);
+    clear_unused_frames(r->frame_list);
+
+    return 0;
+
+exit:
+    if (mpp_pkt)
+        mpp_packet_deinit(&mpp_pkt);
+
+    return ret;
+}
+
+static int rkmpp_encode_frame(AVCodecContext *avctx, AVPacket *packet,
+                              const AVFrame *frame, int *got_packet)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+    MPPEncFrame *mpp_enc_frame = NULL;
+    int surfaces = r->surfaces;
+    int ret;
+
+    if (get_used_frame_count(r->frame_list) > surfaces)
+        goto get;
+
+    mpp_enc_frame = rkmpp_submit_frame(avctx, (AVFrame *)frame);
+    if (!mpp_enc_frame) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to submit frame on input\n");
+        return AVERROR(ENOMEM);
+    }
+
+send:
+    ret = rkmpp_send_frame(avctx, mpp_enc_frame);
+    if (ret == AVERROR(EAGAIN))
+        goto send;
+    else if (ret)
+        return ret;
+
+get:
+    ret = rkmpp_get_packet(avctx, packet);
+    if (ret == AVERROR_EOF ||
+        ret == AVERROR(EAGAIN))
+        *got_packet = 0;
+    else if (ret)
+        return ret;
+    else
+        *got_packet = 1;
+
+    return 0;
+}
+
+static int rkmpp_encode_close(AVCodecContext *avctx)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+
+    r->cfg_init = 0;
+
+    if (r->mapi) {
+        r->mapi->reset(r->mctx);
+        mpp_destroy(r->mctx);
+        r->mctx = NULL;
+    }
+
+    clear_frame_list(&r->frame_list);
+
+    if (r->hwframe)
+        av_buffer_unref(&r->hwframe);
+    if (r->hwdevice)
+        av_buffer_unref(&r->hwdevice);
+
+    return 0;
+}
+
+static av_cold int init_hwframes_ctx(AVCodecContext *avctx)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+    AVHWFramesContext *hwfc;
+    int ret;
+
+    av_buffer_unref(&r->hwframe);
+    r->hwframe = av_hwframe_ctx_alloc(r->hwdevice);
+    if (!r->hwframe)
+        return AVERROR(ENOMEM);
+
+    hwfc            = (AVHWFramesContext *)r->hwframe->data;
+    hwfc->format    = AV_PIX_FMT_DRM_PRIME;
+    hwfc->sw_format = avctx->pix_fmt;
+    hwfc->width     = avctx->width;
+    hwfc->height    = avctx->height;
+
+    ret = av_hwframe_ctx_init(r->hwframe);
+    if (ret < 0) {
+        av_buffer_unref(&r->hwframe);
+        av_log(avctx, AV_LOG_ERROR, "Error creating internal frames_ctx: %d\n", ret);
+        return ret;
+    }
+
+    return 0;
+}
+
+static int rkmpp_encode_init(AVCodecContext *avctx)
+{
+    RKMPPEncContext *r = avctx->priv_data;
+    enum AVPixelFormat pix_fmt = AV_PIX_FMT_NONE;
+    MppFrameFormat mpp_fmt = MPP_FMT_BUTT;
+    MppCodingType coding_type = MPP_VIDEO_CodingUnused;
+    MppPacket mpp_pkt = NULL;
+    int input_timeout = MPP_TIMEOUT_NON_BLOCK;
+    int output_timeout = MPP_TIMEOUT_NON_BLOCK;
+    int ret;
+
+    if ((coding_type = rkmpp_get_coding_type(avctx)) == MPP_VIDEO_CodingUnused) {
+        av_log(avctx, AV_LOG_ERROR, "Unknown codec id: %d\n", avctx->codec_id);
+        return AVERROR(ENOSYS);
+    }
+
+    if ((ret = mpp_check_support_format(MPP_CTX_ENC, coding_type)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "MPP doesn't support encoding codec '%s' (%d)\n",
+               avcodec_get_name(avctx->codec_id), avctx->codec_id);
+        return AVERROR(ENOSYS);
+    }
+
+    if ((ret = mpp_create(&r->mctx, &r->mapi)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create MPP context and api: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
+        goto fail;
+    }
+
+    if ((ret = r->mapi->control(r->mctx, MPP_SET_INPUT_TIMEOUT,
+                                (MppParam)&input_timeout)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set input timeout: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
+    if ((ret = r->mapi->control(r->mctx, MPP_SET_OUTPUT_TIMEOUT,
+                                (MppParam)&output_timeout)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set output timeout: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
+    if ((ret = mpp_init(r->mctx, MPP_CTX_ENC, coding_type)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP context: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
+        goto fail;
+    }
+
+    if ((ret = mpp_enc_cfg_init(&r->mcfg)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init encoder config: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
+        goto fail;
+    }
+
+    if ((ret = r->mapi->control(r->mctx, MPP_ENC_GET_CFG, r->mcfg)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get encoder config: %d\n", ret);
+        ret = AVERROR_EXTERNAL;
+        goto fail;
+    }
+
+    if ((ret = rkmpp_set_enc_cfg(avctx)) < 0)
+        goto fail;
+
+    if (avctx->codec_id == AV_CODEC_ID_H264 ||
+        avctx->codec_id == AV_CODEC_ID_HEVC) {
+        RK_U8 enc_hdr_buf[H26X_HEADER_SIZE];
+        size_t pkt_len = 0;
+        void *pkt_pos = NULL;
+
+        memset(enc_hdr_buf, 0, H26X_HEADER_SIZE);
+
+        if ((ret = mpp_packet_init(&mpp_pkt,
+	                           (void *)enc_hdr_buf,
+                                   H26X_HEADER_SIZE)) != MPP_OK || !mpp_pkt) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to init extra info packet: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto fail;
+        }
+
+        mpp_packet_set_length(mpp_pkt, 0);
+        if ((ret = r->mapi->control(r->mctx, MPP_ENC_GET_HDR_SYNC, mpp_pkt)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get header sync: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto fail;
+        }
+
+        pkt_pos = mpp_packet_get_pos(mpp_pkt);
+        pkt_len = mpp_packet_get_length(mpp_pkt);
+
+        if (avctx->extradata) {
+            av_free(avctx->extradata);
+            avctx->extradata = NULL;
+        }
+        avctx->extradata = av_malloc(pkt_len + AV_INPUT_BUFFER_PADDING_SIZE);
+        if (!avctx->extradata) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        avctx->extradata_size = pkt_len + AV_INPUT_BUFFER_PADDING_SIZE;
+        memcpy(avctx->extradata, pkt_pos, pkt_len);
+        memset(avctx->extradata + pkt_len, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+        mpp_packet_deinit(&mpp_pkt);
+    }
+
+    pix_fmt = avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME ? avctx->sw_pix_fmt : avctx->pix_fmt;
+    mpp_fmt = rkmpp_get_mpp_fmt(pix_fmt) & MPP_FRAME_FMT_MASK;
+
+    if (mpp_fmt == MPP_FMT_BUTT) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported input pixel format '%s'\n",
+               av_get_pix_fmt_name(pix_fmt));
+        return AVERROR(ENOSYS);
+    }
+    r->pix_fmt = pix_fmt;
+    r->mpp_fmt = mpp_fmt;
+
+    if (avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME)
+        return 0;
+
+    if (avctx->hw_frames_ctx || avctx->hw_device_ctx) {
+        AVBufferRef *device_ref = avctx->hw_device_ctx;
+        AVHWFramesContext *hwfc = NULL;
+
+        if (avctx->hw_frames_ctx) {
+            hwfc = (AVHWFramesContext *)avctx->hw_frames_ctx->data;
+            device_ref = hwfc->device_ref;
+        }
+
+        r->hwdevice = av_buffer_ref(device_ref);
+        if (!r->hwdevice) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        av_log(avctx, AV_LOG_VERBOSE, "Picked up an existing RKMPP hardware device\n");
+    } else {
+        if ((ret = av_hwdevice_ctx_create(&r->hwdevice,
+                                          AV_HWDEVICE_TYPE_RKMPP,
+                                          NULL, NULL, 0)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create a RKMPP hardware device: %d\n", ret);
+            goto fail;
+        }
+        av_log(avctx, AV_LOG_VERBOSE, "Created a RKMPP hardware device\n");
+    }
+
+    ret = init_hwframes_ctx(avctx);
+    if (ret < 0)
+        goto fail;
+
+    return 0;
+
+fail:
+    if (mpp_pkt)
+        mpp_packet_deinit(&mpp_pkt);
+
+    rkmpp_encode_close(avctx);
+    return ret;
+}
+
+#if CONFIG_H264_RKMPP_ENCODER
+DEFINE_RKMPP_ENCODER(h264, H264)
+#endif
+#if CONFIG_HEVC_RKMPP_ENCODER
+DEFINE_RKMPP_ENCODER(hevc, HEVC)
+#endif
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
new file mode 100644
index 00000000000..49e53b51e77
--- /dev/null
+++ b/libavcodec/rkmppenc.h
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2023 Huseyin BIYIK
+ * Copyright (c) 2023 NyanMisaka
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Rockchip MPP (Media Process Platform) video encoder
+ */
+
+#ifndef AVCODEC_RKMPPENC_H
+#define AVCODEC_RKMPPENC_H
+
+#include <rockchip/rk_mpi.h>
+
+#include "codec_internal.h"
+#include "encode.h"
+#include "hwconfig.h"
+#include "internal.h"
+
+#include "libavutil/hwcontext_rkmpp.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+
+#define H26X_HEADER_SIZE 1024
+#define ALIGN_DOWN(a, b) ((a) & ~((b)-1))
+
+typedef struct MPPEncFrame {
+    AVFrame            *frame;
+    MppFrame            mpp_frame;
+    struct MPPEncFrame *next;
+    int                 queued;
+} MPPEncFrame;
+
+typedef struct RKMPPEncContext {
+    AVClass           *class;
+
+    MppApi            *mapi;
+    MppCtx             mctx;
+
+    AVBufferRef       *hwdevice;
+    AVBufferRef       *hwframe;
+
+    MppEncCfg          mcfg;
+    int                cfg_init;
+    MppFrameFormat     mpp_fmt;
+    enum AVPixelFormat pix_fmt;
+
+    MPPEncFrame       *frame_list;
+
+    int                rc_mode;
+    int                qp_init;
+    int                qp_max;
+    int                qp_min;
+    int                qp_max_i;
+    int                qp_min_i;
+    int                surfaces;
+    int                profile;
+    int                level;
+    int                coder;
+    int                dct8x8;
+} RKMPPEncContext;
+
+static const AVRational mpp_tb = { 1, 1000000 };
+
+#define PTS_TO_MPP_PTS(pts, pts_tb) ((pts_tb.num && pts_tb.den) ? \
+    av_rescale_q(pts, pts_tb, mpp_tb) : pts)
+
+#define MPP_PTS_TO_PTS(mpp_pts, pts_tb) ((pts_tb.num && pts_tb.den) ? \
+    av_rescale_q(mpp_pts, mpp_tb, pts_tb) : mpp_pts)
+
+#define OFFSET(x) offsetof(RKMPPEncContext, x)
+#define VE (AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
+
+#define RKMPP_ENC_COMMON_OPTS \
+    { "rc_mode", "Set the encoding rate control mode", OFFSET(rc_mode), AV_OPT_TYPE_INT, \
+            { .i64 = MPP_ENC_RC_MODE_BUTT }, MPP_ENC_RC_MODE_VBR, MPP_ENC_RC_MODE_BUTT, VE, "rc_mode"}, \
+        { "VBR", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_ENC_RC_MODE_VBR }, 0, 0, VE, "rc_mode" }, \
+        { "CBR", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_ENC_RC_MODE_CBR }, 0, 0, VE, "rc_mode" }, \
+        { "CQP", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_ENC_RC_MODE_FIXQP }, 0, 0, VE, "rc_mode" }, \
+        { "AVBR", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_ENC_RC_MODE_AVBR }, 0, 0, VE, "rc_mode" }, \
+    { "qp_init", "Set the initial QP value", OFFSET(qp_init), AV_OPT_TYPE_INT, \
+            { .i64 = -1 }, -1, 51, VE, "qmin" }, \
+    { "qp_max", "Set the max QP value for P and B frame", OFFSET(qp_max), AV_OPT_TYPE_INT, \
+            { .i64 = -1 }, -1, 51, VE, "qp_max" }, \
+    { "qp_min", "Set the min QP value for P and B frame", OFFSET(qp_min), AV_OPT_TYPE_INT, \
+            { .i64 = -1 }, -1, 51, VE, "qp_min" }, \
+    { "qp_max_i", "Set the max QP value for I frame", OFFSET(qp_max_i), AV_OPT_TYPE_INT, \
+            { .i64 = -1 }, -1, 51, VE, "qp_max_i" }, \
+    { "qp_min_i", "Set the min QP value for I frame", OFFSET(qp_min_i), AV_OPT_TYPE_INT, \
+            { .i64 = -1 }, -1, 51, VE, "qp_min_i" }, \
+    { "surfaces", "Set the maximum surfaces to be used for encoding", OFFSET(surfaces), AV_OPT_TYPE_INT, \
+            { .i64 = 4 }, 1, 16, VE, "surfaces" },
+
+static const AVOption h264_options[] = {
+    RKMPP_ENC_COMMON_OPTS
+    { "profile", "Set the encoding profile restriction", OFFSET(profile), AV_OPT_TYPE_INT,
+            { .i64 = AV_PROFILE_H264_HIGH }, -1, AV_PROFILE_H264_HIGH, VE, "profile" },
+        { "baseline",   NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_PROFILE_H264_BASELINE }, INT_MIN, INT_MAX, VE, "profile" },
+        { "main",       NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_PROFILE_H264_MAIN },     INT_MIN, INT_MAX, VE, "profile" },
+        { "high",       NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_PROFILE_H264_HIGH },     INT_MIN, INT_MAX, VE, "profile" },
+    { "level", "Set the encoding level restriction", OFFSET(level), AV_OPT_TYPE_INT,
+            { .i64 = 0 }, FF_LEVEL_UNKNOWN, 62, VE, "level" },
+        { "1",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 10 }, 0, 0, VE, "level" },
+        { "1.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 11 }, 0, 0, VE, "level" },
+        { "1.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 12 }, 0, 0, VE, "level" },
+        { "1.3",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 13 }, 0, 0, VE, "level" },
+        { "2",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 20 }, 0, 0, VE, "level" },
+        { "2.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 21 }, 0, 0, VE, "level" },
+        { "2.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 22 }, 0, 0, VE, "level" },
+        { "3",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 30 }, 0, 0, VE, "level" },
+        { "3.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 31 }, 0, 0, VE, "level" },
+        { "3.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 32 }, 0, 0, VE, "level" },
+        { "4",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 40 }, 0, 0, VE, "level" },
+        { "4.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 41 }, 0, 0, VE, "level" },
+        { "4.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 42 }, 0, 0, VE, "level" },
+        { "5",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 50 }, 0, 0, VE, "level" },
+        { "5.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 51 }, 0, 0, VE, "level" },
+        { "5.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 52 }, 0, 0, VE, "level" },
+        { "6",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 60 }, 0, 0, VE, "level" },
+        { "6.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 61 }, 0, 0, VE, "level" },
+        { "6.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 62 }, 0, 0, VE, "level" },
+    { "coder", "Set the entropy coder type (from 0 to 1) (default cabac)", OFFSET(coder), AV_OPT_TYPE_INT,
+            { .i64 = 1 }, 0, 1, VE, "coder" },
+        { "cavlc", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, INT_MIN, INT_MAX, VE, "coder" },
+        { "cabac", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, INT_MIN, INT_MAX, VE, "coder" },
+    { "8x8dct", "Set the high profile 8x8 transform", OFFSET(dct8x8), AV_OPT_TYPE_BOOL,
+            { .i64 = 1 }, 0, 1, VE, "8x8dct" },
+    { NULL }
+};
+
+static const AVOption hevc_options[] = {
+    RKMPP_ENC_COMMON_OPTS
+    { "profile", "Set the encoding profile restriction", OFFSET(profile), AV_OPT_TYPE_INT,
+            { .i64 = AV_PROFILE_HEVC_MAIN }, -1, AV_PROFILE_HEVC_MAIN, VE, "profile" },
+        { "main",       NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_PROFILE_HEVC_MAIN }, INT_MIN, INT_MAX, VE, "profile" },
+    { "level", "Set the encoding level restriction", OFFSET(level), AV_OPT_TYPE_INT,
+            { .i64 = 0 }, FF_LEVEL_UNKNOWN, 186, VE, "level" },
+        { "1",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 30 }, 0, 0, VE, "level" },
+        { "2",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 60 }, 0, 0, VE, "level" },
+        { "2.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 63 }, 0, 0, VE, "level" },
+        { "3",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 90 }, 0, 0, VE, "level" },
+        { "3.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 93 }, 0, 0, VE, "level" },
+        { "4",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 120 }, 0, 0, VE, "level" },
+        { "4.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 123 }, 0, 0, VE, "level" },
+        { "5",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 150 }, 0, 0, VE, "level" },
+        { "5.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 153 }, 0, 0, VE, "level" },
+        { "5.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 156 }, 0, 0, VE, "level" },
+        { "6",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 180 }, 0, 0, VE, "level" },
+        { "6.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 183 }, 0, 0, VE, "level" },
+        { "6.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 186 }, 0, 0, VE, "level" },
+    { NULL }
+};
+
+static const enum AVPixelFormat rkmpp_enc_pix_fmts[] = {
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_YUV422P,
+    AV_PIX_FMT_YUV444P,
+    AV_PIX_FMT_NV12,
+    AV_PIX_FMT_NV21,
+    AV_PIX_FMT_NV16,
+    AV_PIX_FMT_NV24,
+    AV_PIX_FMT_YUYV422,
+    AV_PIX_FMT_YVYU422,
+    AV_PIX_FMT_UYVY422,
+    AV_PIX_FMT_RGB24,
+    AV_PIX_FMT_BGR24,
+    AV_PIX_FMT_RGBA,
+    AV_PIX_FMT_RGB0,
+    AV_PIX_FMT_BGRA,
+    AV_PIX_FMT_BGR0,
+    AV_PIX_FMT_ARGB,
+    AV_PIX_FMT_0RGB,
+    AV_PIX_FMT_ABGR,
+    AV_PIX_FMT_0BGR,
+    AV_PIX_FMT_DRM_PRIME,
+    AV_PIX_FMT_NONE,
+};
+
+static const AVCodecHWConfigInternal *const rkmpp_enc_hw_configs[] = {
+    HW_CONFIG_ENCODER_DEVICE(NONE,      RKMPP),
+    HW_CONFIG_ENCODER_FRAMES(DRM_PRIME, RKMPP),
+    HW_CONFIG_ENCODER_FRAMES(DRM_PRIME, DRM),
+    NULL,
+};
+
+static const FFCodecDefault rkmpp_enc_defaults[] = {
+    { "b",  "2M"  },
+    { "g",  "250" },
+    { NULL }
+};
+
+#define DEFINE_RKMPP_ENCODER(x, X) \
+static const AVClass x##_rkmpp_encoder_class = { \
+    .class_name = #x "_rkmpp_encoder", \
+    .item_name  = av_default_item_name, \
+    .option     = x##_options, \
+    .version    = LIBAVUTIL_VERSION_INT, \
+}; \
+const FFCodec ff_##x##_rkmpp_encoder = { \
+    .p.name         = #x "_rkmpp", \
+    CODEC_LONG_NAME("Rockchip MPP (Media Process Platform) " #X " encoder"), \
+    .p.type         = AVMEDIA_TYPE_VIDEO, \
+    .p.id           = AV_CODEC_ID_##X, \
+    .priv_data_size = sizeof(RKMPPEncContext), \
+    .p.priv_class   = &x##_rkmpp_encoder_class, \
+    .init           = rkmpp_encode_init, \
+    .close          = rkmpp_encode_close, \
+    FF_CODEC_ENCODE_CB(rkmpp_encode_frame), \
+    .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE, \
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | \
+                      FF_CODEC_CAP_INIT_CLEANUP, \
+    .p.pix_fmts     = rkmpp_enc_pix_fmts, \
+    .hw_configs     = rkmpp_enc_hw_configs, \
+    .defaults       = rkmpp_enc_defaults, \
+    .p.wrapper_name = "rkmpp", \
+};
+
+#endif /* AVCODEC_RKMPPENC_H */

From 9aa7638eed9fee823e8311301b3fbee84ac8030f Mon Sep 17 00:00:00 2001
From: rigaya <rigaya34589@live.jp>
Date: Fri, 7 Apr 2023 22:45:51 +0900
Subject: [PATCH 009/103] avdevice/v4l2: add v4l2 multi-planar API support

---
 libavdevice/v4l2.c | 173 ++++++++++++++++++++++++++++++++-------------
 1 file changed, 124 insertions(+), 49 deletions(-)

diff --git a/libavdevice/v4l2.c b/libavdevice/v4l2.c
index 5e85d1a2b34..249bedfaaad 100644
--- a/libavdevice/v4l2.c
+++ b/libavdevice/v4l2.c
@@ -87,14 +87,16 @@ struct video_data {
     int frame_size;
     int interlaced;
     int top_field_first;
+    int multi_planer;
     int ts_mode;
     TimeFilter *timefilter;
     int64_t last_time_m;
 
     int buffers;
     atomic_int buffers_queued;
-    void **buf_start;
-    unsigned int *buf_len;
+    int plane_count;
+    void ***buf_start;
+    unsigned int **buf_len;
     char *standard;
     v4l2_std_id std_id;
     int channel;
@@ -181,11 +183,12 @@ static int device_open(AVFormatContext *ctx, const char* device_path)
     av_log(ctx, AV_LOG_VERBOSE, "fd:%d capabilities:%x\n",
            fd, cap.capabilities);
 
-    if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
+    if (!(cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_CAPTURE_MPLANE))) {
         av_log(ctx, AV_LOG_ERROR, "Not a video capture device.\n");
         err = AVERROR(ENODEV);
         goto fail;
     }
+    s->multi_planer = ((cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_CAPTURE_MPLANE)) == V4L2_CAP_VIDEO_CAPTURE_MPLANE) ? 1 : 0;
 
     if (!(cap.capabilities & V4L2_CAP_STREAMING)) {
         av_log(ctx, AV_LOG_ERROR,
@@ -205,7 +208,7 @@ static int device_init(AVFormatContext *ctx, int *width, int *height,
                        uint32_t pixelformat)
 {
     struct video_data *s = ctx->priv_data;
-    struct v4l2_format fmt = { .type = V4L2_BUF_TYPE_VIDEO_CAPTURE };
+    struct v4l2_format fmt = { .type = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE };
     int res = 0;
 
     fmt.fmt.pix.width = *width;
@@ -287,7 +290,7 @@ static void list_framesizes(AVFormatContext *ctx, uint32_t pixelformat)
 static void list_formats(AVFormatContext *ctx, int type)
 {
     const struct video_data *s = ctx->priv_data;
-    struct v4l2_fmtdesc vfd = { .type = V4L2_BUF_TYPE_VIDEO_CAPTURE };
+    struct v4l2_fmtdesc vfd = { .type = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE };
 
     while(!v4l2_ioctl(s->fd, VIDIOC_ENUM_FMT, &vfd)) {
         enum AVCodecID codec_id = ff_fmt_v4l2codec(vfd.pixelformat);
@@ -351,7 +354,7 @@ static int mmap_init(AVFormatContext *ctx)
     int i, res;
     struct video_data *s = ctx->priv_data;
     struct v4l2_requestbuffers req = {
-        .type   = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+        .type   = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE,
         .count  = desired_video_buffers,
         .memory = V4L2_MEMORY_MMAP
     };
@@ -367,45 +370,71 @@ static int mmap_init(AVFormatContext *ctx)
         return AVERROR(ENOMEM);
     }
     s->buffers = req.count;
-    s->buf_start = av_malloc_array(s->buffers, sizeof(void *));
+    s->buf_start = av_malloc_array(s->buffers, sizeof(void **));
     if (!s->buf_start) {
         av_log(ctx, AV_LOG_ERROR, "Cannot allocate buffer pointers\n");
         return AVERROR(ENOMEM);
     }
-    s->buf_len = av_malloc_array(s->buffers, sizeof(unsigned int));
+    s->buf_len = av_malloc_array(s->buffers, sizeof(unsigned int*));
     if (!s->buf_len) {
         av_log(ctx, AV_LOG_ERROR, "Cannot allocate buffer sizes\n");
         av_freep(&s->buf_start);
         return AVERROR(ENOMEM);
     }
 
+    s->plane_count = 0;
     for (i = 0; i < req.count; i++) {
+        int total_frame_size = 0;
+        int plane_count = 0;
+        struct v4l2_plane planes[VIDEO_MAX_PLANES];
         struct v4l2_buffer buf = {
-            .type   = V4L2_BUF_TYPE_VIDEO_CAPTURE,
-            .index  = i,
-            .memory = V4L2_MEMORY_MMAP
+            .type     = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE,
+            .index    = i,
+            .memory   = V4L2_MEMORY_MMAP,
+            .m.planes = (s->multi_planer) ? planes : 0,
+            .length   = (s->multi_planer) ? VIDEO_MAX_PLANES : 0
         };
         if (v4l2_ioctl(s->fd, VIDIOC_QUERYBUF, &buf) < 0) {
             res = AVERROR(errno);
             av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_QUERYBUF): %s\n", av_err2str(res));
             return res;
         }
-
-        s->buf_len[i] = buf.length;
-        if (s->frame_size > 0 && s->buf_len[i] < s->frame_size) {
-            av_log(ctx, AV_LOG_ERROR,
-                   "buf_len[%d] = %d < expected frame size %d\n",
-                   i, s->buf_len[i], s->frame_size);
+        plane_count = (s->multi_planer) ? buf.length : 1;
+        if (s->plane_count > 0 && s->plane_count != plane_count) {
+            av_log(ctx, AV_LOG_ERROR, "Plane count differed between buffers\n");
+            return AVERROR(EINVAL);
+        }
+        s->plane_count = plane_count;
+        s->buf_start[i] = av_malloc_array(s->plane_count, sizeof(void *));
+        if (!s->buf_start[i]) {
+            av_log(ctx, AV_LOG_ERROR, "Cannot allocate buffer pointers\n");
             return AVERROR(ENOMEM);
         }
-        s->buf_start[i] = v4l2_mmap(NULL, buf.length,
-                               PROT_READ | PROT_WRITE, MAP_SHARED,
-                               s->fd, buf.m.offset);
+        s->buf_len[i] = av_malloc_array(s->plane_count, sizeof(unsigned int*));
+        if (!s->buf_len[i]) {
+            av_log(ctx, AV_LOG_ERROR, "Cannot allocate buffer sizes\n");
+            av_freep(&s->buf_start);
+            return AVERROR(ENOMEM);
+        }
+        for (int iplane = 0; iplane < s->plane_count; iplane++) {
+            s->buf_len[i][iplane] = (s->multi_planer) ? buf.m.planes[iplane].length : buf.length;
+            total_frame_size += s->buf_len[i][iplane];
+            s->buf_start[i][iplane] = v4l2_mmap(NULL, s->buf_len[i][iplane],
+                                PROT_READ | PROT_WRITE, MAP_SHARED,
+                                s->fd, (s->multi_planer) ? buf.m.planes[iplane].m.mem_offset : buf.m.offset);
+
+            if (s->buf_start[i] == MAP_FAILED) {
+                res = AVERROR(errno);
+                av_log(ctx, AV_LOG_ERROR, "mmap: %s\n", av_err2str(res));
+                return res;
+            }
+        }
 
-        if (s->buf_start[i] == MAP_FAILED) {
-            res = AVERROR(errno);
-            av_log(ctx, AV_LOG_ERROR, "mmap: %s\n", av_err2str(res));
-            return res;
+        if (s->frame_size > 0 && total_frame_size < s->frame_size) {
+            av_log(ctx, AV_LOG_ERROR,
+                "buf_len[%d] = %d < expected frame size %d\n",
+                i, total_frame_size, s->frame_size);
+            return AVERROR(ENOMEM);
         }
     }
 
@@ -432,9 +461,9 @@ static void mmap_release_buffer(void *opaque, uint8_t *data)
     struct buff_data *buf_descriptor = opaque;
     struct video_data *s = buf_descriptor->s;
 
-    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    buf.type   = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
     buf.memory = V4L2_MEMORY_MMAP;
-    buf.index = buf_descriptor->index;
+    buf.index  = buf_descriptor->index;
     av_free(buf_descriptor);
 
     enqueue_buffer(s, &buf);
@@ -504,9 +533,12 @@ static int convert_timestamp(AVFormatContext *ctx, int64_t *ts)
 static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)
 {
     struct video_data *s = ctx->priv_data;
+    struct v4l2_plane planes[VIDEO_MAX_PLANES];
     struct v4l2_buffer buf = {
-        .type   = V4L2_BUF_TYPE_VIDEO_CAPTURE,
-        .memory = V4L2_MEMORY_MMAP
+        .type     = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE,
+        .memory   = V4L2_MEMORY_MMAP,
+        .m.planes = (s->multi_planer) ? planes : 0,
+        .length   = (s->multi_planer) ? VIDEO_MAX_PLANES : 0
     };
     struct timeval buf_ts;
     int res;
@@ -544,29 +576,63 @@ static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)
     } else
 #endif
     {
+        int total_frame_size = 0;
+
         /* CPIA is a compressed format and we don't know the exact number of bytes
          * used by a frame, so set it here as the driver announces it. */
         if (ctx->video_codec_id == AV_CODEC_ID_CPIA)
             s->frame_size = buf.bytesused;
 
-        if (s->frame_size > 0 && buf.bytesused != s->frame_size) {
+        if (V4L2_TYPE_IS_MULTIPLANAR(buf.type)) {
+            for (int iplane = 0; iplane < buf.length; iplane++) {
+                total_frame_size += buf.m.planes[iplane].bytesused;
+            }
+        } else {
+            total_frame_size = buf.bytesused;
+        }
+        if (s->frame_size > 0 && total_frame_size != s->frame_size) {
             av_log(ctx, AV_LOG_WARNING,
                    "Dequeued v4l2 buffer contains %d bytes, but %d were expected. Flags: 0x%08X.\n",
-                   buf.bytesused, s->frame_size, buf.flags);
-            buf.bytesused = 0;
+                   total_frame_size, s->frame_size, buf.flags);
+            if (V4L2_TYPE_IS_MULTIPLANAR(buf.type)) {
+                for (int iplane = 0; iplane < buf.length; iplane++) {
+                    buf.m.planes[iplane].bytesused = 0;
+                }
+            } else {
+                buf.bytesused = 0;
+            }
         }
     }
 
-    /* Image is at s->buff_start[buf.index] */
-    if (atomic_load(&s->buffers_queued) == FFMAX(s->buffers / 8, 1)) {
-        /* when we start getting low on queued buffers, fall back on copying data */
-        res = av_new_packet(pkt, buf.bytesused);
-        if (res < 0) {
-            av_log(ctx, AV_LOG_ERROR, "Error allocating a packet.\n");
-            enqueue_buffer(s, &buf);
-            return res;
+    if (atomic_load(&s->buffers_queued) == FFMAX(s->buffers / 8, 1) || V4L2_TYPE_IS_MULTIPLANAR(buf.type)) {
+        if (V4L2_TYPE_IS_MULTIPLANAR(buf.type)) {
+            int totalbytes = 0;
+            for (int iplane = 0; iplane < buf.length; iplane++) {
+                totalbytes += buf.m.planes[iplane].bytesused;
+            }
+            res = av_new_packet(pkt, totalbytes);
+            if (res < 0) {
+                av_log(ctx, AV_LOG_ERROR, "Error allocating a packet.\n");
+                enqueue_buffer(s, &buf);
+                return res;
+            }
+            totalbytes = 0;
+            for (int iplane = 0; iplane < buf.length; iplane++) {
+                struct v4l2_plane *plane = &buf.m.planes[iplane];
+                memcpy(pkt->data + totalbytes, s->buf_start[buf.index][plane->data_offset], plane->bytesused);
+                totalbytes += plane->bytesused;
+            }
+        } else {
+            /* Image is at s->buff_start[buf.index] */
+            /* when we start getting low on queued buffers, fall back on copying data */
+            res = av_new_packet(pkt, buf.bytesused);
+            if (res < 0) {
+                av_log(ctx, AV_LOG_ERROR, "Error allocating a packet.\n");
+                enqueue_buffer(s, &buf);
+                return res;
+            }
+            memcpy(pkt->data, s->buf_start[buf.index][0], buf.bytesused);
         }
-        memcpy(pkt->data, s->buf_start[buf.index], buf.bytesused);
 
         res = enqueue_buffer(s, &buf);
         if (res) {
@@ -576,7 +642,7 @@ static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)
     } else {
         struct buff_data *buf_descriptor;
 
-        pkt->data     = s->buf_start[buf.index];
+        pkt->data     = s->buf_start[buf.index][0];
         pkt->size     = buf.bytesused;
 
         buf_descriptor = av_malloc(sizeof(struct buff_data));
@@ -614,10 +680,13 @@ static int mmap_start(AVFormatContext *ctx)
     int i, res;
 
     for (i = 0; i < s->buffers; i++) {
+        struct v4l2_plane planes[VIDEO_MAX_PLANES];
         struct v4l2_buffer buf = {
-            .type   = V4L2_BUF_TYPE_VIDEO_CAPTURE,
-            .index  = i,
-            .memory = V4L2_MEMORY_MMAP
+            .type     = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE,
+            .index    = i,
+            .memory   = V4L2_MEMORY_MMAP,
+            .m.planes = (s->multi_planer) ? planes : 0,
+            .length   = (s->multi_planer) ? VIDEO_MAX_PLANES : 0
         };
 
         if (v4l2_ioctl(s->fd, VIDIOC_QBUF, &buf) < 0) {
@@ -629,7 +698,7 @@ static int mmap_start(AVFormatContext *ctx)
     }
     atomic_store(&s->buffers_queued, s->buffers);
 
-    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    type = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
     if (v4l2_ioctl(s->fd, VIDIOC_STREAMON, &type) < 0) {
         res = AVERROR(errno);
         av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_STREAMON): %s\n",
@@ -645,13 +714,19 @@ static void mmap_close(struct video_data *s)
     enum v4l2_buf_type type;
     int i;
 
-    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    type = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
     /* We do not check for the result, because we could
      * not do anything about it anyway...
      */
     v4l2_ioctl(s->fd, VIDIOC_STREAMOFF, &type);
     for (i = 0; i < s->buffers; i++) {
-        v4l2_munmap(s->buf_start[i], s->buf_len[i]);
+        for (int iplane = 0; iplane < s->plane_count; iplane++) {
+            v4l2_munmap(s->buf_start[i][iplane], s->buf_len[i][iplane]);
+        }
+    }
+    for (int iplane = 0; iplane < s->plane_count; iplane++) {
+        av_freep(&s->buf_start[iplane]);
+        av_freep(&s->buf_len[iplane]);
     }
     av_freep(&s->buf_start);
     av_freep(&s->buf_len);
@@ -732,7 +807,7 @@ static int v4l2_set_parameters(AVFormatContext *ctx)
         tpf = &streamparm.parm.capture.timeperframe;
     }
 
-    streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    streamparm.type = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
     if (v4l2_ioctl(s->fd, VIDIOC_G_PARM, &streamparm) < 0) {
         ret = AVERROR(errno);
         av_log(ctx, AV_LOG_WARNING, "ioctl(VIDIOC_G_PARM): %s\n", av_err2str(ret));
@@ -920,7 +995,7 @@ static int v4l2_read_header(AVFormatContext *ctx)
     }
 
     if (!s->width && !s->height) {
-        struct v4l2_format fmt = { .type = V4L2_BUF_TYPE_VIDEO_CAPTURE };
+        struct v4l2_format fmt = { .type = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE };
 
         av_log(ctx, AV_LOG_VERBOSE,
                "Querying the device for the current frame size\n");

From cab552d7e118725bd23ae65b843dbbedfe9c2d2e Mon Sep 17 00:00:00 2001
From: rigaya <rigaya34589@live.jp>
Date: Fri, 7 Apr 2023 22:47:10 +0900
Subject: [PATCH 010/103] avdevice/v4l2: add nv16, nv24 support

---
 libavdevice/v4l2-common.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libavdevice/v4l2-common.c b/libavdevice/v4l2-common.c
index b5b4448a315..1926179fdc7 100644
--- a/libavdevice/v4l2-common.c
+++ b/libavdevice/v4l2-common.c
@@ -49,6 +49,8 @@ const struct fmt_map ff_fmt_conversion_table[] = {
 #ifdef V4L2_PIX_FMT_Z16
     { AV_PIX_FMT_GRAY16LE,AV_CODEC_ID_RAWVIDEO, V4L2_PIX_FMT_Z16     },
 #endif
+    { AV_PIX_FMT_NV24,    AV_CODEC_ID_RAWVIDEO, V4L2_PIX_FMT_NV24    },
+    { AV_PIX_FMT_NV16,    AV_CODEC_ID_RAWVIDEO, V4L2_PIX_FMT_NV16    },
     { AV_PIX_FMT_NV12,    AV_CODEC_ID_RAWVIDEO, V4L2_PIX_FMT_NV12    },
     { AV_PIX_FMT_NONE,    AV_CODEC_ID_MJPEG,    V4L2_PIX_FMT_MJPEG   },
     { AV_PIX_FMT_NONE,    AV_CODEC_ID_MJPEG,    V4L2_PIX_FMT_JPEG    },

From b067f43df605ff80964911ea0a03745856eea0d1 Mon Sep 17 00:00:00 2001
From: rigaya <rigaya34589@live.jp>
Date: Sat, 8 Apr 2023 09:48:45 +0900
Subject: [PATCH 011/103] avdevice/v4l2: add option to ignore input error
 (-ignore_input_error).

Some device returns error with VIDIOC_S_INPUT, VIDIOC_G_INPUT.
---
 libavdevice/v4l2.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/libavdevice/v4l2.c b/libavdevice/v4l2.c
index 249bedfaaad..9bdcc324ae9 100644
--- a/libavdevice/v4l2.c
+++ b/libavdevice/v4l2.c
@@ -89,6 +89,7 @@ struct video_data {
     int top_field_first;
     int multi_planer;
     int ts_mode;
+    int ignore_input_error;
     TimeFilter *timefilter;
     int64_t last_time_m;
 
@@ -810,7 +811,7 @@ static int v4l2_set_parameters(AVFormatContext *ctx)
     streamparm.type = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
     if (v4l2_ioctl(s->fd, VIDIOC_G_PARM, &streamparm) < 0) {
         ret = AVERROR(errno);
-        av_log(ctx, AV_LOG_WARNING, "ioctl(VIDIOC_G_PARM): %s\n", av_err2str(ret));
+            av_log(ctx, AV_LOG_WARNING, "ioctl(VIDIOC_G_PARM): %s\n", av_err2str(ret));
     } else if (framerate_q.num && framerate_q.den) {
         if (streamparm.parm.capture.capability & V4L2_CAP_TIMEPERFRAME) {
             tpf = &streamparm.parm.capture.timeperframe;
@@ -940,8 +941,10 @@ static int v4l2_read_header(AVFormatContext *ctx)
         av_log(ctx, AV_LOG_DEBUG, "Selecting input_channel: %d\n", s->channel);
         if (v4l2_ioctl(s->fd, VIDIOC_S_INPUT, &s->channel) < 0) {
             res = AVERROR(errno);
-            av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_S_INPUT): %s\n", av_err2str(res));
-            goto fail;
+            av_log(ctx, (s->ignore_input_error) ? AV_LOG_WARNING : AV_LOG_ERROR, "ioctl(VIDIOC_S_INPUT): %s\n", av_err2str(res));
+            if (!s->ignore_input_error) {
+                goto fail;
+            }
         }
     } else {
         /* get current video input */
@@ -1183,6 +1186,7 @@ static const AVOption options[] = {
     { "pixel_format", "set preferred pixel format",                               OFFSET(pixel_format), AV_OPT_TYPE_STRING, {.str = NULL},  0, 0,       DEC },
     { "input_format", "set preferred pixel format (for raw video) or codec name", OFFSET(pixel_format), AV_OPT_TYPE_STRING, {.str = NULL},  0, 0,       DEC },
     { "framerate",    "set frame rate",                                           OFFSET(framerate),    AV_OPT_TYPE_STRING, {.str = NULL},  0, 0,       DEC },
+    { "ignore_input_error", "ignore input error",                                 OFFSET(ignore_input_error), AV_OPT_TYPE_BOOL, {.i64 = 0 }, 0, 1,      DEC },
 
     { "list_formats", "list available formats and exit",                          OFFSET(list_format),  AV_OPT_TYPE_INT,    {.i64 = 0 },  0, INT_MAX, DEC, "list_formats" },
     { "all",          "show all available formats",                               OFFSET(list_format),  AV_OPT_TYPE_CONST,  {.i64 = V4L_ALLFORMATS  },    0, INT_MAX, DEC, "list_formats" },

From 4d2e94eb6dff0ecc0ec6855a2f00eb96240703aa Mon Sep 17 00:00:00 2001
From: rigaya <rigaya34589@live.jp>
Date: Sat, 8 Apr 2023 09:49:05 +0900
Subject: [PATCH 012/103] avdevice/v4l2: estimate framerate from dv-timings
 when VIDIOC_G_PARM returns error.

---
 libavdevice/v4l2.c | 30 ++++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/libavdevice/v4l2.c b/libavdevice/v4l2.c
index 9bdcc324ae9..2146c6cd570 100644
--- a/libavdevice/v4l2.c
+++ b/libavdevice/v4l2.c
@@ -810,8 +810,38 @@ static int v4l2_set_parameters(AVFormatContext *ctx)
 
     streamparm.type = (s->multi_planer) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_CAPTURE;
     if (v4l2_ioctl(s->fd, VIDIOC_G_PARM, &streamparm) < 0) {
+        // for error cases, try to get frame rate from VIDIOC_G_DV_TIMINGS
+        struct v4l2_dv_timings timings;
         ret = AVERROR(errno);
+        if (v4l2_ioctl(s->fd, VIDIOC_G_DV_TIMINGS, &timings) == 0) {
+            const int total_width  = timings.bt.width  + timings.bt.hfrontporch + timings.bt.hsync + timings.bt.hbackporch;
+            const int total_height = timings.bt.height + timings.bt.vfrontporch + timings.bt.vsync + timings.bt.vbackporch;
+            int64_t framerate_den = 1001;
+            int64_t framerate_num = av_rescale(timings.bt.pixelclock, framerate_den, (int64_t)total_width * total_height);
+            framerate_num = ((framerate_num + 5) / 10) * 10; // round by 10
+            if (framerate_num % 1000 == 0) {
+                tpf->numerator   = framerate_den;
+                tpf->denominator = framerate_num;
+            } else {
+                int framerate_num_dst = 0, framerate_den_dst = 0;
+                framerate_den = 1000;
+                framerate_num = av_rescale(timings.bt.pixelclock, framerate_den, (int64_t)total_width * total_height);
+                framerate_num = ((framerate_num + 5) / 10) * 10; // round by 10
+                av_reduce(&framerate_num_dst, &framerate_den_dst, framerate_num, framerate_den, INT_MAX);
+                tpf->numerator   = framerate_den_dst;
+                tpf->denominator = framerate_num_dst;
+            }
+            av_log(ctx, AV_LOG_WARNING, "ioctl(VIDIOC_G_PARM): %s, estimated framerate %d/%d from dv timings.\n",
+                av_err2str(ret), tpf->denominator, tpf->numerator);
+        } else if (framerate_q.num && framerate_q.den) {
+            // use user defined framerate for further error cases.
+            tpf->numerator   = framerate_q.num;
+            tpf->denominator = framerate_q.den;
+            av_log(ctx, AV_LOG_WARNING, "ioctl(VIDIOC_G_PARM): %s, using framerate %d/%d\n",
+                av_err2str(ret), framerate_q.num, framerate_q.den);
+        } else {
             av_log(ctx, AV_LOG_WARNING, "ioctl(VIDIOC_G_PARM): %s\n", av_err2str(ret));
+        }
     } else if (framerate_q.num && framerate_q.den) {
         if (streamparm.parm.capture.capability & V4L2_CAP_TIMEPERFRAME) {
             tpf = &streamparm.parm.capture.timeperframe;

From 99a325f1f6bbaf264f95e20dd287456e70ac15ed Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Sat, 17 Jun 2023 18:56:02 +0200
Subject: [PATCH 013/103] v4l2: use always channel 0 if driver does not return
 it. Always ignore device select / set errors

---
 libavdevice/v4l2.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/libavdevice/v4l2.c b/libavdevice/v4l2.c
index 2146c6cd570..6b7c5dbc205 100644
--- a/libavdevice/v4l2.c
+++ b/libavdevice/v4l2.c
@@ -980,8 +980,11 @@ static int v4l2_read_header(AVFormatContext *ctx)
         /* get current video input */
         if (v4l2_ioctl(s->fd, VIDIOC_G_INPUT, &s->channel) < 0) {
             res = AVERROR(errno);
-            av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_G_INPUT): %s\n", av_err2str(res));
-            goto fail;
+            av_log(ctx, (s->ignore_input_error) ? AV_LOG_WARNING : AV_LOG_ERROR, "ioctl(VIDIOC_G_INPUT): %s\n", av_err2str(res));
+            if (!s->ignore_input_error)
+                goto fail;
+            else
+                s->channel = 0;
         }
     }
 
@@ -1216,7 +1219,7 @@ static const AVOption options[] = {
     { "pixel_format", "set preferred pixel format",                               OFFSET(pixel_format), AV_OPT_TYPE_STRING, {.str = NULL},  0, 0,       DEC },
     { "input_format", "set preferred pixel format (for raw video) or codec name", OFFSET(pixel_format), AV_OPT_TYPE_STRING, {.str = NULL},  0, 0,       DEC },
     { "framerate",    "set frame rate",                                           OFFSET(framerate),    AV_OPT_TYPE_STRING, {.str = NULL},  0, 0,       DEC },
-    { "ignore_input_error", "ignore input error",                                 OFFSET(ignore_input_error), AV_OPT_TYPE_BOOL, {.i64 = 0 }, 0, 1,      DEC },
+    { "ignore_input_error", "ignore input error",                                 OFFSET(ignore_input_error), AV_OPT_TYPE_BOOL, {.i64 = 1 }, 0, 1,      DEC },
 
     { "list_formats", "list available formats and exit",                          OFFSET(list_format),  AV_OPT_TYPE_INT,    {.i64 = 0 },  0, INT_MAX, DEC, "list_formats" },
     { "all",          "show all available formats",                               OFFSET(list_format),  AV_OPT_TYPE_CONST,  {.i64 = V4L_ALLFORMATS  },    0, INT_MAX, DEC, "list_formats" },

From ade272545520880c03164eb1c2e819c7ea1fd2c4 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 28 Dec 2023 09:34:51 +0800
Subject: [PATCH 014/103] README: update for ffmpeg-rockchip

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 README.md | 92 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 92 insertions(+)

diff --git a/README.md b/README.md
index f8c23f28700..4dad27b8c0d 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,95 @@
+ffmpeg-rockchip
+=============
+This project aims to provide full hardware transcoding pipeline in FFmpeg CLI for Rockchip platforms that support MPP ([Media Process Platform](https://github.com/rockchip-linux/mpp)) and RGA ([2D Raster Graphic Acceleration](https://github.com/airockchip/librga)). This includes hardware decoders, encoders and filters. A typical target platform is RK3588/3588s based devices.
+
+## Hightlights
+* MPP decoders support up to 8K 10-bit H.264, HEVC, VP9 and AV1 decoding
+* MPP decoders support producing AFBC (ARM Frame Buffer Compression) image
+* MPP decoders support de-interlace using IEP (Image Enhancement Processor)
+* MPP decoders support allocator half-internal and pure-external modes
+* MPP encoders support up to 8K H.264 and HEVC encoding
+* MPP encoders support async encoding, AKA frame-parallel
+* MPP encoders support consuming AFBC image
+* RGA filters support image scaling and pixel format conversion
+* RGA filters support image cropping
+* RGA filters support image transposing
+* RGA filters support blending two images
+* RGA filters support async operation
+* RGA filters support producing and consuming AFBC image
+* Zero-copy DMA in above stages
+
+## How to use
+The documentation is available on the [Wiki](https://github.com/nyanmisaka/ffmpeg-rockchip/wiki) page of this project.
+
+
+## Codecs and filters
+### Decoders/Hwaccel
+```
+ V..... av1_rkmpp            Rockchip MPP (Media Process Platform) AV1 decoder (codec av1)
+ V..... h263_rkmpp           Rockchip MPP (Media Process Platform) H263 decoder (codec h263)
+ V..... h264_rkmpp           Rockchip MPP (Media Process Platform) H264 decoder (codec h264)
+ V..... hevc_rkmpp           Rockchip MPP (Media Process Platform) HEVC decoder (codec hevc)
+ V..... mpeg1_rkmpp          Rockchip MPP (Media Process Platform) MPEG1VIDEO decoder (codec mpeg1video)
+ V..... mpeg2_rkmpp          Rockchip MPP (Media Process Platform) MPEG2VIDEO decoder (codec mpeg2video)
+ V..... mpeg4_rkmpp          Rockchip MPP (Media Process Platform) MPEG4 decoder (codec mpeg4)
+ V..... vp8_rkmpp            Rockchip MPP (Media Process Platform) VP8 decoder (codec vp8)
+ V..... vp9_rkmpp            Rockchip MPP (Media Process Platform) VP9 decoder (codec vp9)
+```
+
+### Encoders
+```
+ V..... h264_rkmpp           Rockchip MPP (Media Process Platform) H264 encoder (codec h264)
+ V..... hevc_rkmpp           Rockchip MPP (Media Process Platform) HEVC encoder (codec hevc)
+```
+
+### Filters
+```
+ ... overlay_rkrga     VV->V      Rockchip RGA (2D Raster Graphic Acceleration) video compositor
+ ... scale_rkrga       V->V       Rockchip RGA (2D Raster Graphic Acceleration) video resizer and format converter
+ ... vpp_rkrga         V->V       Rockchip RGA (2D Raster Graphic Acceleration) video post-process (scale/crop/transpose)
+```
+
+## Important
+* Rockchip BSP/vendor kernel is necessary, 5.10 and 6.1 are two tested versions.
+* For the supported maximum resolution and FPS you can refer to the datasheet or TRM.
+* User MUST be granted permission to access these device files.
+```
+# DRM allocator
+/dev/dri
+
+# DMA_HEAP allocator
+/dev/dma_heap
+
+# RGA filters
+/dev/rga
+
+# MPP codecs
+/dev/mpp_service
+
+# Optional, for compatibility with older kernels and socs
+/dev/iep
+/dev/mpp-service
+/dev/vpu_service
+/dev/vpu-service
+/dev/hevc_service
+/dev/hevc-service
+/dev/rkvdec
+/dev/rkvenc
+/dev/vepu
+/dev/h265e
+```
+
+## Todo
+* Support MPP MJPEG/JPEG decoder and encoder
+* Support MPP VP8 video encoder
+* ...
+
+## Acknowledgments
+
+@[hbiyik](https://github.com/hbiyik) @[HermanChen](https://github.com/HermanChen) @[rigaya](https://github.com/rigaya)
+
+---
+
 FFmpeg README
 =============
 

From 9e7314093f635b2641c15e756ec45d2a9bc9f0b9 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sun, 31 Dec 2023 19:12:48 +0800
Subject: [PATCH 015/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index e8478b2150c..04f869a24df 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -121,6 +121,7 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
 
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
+    case AV_PIX_FMT_YUVJ420P:
         is_fmt_supported = 1;
         break;
     case AV_PIX_FMT_YUV420P10:

From 50cc62684ab9b062cecf7db2d3d5e0b8a137c49f Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Wed, 3 Jan 2024 23:10:19 +0800
Subject: [PATCH 016/103] fixup! lavu/hwcontext_drm: preparations for RKMPP
 hwcontext

Introduce AVRKMPPDRMFrameDescriptor

This is exactly like AVDRMFrameDescriptor but attionally it holds
MppBuffer instance used on each index. With that, AVDRMObjectDescriptor
can be kept as is, and no need to modify the existing API.
---
 libavcodec/rkmppdec.c       |  7 ++-
 libavutil/hwcontext_drm.h   | 10 -----
 libavutil/hwcontext_rkmpp.c | 88 ++++++++++++++++---------------------
 libavutil/hwcontext_rkmpp.h | 20 ++++++++-
 4 files changed, 60 insertions(+), 65 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 04f869a24df..f6bb1767ed5 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -321,9 +321,9 @@ static int rkmpp_set_buffer_group(AVCodecContext *avctx,
         MppBufferInfo buf_info = {
             .index = i,
             .type  = MPP_BUFFER_TYPE_DRM,
-            .fd    = rkmpp_fc->frames[i].objects[0].fd,
-            .ptr   = rkmpp_fc->frames[i].objects[0].ptr,
-            .size  = rkmpp_fc->frames[i].objects[0].size,
+            .ptr   = mpp_buffer_get_ptr(rkmpp_fc->frames[i].buffers[0]),
+            .fd    = rkmpp_fc->frames[i].drm_desc.objects[0].fd,
+            .size  = rkmpp_fc->frames[i].drm_desc.objects[0].size,
         };
 
         if ((ret = mpp_buffer_commit(r->buf_group, &buf_info)) != MPP_OK) {
@@ -485,7 +485,6 @@ static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mp
 
     desc->nb_objects = 1;
     desc->objects[0].fd   = mpp_buffer_get_fd(mpp_buf);
-    desc->objects[0].ptr  = mpp_buffer_get_ptr(mpp_buf);
     desc->objects[0].size = mpp_buffer_get_size(mpp_buf);
 
     mpp_fmt = mpp_frame_get_fmt(mpp_frame);
diff --git a/libavutil/hwcontext_drm.h b/libavutil/hwcontext_drm.h
index bc50e427f65..42709f215ef 100644
--- a/libavutil/hwcontext_drm.h
+++ b/libavutil/hwcontext_drm.h
@@ -50,12 +50,6 @@ typedef struct AVDRMObjectDescriptor {
      * DRM PRIME fd for the object.
      */
     int fd;
-    /**
-     * DRM PRIME mapped virtual ptr for above fd.
-     *
-     * The content of this buffer must be readonly when acting decoder's out buffer.
-     */
-    void *ptr;
     /**
      * Total size of the object.
      *
@@ -69,10 +63,6 @@ typedef struct AVDRMObjectDescriptor {
      * DRM_FORMAT_MOD_INVALID.
      */
     uint64_t format_modifier;
-    /**
-     * User opaque for the object.
-     */
-    void *opaque;
 } AVDRMObjectDescriptor;
 
 /**
diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index 8371ccc8811..a3d0c2e76c4 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -124,39 +124,27 @@ static int rkmpp_frames_get_constraints(AVHWDeviceContext *hwdev,
     return 0;
 }
 
-static void rkmpp_free_drm_frame_descriptor(AVRKMPPDeviceContext *hwctx,
-                                            AVDRMFrameDescriptor *desc)
+static void rkmpp_free_drm_frame_descriptor(void *opaque, uint8_t *data)
 {
-    int i, ret;
+
+    MppBuffer mpp_buf = opaque;
+    AVRKMPPDRMFrameDescriptor *desc = (AVRKMPPDRMFrameDescriptor *)data;
+    int ret;
 
     if (!desc)
         return;
 
-    for (i = 0; i < desc->nb_objects; i++) {
-        AVDRMObjectDescriptor *object = &desc->objects[i];
-        MppBuffer mpp_buf = (MppBuffer)object->opaque;
-
-        if (mpp_buf) {
-            ret = mpp_buffer_put(mpp_buf);
-            if (ret != MPP_OK)
-                av_log(NULL, AV_LOG_WARNING,
-                       "Failed to put MPP buffer: %d\n", ret);
-        }
+    if (mpp_buf) {
+        ret = mpp_buffer_put(mpp_buf);
+        if (ret != MPP_OK)
+            av_log(NULL, AV_LOG_WARNING,
+                   "Failed to put MPP buffer: %d\n", ret);
     }
 
     memset(desc, 0, sizeof(*desc));
     av_free(desc);
 }
 
-static void rkmpp_buffer_free(void *opaque, uint8_t *data)
-{
-    AVHWFramesContext *hwfc = opaque;
-    AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
-    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
-
-    rkmpp_free_drm_frame_descriptor(hwctx, desc);
-}
-
 static int rkmpp_get_aligned_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
 {
     const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(pix_fmt);
@@ -189,7 +177,7 @@ static AVBufferRef *rkmpp_drm_pool_alloc(void *opaque, size_t size)
     AVHWFramesContext *hwfc = opaque;
     AVRKMPPFramesContext *avfc = hwfc->hwctx;
     AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
-    AVDRMFrameDescriptor *desc;
+    AVRKMPPDRMFrameDescriptor *desc;
     AVDRMLayerDescriptor *layer;
     AVBufferRef *ref;
 
@@ -210,8 +198,8 @@ static AVBufferRef *rkmpp_drm_pool_alloc(void *opaque, size_t size)
     if (!desc)
         return NULL;
 
-    desc->nb_objects = 1;
-    desc->nb_layers  = 1;
+    desc->drm_desc.nb_objects = 1;
+    desc->drm_desc.nb_layers  = 1;
 
     ret = mpp_buffer_get(avfc->buf_group, &mpp_buf, mpp_buf_size);
     if (ret != MPP_OK || !mpp_buf) {
@@ -219,13 +207,12 @@ static AVBufferRef *rkmpp_drm_pool_alloc(void *opaque, size_t size)
         ret = AVERROR(ENOMEM);
         goto fail;
     }
-    desc->objects[0].opaque = mpp_buf;
+    desc->buffers[0] = mpp_buf;
 
-    desc->objects[0].fd   = mpp_buffer_get_fd(mpp_buf);
-    desc->objects[0].ptr  = mpp_buffer_get_ptr(mpp_buf);
-    desc->objects[0].size = mpp_buffer_get_size(mpp_buf);
+    desc->drm_desc.objects[0].fd   = mpp_buffer_get_fd(mpp_buf);
+    desc->drm_desc.objects[0].size = mpp_buffer_get_size(mpp_buf);
 
-    layer = &desc->layers[0];
+    layer = &desc->drm_desc.layers[0];
     for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++) {
         if (supported_formats[i].pixfmt == hwfc->sw_format) {
             layer->format = supported_formats[i].drm_format;
@@ -247,8 +234,8 @@ static AVBufferRef *rkmpp_drm_pool_alloc(void *opaque, size_t size)
             rkmpp_get_aligned_linesize(hwfc->sw_format, hwfc->width, i);
     }
 
-    ref = av_buffer_create((uint8_t*)desc, sizeof(*desc), rkmpp_buffer_free,
-                           opaque, 0);
+    ref = av_buffer_create((uint8_t*)desc, sizeof(*desc), rkmpp_free_drm_frame_descriptor,
+                           mpp_buf, 0);
     if (!ref) {
         av_log(hwfc, AV_LOG_ERROR, "Failed to create RKMPP buffer.\n");
         goto fail;
@@ -263,7 +250,7 @@ static AVBufferRef *rkmpp_drm_pool_alloc(void *opaque, size_t size)
     return ref;
 
 fail:
-    rkmpp_free_drm_frame_descriptor(hwctx, desc);
+    rkmpp_free_drm_frame_descriptor(mpp_buf, (uint8_t *)desc);
     return NULL;
 }
 
@@ -301,7 +288,7 @@ static int rkmpp_frames_init(AVHWFramesContext *hwfc)
     }
 
     hwfc->internal->pool_internal =
-        av_buffer_pool_init2(sizeof(AVDRMFrameDescriptor), hwfc,
+        av_buffer_pool_init2(sizeof(AVRKMPPDRMFrameDescriptor), hwfc,
                              rkmpp_drm_pool_alloc, NULL);
     if (!hwfc->internal->pool_internal) {
         av_log(hwfc, AV_LOG_ERROR, "Failed to create RKMPP buffer pool.\n");
@@ -371,7 +358,7 @@ static int rkmpp_map_frame(AVHWFramesContext *hwfc,
                            AVFrame *dst, const AVFrame *src, int flags)
 {
     AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
-    const AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)src->data[0];
+    const AVRKMPPDRMFrameDescriptor *desc = (AVRKMPPDRMFrameDescriptor *)src->data[0];
 #if HAVE_LINUX_DMA_BUF_H
     struct dma_buf_sync sync_start = { 0 };
 #endif
@@ -398,44 +385,47 @@ static int rkmpp_map_frame(AVHWFramesContext *hwfc,
     sync_start.flags = DMA_BUF_SYNC_START | map->sync_flags;
 #endif
 
-    if (desc->objects[0].format_modifier != DRM_FORMAT_MOD_LINEAR) {
+    if (desc->drm_desc.objects[0].format_modifier != DRM_FORMAT_MOD_LINEAR) {
         av_log(hwfc, AV_LOG_ERROR, "Transfer non-linear DRM_PRIME frame is not supported!\n");
         return AVERROR(ENOSYS);
     }
 
-    av_assert0(desc->nb_objects <= AV_DRM_MAX_PLANES);
-    for (i = 0; i < desc->nb_objects; i++) {
-        if (desc->objects[i].ptr) {
-            addr = desc->objects[i].ptr;
+    av_assert0(desc->drm_desc.nb_objects <= AV_DRM_MAX_PLANES);
+    for (i = 0; i < desc->drm_desc.nb_objects; i++) {
+        addr = NULL;
+        if (desc->buffers[i])
+            addr = mpp_buffer_get_ptr(desc->buffers[i]);
+
+        if (addr) {
             map->unmap[i] = 0;
         } else {
-            addr = mmap(NULL, desc->objects[i].size, mmap_prot, MAP_SHARED,
-                        desc->objects[i].fd, 0);
+            addr = mmap(NULL, desc->drm_desc.objects[i].size, mmap_prot, MAP_SHARED,
+                        desc->drm_desc.objects[i].fd, 0);
             if (addr == MAP_FAILED) {
                 err = AVERROR(errno);
                 av_log(hwfc, AV_LOG_ERROR, "Failed to map RKMPP object %d to "
-                       "memory: %d.\n", desc->objects[i].fd, errno);
+                       "memory: %d.\n", desc->drm_desc.objects[i].fd, errno);
                 goto fail;
             }
             map->unmap[i] = 1;
         }
 
         map->address[i] = addr;
-        map->length[i]  = desc->objects[i].size;
-        map->object[i] = desc->objects[i].fd;
+        map->length[i]  = desc->drm_desc.objects[i].size;
+        map->object[i]  = desc->drm_desc.objects[i].fd;
 
 #if HAVE_LINUX_DMA_BUF_H
         /* We're not checking for errors here because the kernel may not
          * support the ioctl, in which case its okay to carry on */
         if (hwctx->flags & MPP_BUFFER_FLAGS_CACHABLE)
-            ioctl(desc->objects[i].fd, DMA_BUF_IOCTL_SYNC, &sync_start);
+            ioctl(desc->drm_desc.objects[i].fd, DMA_BUF_IOCTL_SYNC, &sync_start);
 #endif
     }
     map->nb_regions = i;
 
     plane = 0;
-    for (i = 0; i < desc->nb_layers; i++) {
-        const AVDRMLayerDescriptor *layer = &desc->layers[i];
+    for (i = 0; i < desc->drm_desc.nb_layers; i++) {
+        const AVDRMLayerDescriptor *layer = &desc->drm_desc.layers[i];
         for (p = 0; p < layer->nb_planes; p++) {
             dst->data[plane] =
                 (uint8_t*)map->address[layer->planes[p].object_index] +
@@ -457,7 +447,7 @@ static int rkmpp_map_frame(AVHWFramesContext *hwfc,
     return 0;
 
 fail:
-    for (i = 0; i < desc->nb_objects; i++) {
+    for (i = 0; i < desc->drm_desc.nb_objects; i++) {
         if (map->address[i] && map->unmap[i])
             munmap(map->address[i], map->length[i]);
     }
diff --git a/libavutil/hwcontext_rkmpp.h b/libavutil/hwcontext_rkmpp.h
index 796debd316d..09a8c8bf07f 100644
--- a/libavutil/hwcontext_rkmpp.h
+++ b/libavutil/hwcontext_rkmpp.h
@@ -56,6 +56,22 @@
         ((mod >> 52) == (DRM_FORMAT_MOD_ARM_TYPE_AFBC | \
                 (DRM_FORMAT_MOD_VENDOR_ARM << 4)))
 
+/**
+ * DRM Prime Frame descriptor for RKMPP HWDevice.
+ */
+typedef struct AVRKMPPDRMFrameDescriptor {
+    /**
+     * Backwards compatibility with AVDRMFrameDescriptor.
+     */
+    AVDRMFrameDescriptor drm_desc;
+
+    /**
+     * References to MppBuffer instances which are used
+     * on each drm frame index.
+     */
+    MppBuffer buffers[AV_DRM_MAX_PLANES];
+} AVRKMPPDRMFrameDescriptor;
+
 /**
  * RKMPP-specific data associated with a frame pool.
  *
@@ -72,8 +88,8 @@ typedef struct AVRKMPPFramesContext {
      * Only valid if AVHWFramesContext.initial_pool_size was positive.
      * These are intended to be used as the buffer of RKMPP decoder.
      */
-    AVDRMFrameDescriptor *frames;
-    int                nb_frames;
+    AVRKMPPDRMFrameDescriptor *frames;
+    int                     nb_frames;
 } AVRKMPPFramesContext;
 
 /**

From c437e64c98fcb33442ab11f4c5d5950cef12f4a7 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Fri, 12 Jan 2024 15:19:36 +0800
Subject: [PATCH 017/103] lavc/rkmppenc: add GRAY8/YUV400 monochroma support

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 30 ++++++++++++++++--------------
 libavcodec/rkmppenc.h |  1 +
 2 files changed, 17 insertions(+), 14 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 97fa74efd32..bd06a6fc8ff 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -39,6 +39,7 @@ static MppCodingType rkmpp_get_coding_type(AVCodecContext *avctx)
 static MppFrameFormat rkmpp_get_mpp_fmt(enum AVPixelFormat pix_fmt)
 {
     switch (pix_fmt) {
+    case AV_PIX_FMT_GRAY8:   return MPP_FMT_YUV400;
     case AV_PIX_FMT_YUV420P: return MPP_FMT_YUV420P;
     case AV_PIX_FMT_YUV422P: return MPP_FMT_YUV422P;
     case AV_PIX_FMT_YUV444P: return MPP_FMT_YUV444P;
@@ -412,7 +413,8 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
         break;
     case AV_CODEC_ID_HEVC:
         {
-            avctx->profile = AV_PROFILE_HEVC_MAIN;
+            avctx->profile = r->pix_fmt == AV_PIX_FMT_GRAY8
+                ? AV_PROFILE_HEVC_REXT : AV_PROFILE_HEVC_MAIN;
             avctx->level = r->level;
             mpp_enc_cfg_set_s32(cfg, "h265:profile", avctx->profile);
             mpp_enc_cfg_set_s32(cfg, "h265:level", avctx->level);
@@ -420,8 +422,8 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
             switch (avctx->profile) {
             case AV_PROFILE_HEVC_MAIN:
                 av_log(avctx, AV_LOG_VERBOSE, "Profile is set to MAIN\n"); break;
-            case AV_PROFILE_HEVC_MAIN_10:
-                av_log(avctx, AV_LOG_VERBOSE, "Profile is set to MAIN 10\n"); break;
+            case AV_PROFILE_HEVC_REXT:
+                av_log(avctx, AV_LOG_VERBOSE, "Profile is set to REXT\n"); break;
             }
             av_log(avctx, AV_LOG_VERBOSE, "Level is set to %d\n", avctx->level / 3);
         }
@@ -802,6 +804,17 @@ static int rkmpp_encode_init(AVCodecContext *avctx)
         return AVERROR(ENOSYS);
     }
 
+    pix_fmt = avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME ? avctx->sw_pix_fmt : avctx->pix_fmt;
+    mpp_fmt = rkmpp_get_mpp_fmt(pix_fmt) & MPP_FRAME_FMT_MASK;
+
+    if (mpp_fmt == MPP_FMT_BUTT) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported input pixel format '%s'\n",
+               av_get_pix_fmt_name(pix_fmt));
+        return AVERROR(ENOSYS);
+    }
+    r->pix_fmt = pix_fmt;
+    r->mpp_fmt = mpp_fmt;
+
     if ((ret = mpp_check_support_format(MPP_CTX_ENC, coding_type)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "MPP doesn't support encoding codec '%s' (%d)\n",
                avcodec_get_name(avctx->codec_id), avctx->codec_id);
@@ -888,17 +901,6 @@ static int rkmpp_encode_init(AVCodecContext *avctx)
         mpp_packet_deinit(&mpp_pkt);
     }
 
-    pix_fmt = avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME ? avctx->sw_pix_fmt : avctx->pix_fmt;
-    mpp_fmt = rkmpp_get_mpp_fmt(pix_fmt) & MPP_FRAME_FMT_MASK;
-
-    if (mpp_fmt == MPP_FMT_BUTT) {
-        av_log(avctx, AV_LOG_ERROR, "Unsupported input pixel format '%s'\n",
-               av_get_pix_fmt_name(pix_fmt));
-        return AVERROR(ENOSYS);
-    }
-    r->pix_fmt = pix_fmt;
-    r->mpp_fmt = mpp_fmt;
-
     if (avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME)
         return 0;
 
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index 49e53b51e77..0851054ddd4 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -169,6 +169,7 @@ static const AVOption hevc_options[] = {
 };
 
 static const enum AVPixelFormat rkmpp_enc_pix_fmts[] = {
+    AV_PIX_FMT_GRAY8,
     AV_PIX_FMT_YUV420P,
     AV_PIX_FMT_YUV422P,
     AV_PIX_FMT_YUV444P,

From 428a11f982917cde4b9a0115fe552546708637df Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Fri, 12 Jan 2024 18:24:50 +0800
Subject: [PATCH 018/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

EAGAIN should never happen during draining.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 8 ++++++++
 libavcodec/rkmppdec.h | 3 ++-
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index f6bb1767ed5..2660d7b6a8a 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -787,6 +787,7 @@ static int rkmpp_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     AVCodecInternal *avci = avctx->internal;
     RKMPPDecContext *r = avctx->priv_data;
     AVPacket *pkt = &r->last_pkt;
+    int retry_cnt = 0;
     int ret_send, ret_get;
 
     if (r->info_change && !r->buf_group)
@@ -828,6 +829,13 @@ static int rkmpp_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     ret_get = rkmpp_get_frame(avctx, frame, 100);
     if (ret_get == AVERROR_EOF)
         av_log(avctx, AV_LOG_DEBUG, "Decoder is at EOF\n");
+    /* EAGAIN should never happen during draining */
+    else if (avci->draining && ret_get == AVERROR(EAGAIN)) {
+        if (retry_cnt++ < MAX_RETRY_COUNT)
+            goto get_frame;
+        else
+            ret_get = AVERROR_BUG;
+    }
     /* this is not likely but lets handle it in case synchronization issues of MPP */
     else if (ret_get == AVERROR(EAGAIN) && ret_send == AVERROR(EAGAIN))
         goto send_pkt;
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index 7539bedf29e..421a7814adf 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -40,7 +40,8 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 
-#define MAX_ERRINFO_COUNT 1000
+#define MAX_ERRINFO_COUNT 100
+#define MAX_RETRY_COUNT   100
 
 typedef struct RKMPPDecContext {
     AVClass       *class;

From 97e6a5ef2097fe8d3f052146c2ac40a7ba35eb52 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 13 Jan 2024 17:38:31 +0800
Subject: [PATCH 019/103] fixup! lavu/hwcontext_drm: preparations for RKMPP
 hwcontext

adapt rkmppdec half-internal mode to use AVRKMPPDRMFrameDescriptor.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 2660d7b6a8a..09939fcb672 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -442,7 +442,7 @@ static void rkmpp_free_mpp_frame(void *opaque, uint8_t *data)
 
 static void rkmpp_free_drm_desc(void *opaque, uint8_t *data)
 {
-    AVDRMFrameDescriptor *drm_desc = (AVDRMFrameDescriptor *)opaque;
+    AVRKMPPDRMFrameDescriptor *drm_desc = (AVRKMPPDRMFrameDescriptor *)opaque;
     av_free(drm_desc);
 }
 
@@ -465,7 +465,7 @@ static int frame_create_buf(AVFrame *frame,
 static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mpp_frame)
 {
     RKMPPDecContext *r = avctx->priv_data;
-    AVDRMFrameDescriptor *desc = NULL;
+    AVRKMPPDRMFrameDescriptor *desc = NULL;
     AVDRMLayerDescriptor *layer = NULL;
     MppBuffer mpp_buf = NULL;
     MppFrameFormat mpp_fmt = MPP_FMT_BUTT;
@@ -483,19 +483,21 @@ static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mp
     if (!desc)
         return AVERROR(ENOMEM);
 
-    desc->nb_objects = 1;
-    desc->objects[0].fd   = mpp_buffer_get_fd(mpp_buf);
-    desc->objects[0].size = mpp_buffer_get_size(mpp_buf);
+    desc->drm_desc.nb_objects = 1;
+    desc->buffers[0] = mpp_buf;
+
+    desc->drm_desc.objects[0].fd   = mpp_buffer_get_fd(mpp_buf);
+    desc->drm_desc.objects[0].size = mpp_buffer_get_size(mpp_buf);
 
     mpp_fmt = mpp_frame_get_fmt(mpp_frame);
     is_afbc = mpp_fmt & MPP_FRAME_FBC_MASK;
 
     if (is_afbc)
-        desc->objects[0].format_modifier =
+        desc->drm_desc.objects[0].format_modifier =
             DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
 
-    desc->nb_layers = 1;
-    layer = &desc->layers[0];
+    desc->drm_desc.nb_layers = 1;
+    layer = &desc->drm_desc.layers[0];
     layer->format = is_afbc ? rkmpp_get_drm_afbc_format(mpp_fmt)
                             : rkmpp_get_drm_format(mpp_fmt);
 

From 2938ac0758883a31e41e02590dd913ce5b79cb60 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 15 Jan 2024 22:25:58 +0800
Subject: [PATCH 020/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

Improve RKMPP HWdevice selection.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index bd06a6fc8ff..62054ae0e9b 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -906,20 +906,22 @@ static int rkmpp_encode_init(AVCodecContext *avctx)
 
     if (avctx->hw_frames_ctx || avctx->hw_device_ctx) {
         AVBufferRef *device_ref = avctx->hw_device_ctx;
+        AVHWDeviceContext *device_ctx = NULL;
         AVHWFramesContext *hwfc = NULL;
 
         if (avctx->hw_frames_ctx) {
             hwfc = (AVHWFramesContext *)avctx->hw_frames_ctx->data;
             device_ref = hwfc->device_ref;
         }
+        device_ctx = (AVHWDeviceContext *)device_ref->data;
 
-        r->hwdevice = av_buffer_ref(device_ref);
-        if (!r->hwdevice) {
-            ret = AVERROR(ENOMEM);
-            goto fail;
+        if (device_ctx && device_ctx->type == AV_HWDEVICE_TYPE_RKMPP) {
+            r->hwdevice = av_buffer_ref(device_ref);
+            if (r->hwdevice)
+                av_log(avctx, AV_LOG_VERBOSE, "Picked up an existing RKMPP hardware device\n");
         }
-        av_log(avctx, AV_LOG_VERBOSE, "Picked up an existing RKMPP hardware device\n");
-    } else {
+    }
+    if (!r->hwdevice) {
         if ((ret = av_hwdevice_ctx_create(&r->hwdevice,
                                           AV_HWDEVICE_TYPE_RKMPP,
                                           NULL, NULL, 0)) < 0) {

From d0a1484db466d62b7700fb0c899593b0142cf28c Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Fri, 19 Jan 2024 02:03:13 +0800
Subject: [PATCH 021/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

Add HwFramesContext config method support.
---
 libavcodec/rkmppdec.c | 35 +++++++++++++++++++++++------------
 libavcodec/rkmppdec.h |  1 +
 2 files changed, 24 insertions(+), 12 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 09939fcb672..c5fb45edcf1 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -136,22 +136,28 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
         is_fmt_supported =
             avctx->codec_id == AV_CODEC_ID_H264;
         break;
+    case AV_PIX_FMT_NONE: /* fallback to drm_prime */
+        is_fmt_supported = 1;
+        avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
+        break;
     default:
         is_fmt_supported = 0;
         break;
     }
 
-    if (!is_fmt_supported) {
-        av_log(avctx, AV_LOG_ERROR, "MPP doesn't support codec '%s' with pix_fmt '%s'\n",
-               avcodec_get_name(avctx->codec_id), av_get_pix_fmt_name(avctx->pix_fmt));
-        return AVERROR(ENOSYS);
-    }
+    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
+        if (!is_fmt_supported) {
+            av_log(avctx, AV_LOG_ERROR, "MPP doesn't support codec '%s' with pix_fmt '%s'\n",
+                   avcodec_get_name(avctx->codec_id), av_get_pix_fmt_name(avctx->pix_fmt));
+            return AVERROR(ENOSYS);
+        }
 
-    if ((ret = ff_get_format(avctx, pix_fmts)) < 0) {
-        av_log(avctx, AV_LOG_ERROR, "ff_get_format failed: %d\n", ret);
-        return ret;
+        if ((ret = ff_get_format(avctx, pix_fmts)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "ff_get_format failed: %d\n", ret);
+            return ret;
+        }
+        avctx->pix_fmt = ret;
     }
-    avctx->pix_fmt = ret;
 
     if ((coding_type = rkmpp_get_coding_type(avctx)) == MPP_VIDEO_CodingUnused) {
         av_log(avctx, AV_LOG_ERROR, "Unknown codec id: %d\n", avctx->codec_id);
@@ -645,10 +651,15 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
             av_log(avctx, AV_LOG_VERBOSE, "AFBC is requested but not supported\n");
 
         pix_fmts[1] = rkmpp_get_av_format(mpp_fmt & MPP_FRAME_FMT_MASK);
-        if ((ret = ff_get_format(avctx, pix_fmts)) < 0)
-            goto exit;
 
-        avctx->pix_fmt      = ret;
+        if (avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME)
+            avctx->sw_pix_fmt = pix_fmts[1];
+        else {
+            if ((ret = ff_get_format(avctx, pix_fmts)) < 0)
+                goto exit;
+            avctx->pix_fmt = ret;
+        }
+
         avctx->width        = mpp_frame_get_width(mpp_frame);
         avctx->height       = mpp_frame_get_height(mpp_frame);
         avctx->coded_width  = FFALIGN(avctx->width,  64);
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index 421a7814adf..6ba0e464259 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -115,6 +115,7 @@ static const AVCodecHWConfigInternal *const rkmpp_dec_hw_configs[] = {
         .public = {
             .pix_fmt     = AV_PIX_FMT_DRM_PRIME,
             .methods     = AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX |
+                           AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX |
                            AV_CODEC_HW_CONFIG_METHOD_INTERNAL,
             .device_type = AV_HWDEVICE_TYPE_RKMPP,
         },

From 2b2e075476f36a5d1d06fc52e67c22297bd0547e Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Fri, 19 Jan 2024 20:39:26 +0800
Subject: [PATCH 022/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

disable `force_{original_aspect_ratio,divisible_by}` options for
the vpp_rkrga filter and leave it to scale_rkrga.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/vf_vpp_rkrga.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
index 3c9c2e1c218..c6ff6cc83e0 100644
--- a/libavfilter/vf_vpp_rkrga.c
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -371,11 +371,6 @@ static av_cold void rgavpp_uninit(AVFilterContext *ctx)
 #define FLAGS (AV_OPT_FLAG_FILTERING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
 
 #define RKRGA_VPP_COMMON_OPTS \
-    { "force_original_aspect_ratio", "Decrease or increase w/h if necessary to keep the original AR", OFFSET(force_original_aspect_ratio), AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 2, FLAGS, "force_oar" }, \
-        { "disable",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, "force_oar" }, \
-        { "decrease", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "force_oar" }, \
-        { "increase", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, "force_oar" }, \
-    { "force_divisible_by", "Enforce that the output resolution is divisible by a defined integer when force_original_aspect_ratio is used", OFFSET(force_divisible_by), AV_OPT_TYPE_INT, { .i64 = 2 }, 1, 256, FLAGS }, \
     { "core", "Set multicore RGA scheduler core [use with caution]", OFFSET(rga.scheduler_core), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, 0, INT_MAX, FLAGS, "core" }, \
         { "default",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, "core" }, \
         { "rga3_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE0 */ \
@@ -405,6 +400,11 @@ static const AVOption rgascale_options[] = {
     { "w",  "Output video width",  OFFSET(ow), AV_OPT_TYPE_STRING, { .str = "iw" }, 0, 0, FLAGS },
     { "h",  "Output video height", OFFSET(oh), AV_OPT_TYPE_STRING, { .str = "ih" }, 0, 0, FLAGS },
     { "format", "Output video pixel format", OFFSET(format), AV_OPT_TYPE_PIXEL_FMT, { .i64 = AV_PIX_FMT_NONE }, INT_MIN, INT_MAX, .flags = FLAGS },
+    { "force_original_aspect_ratio", "Decrease or increase w/h if necessary to keep the original AR", OFFSET(force_original_aspect_ratio), AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 2, FLAGS, "force_oar" }, \
+        { "disable",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, "force_oar" }, \
+        { "decrease", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "force_oar" }, \
+        { "increase", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, "force_oar" }, \
+    { "force_divisible_by", "Enforce that the output resolution is divisible by a defined integer when force_original_aspect_ratio is used", OFFSET(force_divisible_by), AV_OPT_TYPE_INT, { .i64 = 2 }, 1, 256, FLAGS }, \
     RKRGA_VPP_COMMON_OPTS
     { NULL },
 };

From e0775b91e285df038d9d8063348e4090c87b44b5 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Sun, 21 Jan 2024 18:18:40 +0800
Subject: [PATCH 023/103] lavu/hwcontext_drm: add P210 format

---
 libavutil/hwcontext_rkmpp.c | 1 +
 libavutil/hwcontext_rkmpp.h | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index a3d0c2e76c4..092b868d523 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -54,6 +54,7 @@ static const struct {
     { AV_PIX_FMT_NV24,     DRM_FORMAT_NV24,     },
     /* semi-planar YUV 10-bit */
     { AV_PIX_FMT_P010,     DRM_FORMAT_P010,     },
+    { AV_PIX_FMT_P210,     DRM_FORMAT_P210,     },
     { AV_PIX_FMT_NV15,     DRM_FORMAT_NV15,     },
     { AV_PIX_FMT_NV20,     DRM_FORMAT_NV20,     },
     /* packed YUV */
diff --git a/libavutil/hwcontext_rkmpp.h b/libavutil/hwcontext_rkmpp.h
index 09a8c8bf07f..3097f275308 100644
--- a/libavutil/hwcontext_rkmpp.h
+++ b/libavutil/hwcontext_rkmpp.h
@@ -29,6 +29,9 @@
 #ifndef DRM_FORMAT_P010
 #define DRM_FORMAT_P010         fourcc_code('P', '0', '1', '0')
 #endif
+#ifndef DRM_FORMAT_P210
+#define DRM_FORMAT_P210         fourcc_code('P', '2', '1', '0')
+#endif
 #ifndef DRM_FORMAT_NV15
 #define DRM_FORMAT_NV15         fourcc_code('N', 'V', '1', '5')
 #endif

From 668585f514b0326154d4c47df087b30d123e3154 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Sun, 21 Jan 2024 18:19:34 +0800
Subject: [PATCH 024/103] lavf/rkrga: add P210 format support

---
 libavfilter/rkrga_common.c | 57 +++++++++++++++++++++++++-------------
 1 file changed, 38 insertions(+), 19 deletions(-)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 14c46f7238f..813b4768537 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -50,8 +50,9 @@ typedef struct RGAFormatMap {
     { AV_PIX_FMT_NV21,     RK_FORMAT_YCrCb_420_SP }, \
     { AV_PIX_FMT_NV16,     RK_FORMAT_YCbCr_422_SP }, \
     { AV_PIX_FMT_P010,     RK_FORMAT_YCbCr_420_SP_10B }, /* RGA3 only */ \
+    { AV_PIX_FMT_P210,     RK_FORMAT_YCbCr_422_SP_10B }, /* RGA3 only */ \
     { AV_PIX_FMT_NV15,     RK_FORMAT_YCbCr_420_SP_10B }, /* RGA2 only input, aka P010 compact */ \
-    { AV_PIX_FMT_NV20,     RK_FORMAT_YCbCr_422_SP_10B }, \
+    { AV_PIX_FMT_NV20,     RK_FORMAT_YCbCr_422_SP_10B }, /* RGA2 only input, aka P210 compact */ \
     { AV_PIX_FMT_YUYV422,  RK_FORMAT_YUYV_422 }, \
     { AV_PIX_FMT_YVYU422,  RK_FORMAT_YVYU_422 }, \
     { AV_PIX_FMT_UYVY422,  RK_FORMAT_UYVY_422 },
@@ -314,6 +315,13 @@ static int verify_rga_frame_info_io_dynamic(AVFilterContext *avctx,
                av_get_pix_fmt_name(AV_PIX_FMT_P010));
         return AVERROR(ENOSYS);
     }
+    if (r->is_rga2_used &&
+        (in->pix_fmt == AV_PIX_FMT_P210 ||
+         out->pix_fmt == AV_PIX_FMT_P210)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' is not supported if RGA2 is requested\n",
+               av_get_pix_fmt_name(AV_PIX_FMT_P210));
+        return AVERROR(ENOSYS);
+    }
     if (r->is_rga2_used &&
         (out->pix_fmt == AV_PIX_FMT_NV15 ||
          out->pix_fmt == AV_PIX_FMT_NV20)) {
@@ -689,6 +697,14 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
                av_get_pix_fmt_name(AV_PIX_FMT_P010));
         return AVERROR(ENOSYS);
     }
+    /* P210 requires RGA3 */
+    if (!r->has_rga3 &&
+        (src->pix_fmt == AV_PIX_FMT_P210 ||
+         dst->pix_fmt == AV_PIX_FMT_P210)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' is only supported by RGA3\n",
+               av_get_pix_fmt_name(AV_PIX_FMT_P210));
+        return AVERROR(ENOSYS);
+    }
     /* Input formats that requires RGA2 */
     if (!r->has_rga2 &&
         (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
@@ -715,29 +731,31 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
                av_get_pix_fmt_name(dst->pix_fmt));
         return AVERROR(ENOSYS);
     }
-    /* P010 requires RGA3 but it can't handle certain formats */
-    if (src->pix_fmt == AV_PIX_FMT_P010 &&
-        (dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
-         dst->pix_fmt == AV_PIX_FMT_YUV420P ||
-         dst->pix_fmt == AV_PIX_FMT_YUV422P ||
-         dst->pix_fmt == AV_PIX_FMT_RGB555LE ||
-         dst->pix_fmt == AV_PIX_FMT_BGR555LE ||
-         dst->pix_fmt == AV_PIX_FMT_ARGB ||
-         dst->pix_fmt == AV_PIX_FMT_0RGB ||
-         dst->pix_fmt == AV_PIX_FMT_ABGR ||
-         dst->pix_fmt == AV_PIX_FMT_0BGR)) {
+    /* P010/P210 requires RGA3 but it can't handle certain formats */
+    if ((src->pix_fmt == AV_PIX_FMT_P010 ||
+         src->pix_fmt == AV_PIX_FMT_P210) &&
+         (dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
+          dst->pix_fmt == AV_PIX_FMT_YUV420P ||
+          dst->pix_fmt == AV_PIX_FMT_YUV422P ||
+          dst->pix_fmt == AV_PIX_FMT_RGB555LE ||
+          dst->pix_fmt == AV_PIX_FMT_BGR555LE ||
+          dst->pix_fmt == AV_PIX_FMT_ARGB ||
+          dst->pix_fmt == AV_PIX_FMT_0RGB ||
+          dst->pix_fmt == AV_PIX_FMT_ABGR ||
+          dst->pix_fmt == AV_PIX_FMT_0BGR)) {
         av_log(avctx, AV_LOG_ERROR, "'%s' to '%s' is not supported\n",
                av_get_pix_fmt_name(src->pix_fmt),
                av_get_pix_fmt_name(dst->pix_fmt));
         return AVERROR(ENOSYS);
     }
     /* RGA3 only format to RGA2 only format is not supported */
-    if (dst->pix_fmt == AV_PIX_FMT_P010 &&
-        (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
-         src->pix_fmt == AV_PIX_FMT_YUV420P ||
-         src->pix_fmt == AV_PIX_FMT_YUV422P ||
-         src->pix_fmt == AV_PIX_FMT_RGB555LE ||
-         src->pix_fmt == AV_PIX_FMT_BGR555LE)) {
+    if ((dst->pix_fmt == AV_PIX_FMT_P010 ||
+         dst->pix_fmt == AV_PIX_FMT_P210) &&
+         (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
+          src->pix_fmt == AV_PIX_FMT_YUV420P ||
+          src->pix_fmt == AV_PIX_FMT_YUV422P ||
+          src->pix_fmt == AV_PIX_FMT_RGB555LE ||
+          src->pix_fmt == AV_PIX_FMT_BGR555LE)) {
         av_log(avctx, AV_LOG_ERROR, "'%s' to '%s' is not supported\n",
                av_get_pix_fmt_name(src->pix_fmt),
                av_get_pix_fmt_name(dst->pix_fmt));
@@ -849,7 +867,8 @@ static av_cold int fill_rga_frame_info_by_link(AVFilterContext *avctx,
         info->act_h = ALIGN_DOWN(info->act_h, RK_RGA_YUV_ALIGN);
     }
 
-    info->uncompact_10b_msb = info->pix_fmt == AV_PIX_FMT_P010;
+    info->uncompact_10b_msb = info->pix_fmt == AV_PIX_FMT_P010 ||
+                              info->pix_fmt == AV_PIX_FMT_P210;
 
     if (link->w * link->h > (3840 * 2160 * 3))
         r->async_depth = FFMIN(r->async_depth, 1);

From e753665e6d9c37285b54e1d599053f41f5f987a5 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 23 Jan 2024 16:13:32 +0800
Subject: [PATCH 025/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

Fix the latency issue in decoder output.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 15 +++++++++++++--
 libavcodec/rkmppdec.h |  2 ++
 2 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index c5fb45edcf1..788c0c5c9ba 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -90,6 +90,8 @@ static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
     r->eof = 0;
     r->info_change = 0;
     r->errinfo_cnt = 0;
+    r->queue_cnt = 0;
+    r->queue_size = 0;
 
     if (r->mapi) {
         r->mapi->reset(r->mctx);
@@ -826,12 +828,17 @@ static int rkmpp_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
         if (ret_send == 0) {
             /* send successful, continue until decoder input buffer is full */
             av_packet_unref(pkt);
-            return AVERROR(EAGAIN);
+            r->queue_cnt++;
+            if (r->queue_size <= 0 ||
+                r->queue_cnt < r->queue_size)
+                return AVERROR(EAGAIN);
         } else if (ret_send < 0 && ret_send != AVERROR(EAGAIN)) {
             /* something went wrong, raise error */
             av_log(avctx, AV_LOG_ERROR, "Decoder failed to send data: %d", ret_send);
             return ret_send;
-        }
+        } else
+            /* input buffer is full, estimate queue size */
+            r->queue_size = FFMAX(r->queue_cnt, r->queue_size);
     }
 
     if (r->eof)
@@ -854,6 +861,8 @@ static int rkmpp_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
         goto send_pkt;
     else if (ret_get < 0 && ret_get != AVERROR(EAGAIN))
         av_log(avctx, AV_LOG_ERROR, "Decoder failed to get frame: %d\n", ret_get);
+    else
+        r->queue_cnt--;
 
     return ret_get;
 }
@@ -869,6 +878,8 @@ static void rkmpp_decode_flush(AVCodecContext *avctx)
         r->eof = 0;
         r->info_change = 0;
         r->errinfo_cnt = 0;
+        r->queue_cnt = 0;
+        r->queue_size = 0;
 
         av_packet_unref(&r->last_pkt);
         av_frame_unref(&r->last_frame);
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index 6ba0e464259..f2749f21f8f 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -59,6 +59,8 @@ typedef struct RKMPPDecContext {
     int            eof;
     int            info_change;
     int            errinfo_cnt;
+    int            queue_cnt;
+    int            queue_size;
 
     int            deint;
     int            afbc;

From caef8e7f05590f60f0e690b9ddfb8f6bc2ff9df0 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 23 Jan 2024 16:14:52 +0800
Subject: [PATCH 026/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

Fix the issue that some PGSSUB subtitle have incorrect color.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 813b4768537..6be7edd342b 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -955,10 +955,8 @@ av_cold int ff_rkrga_init(AVFilterContext *avctx, RKRGAParam *param)
             r->in_rga_frame_infos[0].blend_mode = premultiplied_alpha ? (0x4 | (1 << 12)) : 0x4;
             r->in_rga_frame_infos[0].blend_mode |= (param->in_global_alpha & 0xff) << 16; /* fg_global_alpha */
             r->in_rga_frame_infos[0].blend_mode |= 0xff << 24;                            /* bg_global_alpha */
-        } else {
+        } else
             r->in_rga_frame_infos[0].blend_mode = premultiplied_alpha ? 0x504 : 0x501;
-            r->in_rga_frame_infos[0].blend_mode |= (0xff << 16) | (0xff << 24);
-        }
 
         r->in_rga_frame_infos[1].overlay_x = FFMAX(param->overlay_x, 0);
         r->in_rga_frame_infos[1].overlay_y = FFMAX(param->overlay_y, 0);

From d023c944aca487907c36d244f8a62f6ec4417dd3 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 23 Jan 2024 20:04:55 +0800
Subject: [PATCH 027/103] lavu: add NV20 bitstream format support

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/pixdesc.c              | 12 ++++++++++++
 libavutil/pixfmt.h               |  8 ++++----
 tests/ref/fate/imgutils          |  1 +
 tests/ref/fate/sws-pixdesc-query |  5 +++++
 4 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/libavutil/pixdesc.c b/libavutil/pixdesc.c
index 27f052400f6..abbdbb55212 100644
--- a/libavutil/pixdesc.c
+++ b/libavutil/pixdesc.c
@@ -2805,6 +2805,18 @@ static const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = {
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BITSTREAM,
     },
+    [AV_PIX_FMT_NV20] = {
+        .name = "nv20",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 10,  0, 0, 10 },      /* Y */
+            { 1, 20,  0, 0, 10 },      /* U */
+            { 1, 20, 10, 0, 10 },      /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BITSTREAM,
+    },
 };
 
 static const char * const color_range_names[] = {
diff --git a/libavutil/pixfmt.h b/libavutil/pixfmt.h
index 9c6cd4fb6ad..ba16ea9925b 100644
--- a/libavutil/pixfmt.h
+++ b/libavutil/pixfmt.h
@@ -189,8 +189,8 @@ enum AVPixelFormat {
     AV_PIX_FMT_XYZ12LE,      ///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0
     AV_PIX_FMT_XYZ12BE,      ///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0
     AV_PIX_FMT_NV16,         ///< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
-    AV_PIX_FMT_NV20LE,       ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    AV_PIX_FMT_NV20BE,       ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
+    AV_PIX_FMT_NV20LE,       ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian, deprecated in favor of AV_PIX_FMT_NV20
+    AV_PIX_FMT_NV20BE,       ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian, deprecated in favor of AV_PIX_FMT_NV20
 
     AV_PIX_FMT_RGBA64BE,     ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
     AV_PIX_FMT_RGBA64LE,     ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
@@ -429,7 +429,8 @@ enum AVPixelFormat {
     AV_PIX_FMT_GBRAP14BE,  ///< planar GBR 4:4:4:4 56bpp, big-endian
     AV_PIX_FMT_GBRAP14LE,  ///< planar GBR 4:4:4:4 56bpp, little-endian
 
-    AV_PIX_FMT_NV15,        ///< like P010, but has no zero padding bits, 15bpp, little-endian
+    AV_PIX_FMT_NV15,        ///< like P010, but has no zero padding bits, 15bpp, bitstream
+    AV_PIX_FMT_NV20,        ///< like P210, but has no zero padding bits, 20bpp, bitstream
 
     AV_PIX_FMT_NB         ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
@@ -515,7 +516,6 @@ enum AVPixelFormat {
 #define AV_PIX_FMT_YUVA444P16 AV_PIX_FMT_NE(YUVA444P16BE, YUVA444P16LE)
 
 #define AV_PIX_FMT_XYZ12      AV_PIX_FMT_NE(XYZ12BE, XYZ12LE)
-#define AV_PIX_FMT_NV20       AV_PIX_FMT_NE(NV20BE,  NV20LE)
 #define AV_PIX_FMT_AYUV64     AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)
 #define AV_PIX_FMT_P010       AV_PIX_FMT_NE(P010BE,  P010LE)
 #define AV_PIX_FMT_P012       AV_PIX_FMT_NE(P012BE,  P012LE)
diff --git a/tests/ref/fate/imgutils b/tests/ref/fate/imgutils
index 62de71ddb9d..41b1c8fcca3 100644
--- a/tests/ref/fate/imgutils
+++ b/tests/ref/fate/imgutils
@@ -269,3 +269,4 @@ p412le          planes: 2, linesizes: 128 256   0   0, plane_sizes:  6144 12288
 gbrap14be       planes: 4, linesizes: 128 128 128 128, plane_sizes:  6144  6144  6144  6144, plane_offsets:  6144  6144  6144, total_size: 24576
 gbrap14le       planes: 4, linesizes: 128 128 128 128, plane_sizes:  6144  6144  6144  6144, plane_offsets:  6144  6144  6144, total_size: 24576
 nv15            planes: 2, linesizes:  80  80   0   0, plane_sizes:  3840  1920     0     0, plane_offsets:  3840     0     0, total_size: 5760
+nv20            planes: 2, linesizes:  80  80   0   0, plane_sizes:  3840  3840     0     0, plane_offsets:  3840     0     0, total_size: 7680
diff --git a/tests/ref/fate/sws-pixdesc-query b/tests/ref/fate/sws-pixdesc-query
index c89434fc0b9..9b427ff0a1f 100644
--- a/tests/ref/fate/sws-pixdesc-query
+++ b/tests/ref/fate/sws-pixdesc-query
@@ -62,6 +62,7 @@ isNBPS:
   gray9be
   gray9le
   nv15
+  nv20
   nv20be
   nv20le
   p010be
@@ -224,6 +225,7 @@ isYUV:
   nv12
   nv15
   nv16
+  nv20
   nv20be
   nv20le
   nv21
@@ -341,6 +343,7 @@ isPlanarYUV:
   nv12
   nv15
   nv16
+  nv20
   nv20be
   nv20le
   nv21
@@ -439,6 +442,7 @@ isSemiPlanarYUV:
   nv12
   nv15
   nv16
+  nv20
   nv20be
   nv20le
   nv21
@@ -874,6 +878,7 @@ Planar:
   nv12
   nv15
   nv16
+  nv20
   nv20be
   nv20le
   nv21

From f508e46403235e35aa16080751b3d1a80e1d9783 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 23 Jan 2024 20:05:43 +0800
Subject: [PATCH 028/103] Revert "HACK: lavu: allow image copy for NV15 and
 NV20"

This reverts commit c359d00d131770502deaf1c198211edcf43fa013.
---
 libavutil/imgutils.c | 26 +++++++-------------------
 1 file changed, 7 insertions(+), 19 deletions(-)

diff --git a/libavutil/imgutils.c b/libavutil/imgutils.c
index c703425a066..da3812698e6 100644
--- a/libavutil/imgutils.c
+++ b/libavutil/imgutils.c
@@ -341,19 +341,6 @@ int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     return AVERROR(EINVAL);
 }
 
-static void image_copy_plane2(uint8_t       *dst, ptrdiff_t dst_linesize,
-                              const uint8_t *src, ptrdiff_t src_linesize,
-                              ptrdiff_t bytewidth, int height)
-{
-    if (!dst || !src)
-        return;
-    for (;height > 0; height--) {
-        memcpy(dst, src, bytewidth);
-        dst += dst_linesize;
-        src += src_linesize;
-    }
-}
-
 static void image_copy_plane(uint8_t       *dst, ptrdiff_t dst_linesize,
                              const uint8_t *src, ptrdiff_t src_linesize,
                              ptrdiff_t bytewidth, int height)
@@ -362,9 +349,11 @@ static void image_copy_plane(uint8_t       *dst, ptrdiff_t dst_linesize,
         return;
     av_assert0(FFABS(src_linesize) >= bytewidth);
     av_assert0(FFABS(dst_linesize) >= bytewidth);
-    image_copy_plane2(dst, dst_linesize,
-                      src, src_linesize,
-                      bytewidth, height);
+    for (;height > 0; height--) {
+        memcpy(dst, src, bytewidth);
+        dst += dst_linesize;
+        src += src_linesize;
+    }
 }
 
 void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize,
@@ -435,8 +424,7 @@ void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4],
                    enum AVPixelFormat pix_fmt, int width, int height)
 {
     ptrdiff_t dst_linesizes1[4], src_linesizes1[4];
-    int i, is_nv15_20 = pix_fmt == AV_PIX_FMT_NV15 ||
-                        pix_fmt == AV_PIX_FMT_NV20;
+    int i;
 
     for (i = 0; i < 4; i++) {
         dst_linesizes1[i] = dst_linesizes[i];
@@ -444,7 +432,7 @@ void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4],
     }
 
     image_copy(dst_data, dst_linesizes1, src_data, src_linesizes1, pix_fmt,
-               width, height, is_nv15_20 ? image_copy_plane2 : image_copy_plane);
+               width, height, image_copy_plane);
 }
 
 void av_image_copy_uc_from(uint8_t * const dst_data[4], const ptrdiff_t dst_linesizes[4],

From 30b1033ec4ceb89fab6172c746db93f7f960290e Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 24 Jan 2024 20:00:04 +0800
Subject: [PATCH 029/103] fixup! lavu: add RKMPP hwcontext

Enlarge the buffer size a little bit to fix a corner
case issue in RGA AFBC 8K cropping and MPP encoder.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index 092b868d523..18f0f82dd74 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -185,8 +185,8 @@ static AVBufferRef *rkmpp_drm_pool_alloc(void *opaque, size_t size)
     int i;
     const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(hwfc->sw_format);
     const int bits_pp = av_get_padded_bits_per_pixel(pixdesc);
-    const int aligned_w = FFALIGN(hwfc->width * 6 / 5,  64);
-    const int aligned_h = FFALIGN(hwfc->height * 6 / 5, 64);
+    const int aligned_w = FFALIGN(hwfc->width * 5 / 4,  64);
+    const int aligned_h = FFALIGN(hwfc->height * 5 / 4, 64);
 
     MppBuffer mpp_buf = NULL;
     size_t mpp_buf_size = aligned_w * aligned_h * bits_pp / 8;

From 4c1997e5a8d621b2d2b2dbc1eb4c8a4390c2b5bb Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 23 Jan 2024 02:01:16 +0800
Subject: [PATCH 030/103] lavf/rkrga: add `force_{yuv,chroma}` options for vpp
 filter

They are used to set the output to an uncompact and linear format while
maintaining the same chroma sub-sampling with the input. The user does
not have to know the input format in advance.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/vf_vpp_rkrga.c | 78 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 78 insertions(+)

diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
index c6ff6cc83e0..4b226f482c6 100644
--- a/libavfilter/vf_vpp_rkrga.c
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -44,6 +44,8 @@ typedef struct RGAVppContext {
     int transpose;
     int force_original_aspect_ratio;
     int force_divisible_by;
+    int force_yuv;
+    int force_chroma;
     int scheduler_core;
 
     int in_rotate_mode;
@@ -56,6 +58,22 @@ typedef struct RGAVppContext {
     int act_w, act_h;
 } RGAVppContext;
 
+enum {
+    FORCE_YUV_DISABLE,
+    FORCE_YUV_8BIT,
+    FORCE_YUV_10BIT,
+    FORCE_YUV_NB
+};
+
+enum {
+    FORCE_CHROMA_AUTO,
+    FORCE_CHROMA_420SP,
+    FORCE_CHROMA_420P,
+    FORCE_CHROMA_422SP,
+    FORCE_CHROMA_422P,
+    FORCE_CHROMA_NB
+};
+
 static const char *const var_names[] = {
     "iw", "in_w",
     "ih", "in_h",
@@ -261,6 +279,54 @@ static av_cold int set_size_info(AVFilterContext *ctx,
     return 0;
 }
 
+static av_cold void config_force_format(AVFilterContext *ctx,
+                                        enum AVPixelFormat in_format,
+                                        enum AVPixelFormat *out_format)
+{
+    RGAVppContext *r = ctx->priv;
+    const AVPixFmtDescriptor *desc;
+    int out_depth, force_chroma;
+    int is_yuv, is_fully_planar;
+
+    if (!out_format)
+        return;
+
+    out_depth = (r->force_yuv == FORCE_YUV_8BIT) ? 8 :
+                (r->force_yuv == FORCE_YUV_10BIT) ? 10 : 0;
+    if (!out_depth)
+        return;
+
+    desc = av_pix_fmt_desc_get(in_format);
+    is_yuv = !(desc->flags & AV_PIX_FMT_FLAG_RGB) && desc->nb_components >= 2;
+
+    force_chroma = r->force_chroma;
+    if (is_yuv && force_chroma == FORCE_CHROMA_AUTO) {
+        is_fully_planar = (desc->flags & AV_PIX_FMT_FLAG_PLANAR) &&
+                           desc->comp[1].plane != desc->comp[2].plane;
+        if (desc->log2_chroma_w == 1 && desc->log2_chroma_h == 1)
+            force_chroma = is_fully_planar ? FORCE_CHROMA_420P : FORCE_CHROMA_420SP;
+        else if (desc->log2_chroma_w == 1 && !desc->log2_chroma_h)
+            force_chroma = is_fully_planar ? FORCE_CHROMA_422P : FORCE_CHROMA_422SP;
+    }
+
+    switch (force_chroma) {
+    case FORCE_CHROMA_422P:
+        *out_format = AV_PIX_FMT_YUV422P;
+        break;
+    case FORCE_CHROMA_422SP:
+        *out_format = out_depth == 10 ?
+            AV_PIX_FMT_P210 : AV_PIX_FMT_NV16;
+        break;
+    case FORCE_CHROMA_420P:
+        *out_format = AV_PIX_FMT_YUV420P;
+        break;
+    case FORCE_CHROMA_420SP:
+    default:
+        *out_format = out_depth == 10 ?
+            AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;
+    }
+}
+
 static av_cold int rgavpp_config_props(AVFilterLink *outlink)
 {
     AVFilterContext *ctx = outlink->src;
@@ -280,6 +346,8 @@ static av_cold int rgavpp_config_props(AVFilterLink *outlink)
     in_format     = in_frames_ctx->sw_format;
     out_format    = (r->format == AV_PIX_FMT_NONE) ? in_format : r->format;
 
+    config_force_format(ctx, in_format, &out_format);
+
     ret = set_size_info(ctx, inlink, outlink);
     if (ret < 0)
         return ret;
@@ -371,6 +439,16 @@ static av_cold void rgavpp_uninit(AVFilterContext *ctx)
 #define FLAGS (AV_OPT_FLAG_FILTERING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
 
 #define RKRGA_VPP_COMMON_OPTS \
+    { "force_yuv",    "Enforce planar YUV format output", OFFSET(force_yuv), AV_OPT_TYPE_INT, { .i64 = FORCE_YUV_DISABLE }, 0, FORCE_YUV_NB - 1, FLAGS, "force_yuv" }, \
+        { "disable",  NULL,                     0, AV_OPT_TYPE_CONST, { .i64 = FORCE_YUV_DISABLE  }, 0, 0, FLAGS, "force_yuv" }, \
+        { "8bit",     "8-bit",                  0, AV_OPT_TYPE_CONST, { .i64 = FORCE_YUV_8BIT     }, 0, 0, FLAGS, "force_yuv" }, \
+        { "10bit",    "10-bit uncompact/8-bit", 0, AV_OPT_TYPE_CONST, { .i64 = FORCE_YUV_10BIT    }, 0, 0, FLAGS, "force_yuv" }, \
+    { "force_chroma", "Enforce chroma of planar YUV format output", OFFSET(force_chroma), AV_OPT_TYPE_INT, { .i64 = FORCE_CHROMA_AUTO }, 0, FORCE_CHROMA_NB - 1, FLAGS, "force_chroma" }, \
+        { "auto",     "Match in/out chroma",    0, AV_OPT_TYPE_CONST, { .i64 = FORCE_CHROMA_AUTO  }, 0, 0, FLAGS, "force_chroma" }, \
+        { "420sp",    "4:2:0 semi-planar",      0, AV_OPT_TYPE_CONST, { .i64 = FORCE_CHROMA_420SP }, 0, 0, FLAGS, "force_chroma" }, \
+        { "420p",     "4:2:0 fully-planar",     0, AV_OPT_TYPE_CONST, { .i64 = FORCE_CHROMA_420P  }, 0, 0, FLAGS, "force_chroma" }, \
+        { "422sp",    "4:2:2 semi-planar",      0, AV_OPT_TYPE_CONST, { .i64 = FORCE_CHROMA_422SP }, 0, 0, FLAGS, "force_chroma" }, \
+        { "422p",     "4:2:2 fully-planar",     0, AV_OPT_TYPE_CONST, { .i64 = FORCE_CHROMA_422P  }, 0, 0, FLAGS, "force_chroma" }, \
     { "core", "Set multicore RGA scheduler core [use with caution]", OFFSET(rga.scheduler_core), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, 0, INT_MAX, FLAGS, "core" }, \
         { "default",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, "core" }, \
         { "rga3_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE0 */ \

From 74050e5a857dfa1fc02ef5897c3fcfa8b3fb244a Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Wed, 24 Jan 2024 20:34:58 +0800
Subject: [PATCH 031/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

- Use crop_top to handle MPP decoder AFBC offset_y.
- Apply stride multiplier to drm_prime AFBC frame.

Co-authored-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 62 ++++++++++++++++++++++++++++++++++---------
 1 file changed, 49 insertions(+), 13 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 788c0c5c9ba..dec974f97ae 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -83,6 +83,30 @@ static uint32_t rkmpp_get_av_format(MppFrameFormat mpp_fmt)
     }
 }
 
+static int get_afbc_byte_stride(const AVPixFmtDescriptor *desc,
+                                int *stride, int reverse)
+{
+    if (!desc || !stride || *stride <= 0)
+        return AVERROR(EINVAL);
+
+    if (desc->nb_components == 1 ||
+        (desc->flags & AV_PIX_FMT_FLAG_RGB) ||
+        (!(desc->flags & AV_PIX_FMT_FLAG_RGB) &&
+         !(desc->flags & AV_PIX_FMT_FLAG_PLANAR)))
+        return 0;
+
+    if (desc->log2_chroma_w == 1 && desc->log2_chroma_h == 1)
+        *stride = reverse ? (*stride * 2 / 3) : (*stride * 3 / 2);
+    else if (desc->log2_chroma_w == 1 && !desc->log2_chroma_h)
+        *stride = reverse ? (*stride / 2) : (*stride * 2);
+    else if (!desc->log2_chroma_w && !desc->log2_chroma_h)
+        *stride = reverse ? (*stride / 3) : (*stride * 3);
+    else
+        return AVERROR(EINVAL);
+
+    return (*stride > 0) ? 0 : AVERROR(EINVAL);
+}
+
 static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
 {
     RKMPPDecContext *r = avctx->priv_data;
@@ -475,6 +499,7 @@ static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mp
     RKMPPDecContext *r = avctx->priv_data;
     AVRKMPPDRMFrameDescriptor *desc = NULL;
     AVDRMLayerDescriptor *layer = NULL;
+    const AVPixFmtDescriptor *pix_desc;
     MppBuffer mpp_buf = NULL;
     MppFrameFormat mpp_fmt = MPP_FMT_BUTT;
     int mpp_frame_mode = 0;
@@ -500,24 +525,35 @@ static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mp
     mpp_fmt = mpp_frame_get_fmt(mpp_frame);
     is_afbc = mpp_fmt & MPP_FRAME_FBC_MASK;
 
-    if (is_afbc)
+    desc->drm_desc.nb_layers = 1;
+    layer = &desc->drm_desc.layers[0];
+    layer->planes[0].object_index = 0;
+
+    if (is_afbc) {
         desc->drm_desc.objects[0].format_modifier =
             DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
 
-    desc->drm_desc.nb_layers = 1;
-    layer = &desc->drm_desc.layers[0];
-    layer->format = is_afbc ? rkmpp_get_drm_afbc_format(mpp_fmt)
-                            : rkmpp_get_drm_format(mpp_fmt);
+        layer->format = rkmpp_get_drm_afbc_format(mpp_fmt);
+        layer->nb_planes = 1;
+        layer->planes[0].offset = 0;
+        layer->planes[0].pitch  = mpp_frame_get_hor_stride(mpp_frame);
 
-    layer->nb_planes = is_afbc ? 1 : 2;
-    layer->planes[0].object_index = 0;
-    layer->planes[0].offset =
-        is_afbc ? mpp_frame_get_offset_y(mpp_frame) * mpp_frame_get_hor_stride(mpp_frame) : 0;
-    layer->planes[0].pitch = mpp_frame_get_hor_stride(mpp_frame);
+        pix_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);
+        if ((ret = get_afbc_byte_stride(pix_desc, (int *)&layer->planes[0].pitch, 0)) < 0)
+            return ret;
+
+        /* MPP specific AFBC src_y offset, not memory address offset */
+        frame->crop_top = mpp_frame_get_offset_y(mpp_frame);
+    } else {
+        layer->format = rkmpp_get_drm_format(mpp_fmt);
+        layer->nb_planes = 2;
+        layer->planes[0].offset = 0;
+        layer->planes[0].pitch  = mpp_frame_get_hor_stride(mpp_frame);
 
-    layer->planes[1].object_index = 0;
-    layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mpp_frame);
-    layer->planes[1].pitch = layer->planes[0].pitch;
+        layer->planes[1].object_index = 0;
+        layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mpp_frame);
+        layer->planes[1].pitch  = layer->planes[0].pitch;
+    }
 
     if ((ret = frame_create_buf(frame, mpp_frame, mpp_frame_get_buf_size(mpp_frame),
                                 rkmpp_free_mpp_frame, mpp_frame, AV_BUFFER_FLAG_READONLY)) < 0)

From 1cb7e3d2e26cde3c6eb91880cb6f9de095a81390 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Wed, 24 Jan 2024 20:17:51 +0800
Subject: [PATCH 032/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

- Use crop_top to handle MPP decoder AFBC offset_y.
- Apply stride multiplier to drm_prime AFBC frame.

Co-authored-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c | 118 ++++++++++++++++++++++++-------------
 1 file changed, 78 insertions(+), 40 deletions(-)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 6be7edd342b..f141da5b175 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -136,6 +136,16 @@ static int get_pixel_stride(const AVDRMObjectDescriptor *object,
     return (*ws > 0 && *hs > 0) ? 0 : AVERROR(EINVAL);
 }
 
+static int get_afbc_pixel_stride(float bytes_pp, int *stride, int reverse)
+{
+    if (!stride || *stride <= 0 || bytes_pp <= 0)
+        return AVERROR(EINVAL);
+
+    *stride = reverse ? (*stride / bytes_pp) : (*stride * bytes_pp);
+
+    return (*stride > 0) ? 0 : AVERROR(EINVAL);
+}
+
 /* Canonical formats: https://dri.freedesktop.org/docs/drm/gpu/afbc.html */
 static uint32_t get_drm_afbc_format(enum AVPixelFormat pix_fmt)
 {
@@ -353,12 +363,11 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
     RGAFrameInfo *in_info = &r->in_rga_frame_infos[nb_link];
     RGAFrameInfo *out_info = &r->out_rga_frame_info;
     int w_stride = 0, h_stride = 0;
-    int ret;
     const AVDRMFrameDescriptor *desc;
     const AVDRMLayerDescriptor *layer;
     const AVDRMPlaneDescriptor *plane0;
     RGAFrame **frame_list = NULL;
-    int is_afbc = 0;
+    int ret, is_afbc = 0;
 
     if (pat_preproc && !nb_link)
         return NULL;
@@ -382,13 +391,18 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
     if (desc->objects[0].fd < 0)
         return NULL;
 
-    ret = get_pixel_stride(&desc->objects[0],
-                           &desc->layers[0],
-                           (in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
-                           (in_info->pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
-                           in_info->bytes_pp, &w_stride, &h_stride);
-    if (ret < 0 || !w_stride || !h_stride)
-        return NULL;
+    is_afbc = drm_is_afbc(desc->objects[0].format_modifier);
+    if (!is_afbc) {
+        ret = get_pixel_stride(&desc->objects[0],
+                               &desc->layers[0],
+                               (in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
+                               (in_info->pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
+                               in_info->bytes_pp, &w_stride, &h_stride);
+        if (ret < 0 || !w_stride || !h_stride) {
+            av_log(ctx, AV_LOG_ERROR, "Failed to get frame strides\n");
+            return NULL;
+        }
+    }
 
     info.fd           = desc->objects[0].fd;
     info.format       = in_info->rga_fmt;
@@ -403,8 +417,6 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
         info.blend    = (do_overlay && !pat_preproc) ? in_info->blend_mode : 0;
     }
 
-    is_afbc = drm_is_afbc(desc->objects[0].format_modifier);
-
     if (is_afbc && (r->is_rga2_used || out_info->scheduler_core == 0x4)) {
         av_log(ctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported by RGA2\n",
                av_get_pix_fmt_name(in_info->pix_fmt));
@@ -416,7 +428,7 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
         out_info->scheduler_core == (out_info->scheduler_core & 0x3)) {
         if (!is_afbc && !is_pixel_stride_rga3_compat(w_stride, h_stride, in_info->rga_fmt)) {
             r->is_rga2_used = 1;
-            av_log(ctx, AV_LOG_WARNING, "Input pixel stride (%dx%d) format %s is not supported by RGA3\n",
+            av_log(ctx, AV_LOG_WARNING, "Input pixel stride (%dx%d) format '%s' is not supported by RGA3\n",
                    w_stride, h_stride, av_get_pix_fmt_name(in_info->pix_fmt));
         }
 
@@ -438,20 +450,25 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
                      in_info->act_w, in_info->act_h,
                      w_stride, h_stride, in_info->rga_fmt);
 
-    layer = &desc->layers[0];
-    plane0 = &layer->planes[0];
     if (is_afbc) {
         int afbc_offset_y = 0;
-        int hor_stride = plane0->pitch;
         uint32_t drm_afbc_fmt = get_drm_afbc_format(in_info->pix_fmt);
 
-        if (layer->planes[0].offset > 0) {
-            afbc_offset_y = layer->planes[0].offset / hor_stride;
+        if (rga_frame->frame->crop_top > 0) {
+            afbc_offset_y = rga_frame->frame->crop_top;
             info.rect.yoffset += afbc_offset_y;
         }
 
+        layer = &desc->layers[0];
+        plane0 = &layer->planes[0];
         if (drm_afbc_fmt == layer->format) {
-            info.rect.wstride = FFALIGN(inlink->w, RK_RGA_AFBC_STRIDE_ALIGN);
+            info.rect.wstride = plane0->pitch;
+            if ((ret = get_afbc_pixel_stride(in_info->bytes_pp, &info.rect.wstride, 1)) < 0)
+                return NULL;
+
+            if (info.rect.wstride % RK_RGA_AFBC_STRIDE_ALIGN)
+                info.rect.wstride = FFALIGN(inlink->w, RK_RGA_AFBC_STRIDE_ALIGN);
+
             info.rect.hstride = FFALIGN(inlink->h + afbc_offset_y, RK_RGA_AFBC_STRIDE_ALIGN);
         } else {
             av_log(ctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported\n",
@@ -473,7 +490,6 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
     AVFilterContext *ctx = outlink->src;
     AVFilterLink *inlink = ctx->inputs[0];
     RGAFrame        *out_frame;
-    int              ret;
     rga_info_t info = { .mmuFlag = 1, };
     RGAFrameInfo *in0_info = &r->in_rga_frame_infos[0];
     RGAFrameInfo *in1_info = ctx->nb_inputs > 1 ? &r->in_rga_frame_infos[1] : NULL;
@@ -483,6 +499,7 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
     AVDRMFrameDescriptor *desc;
     AVDRMLayerDescriptor *layer;
     RGAFrame **frame_list = NULL;
+    int ret, is_afbc = 0;
 
     if (!out_info || !hw_frame_ctx)
         return NULL;
@@ -503,6 +520,7 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
         av_log(ctx, AV_LOG_ERROR, "Failed to copy metadata fields from in to out: %d\n", ret);
         goto fail;
     }
+    out_frame->frame->crop_top = 0;
 
     if ((ret = av_hwframe_get_buffer(hw_frame_ctx, out_frame->frame, 0)) < 0) {
         av_log(ctx, AV_LOG_ERROR, "Cannot allocate an internal frame: %d\n", ret);
@@ -513,13 +531,28 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
     if (desc->objects[0].fd < 0)
         goto fail;
 
+    if (r->is_rga2_used || out_info->scheduler_core == 0x4) {
+        if (pat_preproc && (info.rect.width > 4096 || info.rect.height > 4096)) {
+            av_log(ctx, AV_LOG_ERROR, "Max supported output size of RGA2 is 4096x4096\n");
+            goto fail;
+        }
+        if (r->afbc_out && !pat_preproc) {
+            av_log(ctx, AV_LOG_WARNING, "Output format '%s' with AFBC modifier is not supported by RGA2\n",
+                   av_get_pix_fmt_name(out_info->pix_fmt));
+            r->afbc_out = 0;
+        }
+    }
+
+    is_afbc = r->afbc_out && !pat_preproc;
     ret = get_pixel_stride(&desc->objects[0],
                            &desc->layers[0],
                            (out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
                            (out_info->pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
                            out_info->bytes_pp, &w_stride, &h_stride);
-    if (ret < 0 || !w_stride || !h_stride)
+    if (!is_afbc && (ret < 0 || !w_stride || !h_stride)) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to get frame strides\n");
         goto fail;
+    }
 
     info.fd           = desc->objects[0].fd;
     info.format       = out_info->rga_fmt;
@@ -544,19 +577,7 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
                      out_info->act_w, out_info->act_h,
                      w_stride, h_stride, out_info->rga_fmt);
 
-    if (r->is_rga2_used || out_info->scheduler_core == 0x4) {
-        if (pat_preproc && (info.rect.width > 4096 || info.rect.height > 4096)) {
-            av_log(ctx, AV_LOG_ERROR, "Max supported output size of RGA2 is 4096x4096\n");
-            goto fail;
-        }
-        if (r->afbc_out && !pat_preproc) {
-            av_log(ctx, AV_LOG_WARNING, "Output format '%s' with AFBC modifier is not supported by RGA2\n",
-                   av_get_pix_fmt_name(out_info->pix_fmt));
-            r->afbc_out = 0;
-        }
-    }
-
-    if (r->afbc_out && !pat_preproc) {
+    if (is_afbc) {
         uint32_t drm_afbc_fmt = get_drm_afbc_format(out_info->pix_fmt);
 
         if (drm_afbc_fmt == DRM_FORMAT_INVALID) {
@@ -566,12 +587,16 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
             goto exit;
         }
 
-        desc->objects[0].format_modifier =
-            DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
+        w_stride = FFALIGN(pat_preproc ? inlink->w : outlink->w, RK_RGA_AFBC_STRIDE_ALIGN);
+        h_stride = FFALIGN(pat_preproc ? inlink->h : outlink->h, RK_RGA_AFBC_STRIDE_ALIGN);
 
-        layer = &desc->layers[0];
-        layer->nb_planes = 1;
-        layer->format = drm_afbc_fmt;
+        if ((info.rect.format == RK_FORMAT_YCbCr_420_SP_10B ||
+             info.rect.format == RK_FORMAT_YCbCr_422_SP_10B) && (w_stride % 64)) {
+            av_log(ctx, AV_LOG_WARNING, "Output pixel wstride '%d' format '%s' is not supported by RGA3 AFBC\n",
+                   w_stride, av_get_pix_fmt_name(out_info->pix_fmt));
+            r->afbc_out = 0;
+            goto exit;
+        }
 
         /* Inverted RGB/BGR order in FBCE */
         switch (info.rect.format) {
@@ -583,9 +608,22 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
             break;
         }
 
-        info.rect.wstride = FFALIGN(pat_preproc ? inlink->w : outlink->w, RK_RGA_AFBC_STRIDE_ALIGN);
-        info.rect.hstride = FFALIGN(pat_preproc ? inlink->h : outlink->h, RK_RGA_AFBC_STRIDE_ALIGN);
+        info.rect.wstride = w_stride;
+        info.rect.hstride = h_stride;
         info.rd_mode = 1 << 1; /* IM_FBC_MODE */
+
+        desc->objects[0].format_modifier =
+            DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
+
+        layer = &desc->layers[0];
+        layer->format = drm_afbc_fmt;
+        layer->nb_planes = 1;
+
+        layer->planes[0].offset = 0;
+        layer->planes[0].pitch  = info.rect.wstride;
+
+        if ((ret = get_afbc_pixel_stride(out_info->bytes_pp, (int *)&layer->planes[0].pitch, 0)) < 0)
+            goto fail;
     }
 
 exit:

From 1a9a9688100d17cc2363697f884833ec3b317c58 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Wed, 24 Jan 2024 20:18:19 +0800
Subject: [PATCH 033/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

- Use crop_top to handle MPP decoder AFBC offset_y.
- Apply stride multiplier to drm_prime AFBC frame.

Co-authored-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 130 ++++++++++++++++++++++++++++--------------
 1 file changed, 88 insertions(+), 42 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 62054ae0e9b..1688acc6cb1 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -95,6 +95,30 @@ static int get_byte_stride(const AVDRMObjectDescriptor *object,
     return (*hs > 0 && *vs > 0) ? 0 : AVERROR(EINVAL);
 }
 
+static int get_afbc_byte_stride(const AVPixFmtDescriptor *desc,
+                                int *stride, int reverse)
+{
+    if (!desc || !stride || *stride <= 0)
+        return AVERROR(EINVAL);
+
+    if (desc->nb_components == 1 ||
+        (desc->flags & AV_PIX_FMT_FLAG_RGB) ||
+        (!(desc->flags & AV_PIX_FMT_FLAG_RGB) &&
+         !(desc->flags & AV_PIX_FMT_FLAG_PLANAR)))
+        return 0;
+
+    if (desc->log2_chroma_w == 1 && desc->log2_chroma_h == 1)
+        *stride = reverse ? (*stride * 2 / 3) : (*stride * 3 / 2);
+    else if (desc->log2_chroma_w == 1 && !desc->log2_chroma_h)
+        *stride = reverse ? (*stride / 2) : (*stride * 2);
+    else if (!desc->log2_chroma_w && !desc->log2_chroma_h)
+        *stride = reverse ? (*stride / 3) : (*stride * 3);
+    else
+        return AVERROR(EINVAL);
+
+    return (*stride > 0) ? 0 : AVERROR(EINVAL);
+}
+
 static unsigned get_used_frame_count(MPPEncFrame *list)
 {
     unsigned count = 0;
@@ -190,7 +214,7 @@ static int rkmpp_set_enc_cfg_prep(AVCodecContext *avctx, AVFrame *frame)
     RKMPPEncContext *r = avctx->priv_data;
     MppEncCfg cfg = r->mcfg;
     MppFrameFormat mpp_fmt = r->mpp_fmt;
-    int ret;
+    int ret, is_afbc = 0;
     int hor_stride = 0, ver_stride = 0;
     const AVPixFmtDescriptor *pix_desc;
     const AVDRMFrameDescriptor *drm_desc;
@@ -206,25 +230,31 @@ static int rkmpp_set_enc_cfg_prep(AVCodecContext *avctx, AVFrame *frame)
         return AVERROR(ENOMEM);
 
     pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
-    ret = get_byte_stride(&drm_desc->objects[0],
-                          &drm_desc->layers[0],
-                          (pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
-                          (pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
-                          &hor_stride, &ver_stride);
-    if (ret < 0 || !hor_stride || !ver_stride)
-        return AVERROR(EINVAL);
+    is_afbc = drm_is_afbc(drm_desc->objects[0].format_modifier);
+    if (!is_afbc) {
+        ret = get_byte_stride(&drm_desc->objects[0],
+                              &drm_desc->layers[0],
+                              (pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
+                              (pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
+                              &hor_stride, &ver_stride);
+        if (ret < 0 || !hor_stride || !ver_stride) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get frame strides\n");
+            return AVERROR(EINVAL);
+        }
+
+        mpp_enc_cfg_set_s32(cfg, "prep:hor_stride", hor_stride);
+        mpp_enc_cfg_set_s32(cfg, "prep:ver_stride", ver_stride);
+    }
 
     mpp_enc_cfg_set_s32(cfg, "prep:width", avctx->width);
     mpp_enc_cfg_set_s32(cfg, "prep:height", avctx->height);
-    mpp_enc_cfg_set_s32(cfg, "prep:hor_stride", hor_stride);
-    mpp_enc_cfg_set_s32(cfg, "prep:ver_stride", ver_stride);
 
     mpp_enc_cfg_set_s32(cfg, "prep:colorspace", avctx->colorspace);
     mpp_enc_cfg_set_s32(cfg, "prep:colorprim", avctx->color_primaries);
     mpp_enc_cfg_set_s32(cfg, "prep:colortrc", avctx->color_trc);
     mpp_enc_cfg_set_s32(cfg, "prep:colorrange", avctx->color_range);
 
-    if (drm_is_afbc(drm_desc->objects[0].format_modifier)) {
+    if (is_afbc) {
         const AVDRMLayerDescriptor *layer = &drm_desc->layers[0];
         uint32_t drm_afbc_fmt = rkmpp_get_drm_afbc_format(mpp_fmt);
 
@@ -462,6 +492,8 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     MppBuffer mpp_buf = NULL;
     AVFrame *drm_frame = NULL;
     const AVDRMFrameDescriptor *drm_desc;
+    const AVDRMLayerDescriptor *layer;
+    const AVDRMPlaneDescriptor *plane0;
     const AVPixFmtDescriptor *pix_desc;
     int hor_stride = 0, ver_stride = 0;
     MppBufferInfo buf_info = { 0 };
@@ -515,10 +547,8 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     if (drm_desc->objects[0].fd < 0)
         goto exit;
 
-    is_afbc = drm_is_afbc(drm_desc->objects[0].format_modifier);
     if ((r->pix_fmt == AV_PIX_FMT_YUV420P ||
-         r->pix_fmt == AV_PIX_FMT_YUV422P ||
-         is_afbc) && (drm_frame->width % 2)) {
+         r->pix_fmt == AV_PIX_FMT_YUV422P) && (drm_frame->width % 2)) {
         av_log(avctx, AV_LOG_ERROR, "Unsupported width %d, not 2-aligned\n", drm_frame->width);
         goto exit;
     }
@@ -532,34 +562,11 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     mpp_frame_set_color_trc(mpp_frame, avctx->color_trc);
     mpp_frame_set_color_range(mpp_frame, avctx->color_range);
 
-    pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
-    ret = get_byte_stride(&drm_desc->objects[0],
-                          &drm_desc->layers[0],
-                          (pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
-                          (pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
-                          &hor_stride, &ver_stride);
-    if (ret < 0 || !hor_stride || !ver_stride)
-        goto exit;
-
-    mpp_frame_set_hor_stride(mpp_frame, hor_stride);
-    mpp_frame_set_ver_stride(mpp_frame, ver_stride);
-
-    buf_info.type  = MPP_BUFFER_TYPE_DRM;
-    buf_info.fd    = drm_desc->objects[0].fd;
-    buf_info.size  = drm_desc->objects[0].size;
-
-    /* mark buffer as used (idx >= 0) */
-    buf_info.index = buf_info.fd;
-
-    if ((ret = mpp_buffer_import(&mpp_buf, &buf_info)) != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to import MPP buffer: %d\n", ret);
-        goto exit;
-    }
-    mpp_frame_set_buffer(mpp_frame, mpp_buf);
-    mpp_frame_set_buf_size(mpp_frame, drm_desc->objects[0].size);
+    layer = &drm_desc->layers[0];
+    plane0 = &layer->planes[0];
 
+    is_afbc = drm_is_afbc(drm_desc->objects[0].format_modifier);
     if (is_afbc) {
-        const AVDRMLayerDescriptor *layer = &drm_desc->layers[0];
         uint32_t drm_afbc_fmt = rkmpp_get_drm_afbc_format(mpp_fmt);
         int afbc_offset_y = 0;
 
@@ -570,13 +577,52 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
         }
         mpp_fmt |= MPP_FRAME_FBC_AFBC_V2;
 
-        if (layer->planes[0].offset > 0) {
-            afbc_offset_y = layer->planes[0].offset / hor_stride;
+        if (drm_frame->crop_top > 0) {
+            afbc_offset_y = drm_frame->crop_top;
             mpp_frame_set_offset_y(mpp_frame, afbc_offset_y);
         }
     }
     mpp_frame_set_fmt(mpp_frame, mpp_fmt);
 
+    pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
+    if (is_afbc) {
+        hor_stride = plane0->pitch;
+        if ((ret = get_afbc_byte_stride(pix_desc, &hor_stride, 1)) < 0)
+            goto exit;
+
+        if (hor_stride % 16)
+            hor_stride = FFALIGN(avctx->width, 16);
+
+        mpp_frame_set_fbc_hdr_stride(mpp_frame, hor_stride);
+    } else {
+        ret = get_byte_stride(&drm_desc->objects[0],
+                              &drm_desc->layers[0],
+                              (pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
+                              (pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR),
+                              &hor_stride, &ver_stride);
+        if (ret < 0 || !hor_stride || !ver_stride) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get frame strides\n");
+            goto exit;
+        }
+
+        mpp_frame_set_hor_stride(mpp_frame, hor_stride);
+        mpp_frame_set_ver_stride(mpp_frame, ver_stride);
+    }
+
+    buf_info.type  = MPP_BUFFER_TYPE_DRM;
+    buf_info.fd    = drm_desc->objects[0].fd;
+    buf_info.size  = drm_desc->objects[0].size;
+
+    /* mark buffer as used (idx >= 0) */
+    buf_info.index = buf_info.fd;
+
+    if ((ret = mpp_buffer_import(&mpp_buf, &buf_info)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to import MPP buffer: %d\n", ret);
+        goto exit;
+    }
+    mpp_frame_set_buffer(mpp_frame, mpp_buf);
+    mpp_frame_set_buf_size(mpp_frame, drm_desc->objects[0].size);
+
     return mpp_enc_frame;
 
 exit:

From 99ea69d6d40846684f712e4257fa35f9120ae2ae Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Sun, 28 Jan 2024 01:10:45 +0800
Subject: [PATCH 034/103] lavc/rkmppdec: allow to set decoder options from env

This allows decoder options to be overriden via env FFMPEG_RKMPP_DEC_OPT
where the client has not support to change the decoder options.
Additionally AVOptions are printed as VERBOSE on infochange.
---
 libavcodec/rkmppdec.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index dec974f97ae..c830218b714 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -140,11 +140,16 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
 {
     RKMPPDecContext *r = avctx->priv_data;
     MppCodingType coding_type = MPP_VIDEO_CodingUnused;
+    const char *opts_env = NULL;
     int ret, is_fmt_supported = 0;
     enum AVPixelFormat pix_fmts[3] = { AV_PIX_FMT_DRM_PRIME,
                                        AV_PIX_FMT_NV12,
                                        AV_PIX_FMT_NONE };
 
+    opts_env = getenv("FFMPEG_RKMPP_DEC_OPT");
+    if (opts_env && av_set_options_string(r, opts_env, "=", " ") <= 0)
+        av_log(avctx, AV_LOG_WARNING, "Unable to set decoder options from env\n");
+
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
     case AV_PIX_FMT_YUVJ420P:
@@ -676,6 +681,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     }
 
     if (r->info_change = mpp_frame_get_info_change(mpp_frame)) {
+        char *opts = NULL;
         int fast_parse = r->fast_parse;
         int mpp_frame_mode = mpp_frame_get_mode(mpp_frame);
         const MppFrameFormat mpp_fmt = mpp_frame_get_fmt(mpp_frame);
@@ -685,8 +691,10 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 
         av_log(avctx, AV_LOG_VERBOSE, "Noticed an info change\n");
 
-        if (r->afbc && !(mpp_fmt & MPP_FRAME_FBC_MASK))
+        if (r->afbc && !(mpp_fmt & MPP_FRAME_FBC_MASK)) {
             av_log(avctx, AV_LOG_VERBOSE, "AFBC is requested but not supported\n");
+            r->afbc = 0;
+        }
 
         pix_fmts[1] = rkmpp_get_av_format(mpp_fmt & MPP_FRAME_FMT_MASK);
 
@@ -704,6 +712,9 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         avctx->coded_height = FFALIGN(avctx->height, 64);
         rkmpp_export_avctx_color_props(avctx, mpp_frame);
 
+        if (av_opt_serialize(r, 0, 0, &opts, '=', ' ') >= 0)
+            av_log(avctx, AV_LOG_VERBOSE, "Decoder options: %s\n", opts);
+
         av_log(avctx, AV_LOG_VERBOSE, "Configured with size: %dx%d | pix_fmt: %s | sw_pix_fmt: %s\n",
                avctx->width, avctx->height,
                av_get_pix_fmt_name(avctx->pix_fmt),

From 28b4194646594a46b6fce3bd3f05398ec2a82229 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Sun, 28 Jan 2024 22:09:20 +0800
Subject: [PATCH 035/103] lavf/rkrga: add force_yuv=auto option for auto
 un-compact

---
 libavfilter/vf_vpp_rkrga.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
index 4b226f482c6..ba34b679046 100644
--- a/libavfilter/vf_vpp_rkrga.c
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -60,6 +60,7 @@ typedef struct RGAVppContext {
 
 enum {
     FORCE_YUV_DISABLE,
+    FORCE_YUV_AUTO,
     FORCE_YUV_8BIT,
     FORCE_YUV_10BIT,
     FORCE_YUV_NB
@@ -291,8 +292,12 @@ static av_cold void config_force_format(AVFilterContext *ctx,
     if (!out_format)
         return;
 
-    out_depth = (r->force_yuv == FORCE_YUV_8BIT) ? 8 :
-                (r->force_yuv == FORCE_YUV_10BIT) ? 10 : 0;
+    if (r->force_yuv == FORCE_YUV_AUTO)
+        out_depth = (in_format == AV_PIX_FMT_NV15 ||
+                     in_format == AV_PIX_FMT_NV20) ? 10 : 0;
+    else
+        out_depth = (r->force_yuv == FORCE_YUV_8BIT) ? 8 :
+                    (r->force_yuv == FORCE_YUV_10BIT) ? 10 : 0;
     if (!out_depth)
         return;
 
@@ -441,6 +446,7 @@ static av_cold void rgavpp_uninit(AVFilterContext *ctx)
 #define RKRGA_VPP_COMMON_OPTS \
     { "force_yuv",    "Enforce planar YUV format output", OFFSET(force_yuv), AV_OPT_TYPE_INT, { .i64 = FORCE_YUV_DISABLE }, 0, FORCE_YUV_NB - 1, FLAGS, "force_yuv" }, \
         { "disable",  NULL,                     0, AV_OPT_TYPE_CONST, { .i64 = FORCE_YUV_DISABLE  }, 0, 0, FLAGS, "force_yuv" }, \
+        { "auto",     "Match in/out bit depth", 0, AV_OPT_TYPE_CONST, { .i64 = FORCE_YUV_AUTO     }, 0, 0, FLAGS, "force_yuv" }, \
         { "8bit",     "8-bit",                  0, AV_OPT_TYPE_CONST, { .i64 = FORCE_YUV_8BIT     }, 0, 0, FLAGS, "force_yuv" }, \
         { "10bit",    "10-bit uncompact/8-bit", 0, AV_OPT_TYPE_CONST, { .i64 = FORCE_YUV_10BIT    }, 0, 0, FLAGS, "force_yuv" }, \
     { "force_chroma", "Enforce chroma of planar YUV format output", OFFSET(force_chroma), AV_OPT_TYPE_INT, { .i64 = FORCE_CHROMA_AUTO }, 0, FORCE_CHROMA_NB - 1, FLAGS, "force_chroma" }, \

From 6b13265d705dd6c2ae751ef0f845d12d9d72a9c6 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 5 Feb 2024 00:31:57 +0800
Subject: [PATCH 036/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

EOS frame may contain valid data. Check frame buf to determine it.

```
[hevc_rkmpp @ 0xaaab1462eb20] Received a 'EOS' frame
[hevc_rkmpp @ 0xaaab1462eb20] Received a frame
[hevc_rkmpp @ 0xaaab1462eb20] Received a 'EOS' frame
[hevc_rkmpp @ 0xaaab1462eb20] Decoder is at EOF
[vist#0:0/hevc @ 0xaaab1463e380] Decoder returned EOF, finishing
[vist#0:0/hevc @ 0xaaab1463e380] Terminating decoder thread
```

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 10 ++++++----
 libavcodec/rkmppdec.h |  2 --
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index c830218b714..dae44efc122 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -665,9 +665,12 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     }
     if (mpp_frame_get_eos(mpp_frame)) {
         av_log(avctx, AV_LOG_DEBUG, "Received a 'EOS' frame\n");
-        r->eof = 1;
-        ret = AVERROR_EOF;
-        goto exit;
+        /* EOS frame may contain valid data */
+        if (!mpp_frame_get_buffer(mpp_frame)) {
+            r->eof = 1;
+            ret = AVERROR_EOF;
+            goto exit;
+        }
     }
     if (mpp_frame_get_discard(mpp_frame)) {
         av_log(avctx, AV_LOG_DEBUG, "Received a 'discard' frame\n");
@@ -929,7 +932,6 @@ static void rkmpp_decode_flush(AVCodecContext *avctx)
         r->queue_size = 0;
 
         av_packet_unref(&r->last_pkt);
-        av_frame_unref(&r->last_frame);
     } else
         av_log(avctx, AV_LOG_ERROR, "Failed to reset MPP context: %d\n", ret);
 }
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index f2749f21f8f..6a4cd6bf68b 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -54,8 +54,6 @@ typedef struct RKMPPDecContext {
     AVBufferRef   *hwframe;
 
     AVPacket       last_pkt;
-    AVFrame        last_frame;
-
     int            eof;
     int            info_change;
     int            errinfo_cnt;

From 377fa2c622836cbdd65ef1af8c0c76c9ba01b097 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 29 Feb 2024 16:55:39 +0800
Subject: [PATCH 037/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

Drain the fifo during filter reset to avoid leaking one fence_fd.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index f141da5b175..72dbe8c29f4 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -1048,10 +1048,25 @@ static void set_rga_async_frame_lock_status(RGAAsyncFrame *frame, int lock)
         frame->pat->locked = status;
 }
 
+static void rga_drain_fifo(RKRGAContext *r)
+{
+    RGAAsyncFrame aframe;
+
+    while (r->async_fifo && av_fifo_read(r->async_fifo, &aframe, 1) >= 0) {
+        if (imsync(aframe.dst->info.out_fence_fd) != IM_STATUS_SUCCESS)
+            av_log(NULL, AV_LOG_WARNING, "RGA sync failed\n");
+
+        set_rga_async_frame_lock_status(&aframe, 0);
+    }
+}
+
 av_cold int ff_rkrga_close(AVFilterContext *avctx)
 {
     RKRGAContext *r = avctx->priv;
 
+    /* Drain the fifo during filter reset */
+    rga_drain_fifo(r);
+
     clear_frame_list(&r->src_frame_list);
     clear_frame_list(&r->dst_frame_list);
     clear_frame_list(&r->pat_frame_list);

From 97638cffe1bf3005d4d4c07c8edaf34098054a21 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 29 Feb 2024 22:49:05 +0800
Subject: [PATCH 038/103] fixup! lavf/rkrga: add `force_{yuv,chroma}` options
 for vpp filter

Auto fallback to 8-bit formats on RGA2 hardware.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/vf_vpp_rkrga.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
index ba34b679046..e2cf62aa4f3 100644
--- a/libavfilter/vf_vpp_rkrga.c
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -286,6 +286,8 @@ static av_cold void config_force_format(AVFilterContext *ctx,
 {
     RGAVppContext *r = ctx->priv;
     const AVPixFmtDescriptor *desc;
+    const char *rga_ver = NULL;
+    int has_rga3 = 0;
     int out_depth, force_chroma;
     int is_yuv, is_fully_planar;
 
@@ -298,6 +300,13 @@ static av_cold void config_force_format(AVFilterContext *ctx,
     else
         out_depth = (r->force_yuv == FORCE_YUV_8BIT) ? 8 :
                     (r->force_yuv == FORCE_YUV_10BIT) ? 10 : 0;
+
+    /* Auto fallback to 8-bit fmts on RGA2 */
+    rga_ver = querystring(RGA_VERSION);
+    has_rga3 = !!strstr(rga_ver, "RGA_3");
+    if (out_depth >= 10 && !has_rga3)
+        out_depth = 8;
+
     if (!out_depth)
         return;
 

From d43f4f54e6c732cd47d5e1ab69b600afd8966897 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 29 Feb 2024 23:19:02 +0800
Subject: [PATCH 039/103] fixup! lavf/rkrga: add `force_{yuv,chroma}` options
 for vpp filter

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/vf_vpp_rkrga.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
index e2cf62aa4f3..3aa9285d5b8 100644
--- a/libavfilter/vf_vpp_rkrga.c
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -301,15 +301,15 @@ static av_cold void config_force_format(AVFilterContext *ctx,
         out_depth = (r->force_yuv == FORCE_YUV_8BIT) ? 8 :
                     (r->force_yuv == FORCE_YUV_10BIT) ? 10 : 0;
 
+    if (!out_depth)
+        return;
+
     /* Auto fallback to 8-bit fmts on RGA2 */
     rga_ver = querystring(RGA_VERSION);
     has_rga3 = !!strstr(rga_ver, "RGA_3");
     if (out_depth >= 10 && !has_rga3)
         out_depth = 8;
 
-    if (!out_depth)
-        return;
-
     desc = av_pix_fmt_desc_get(in_format);
     is_yuv = !(desc->flags & AV_PIX_FMT_FLAG_RGB) && desc->nb_components >= 2;
 

From 27136b05e0742450a019d6bab80d840ac5fd6421 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 9 Mar 2024 21:24:37 +0800
Subject: [PATCH 040/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

fix the draining/eof prematurely.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/vf_overlay_rkrga.c | 13 +++++++++----
 libavfilter/vf_vpp_rkrga.c     | 22 +++++++++++++++-------
 2 files changed, 24 insertions(+), 11 deletions(-)

diff --git a/libavfilter/vf_overlay_rkrga.c b/libavfilter/vf_overlay_rkrga.c
index 03803523c78..18d0ff70b0c 100644
--- a/libavfilter/vf_overlay_rkrga.c
+++ b/libavfilter/vf_overlay_rkrga.c
@@ -270,6 +270,7 @@ static int rgaoverlay_activate(AVFilterContext *ctx)
     AVFilterLink *inlink_overlay = ctx->inputs[1];
     AVFilterLink *outlink        = ctx->outputs[0];
     int i, ret;
+    int64_t pts = AV_NOPTS_VALUE;
 
     ret = ff_framesync_activate(&r->fs);
     if (ret < 0)
@@ -277,18 +278,20 @@ static int rgaoverlay_activate(AVFilterContext *ctx)
 
     if (r->fs.eof) {
         r->rga.eof = 1;
+        pts = r->fs.pts;
         goto eof;
     }
 
-    if (!r->rga.got_frame) {
+    if (r->rga.got_frame)
+        r->rga.got_frame = 0;
+    else {
         for (i = 0; i < ctx->nb_inputs; i++) {
             if (!ff_inlink_check_available_frame(ctx->inputs[i])) {
                 FF_FILTER_FORWARD_WANTED(outlink, ctx->inputs[i]);
             }
         }
         return FFERROR_NOT_READY;
-    } else
-        r->rga.got_frame = 0;
+    }
 
     return 0;
 
@@ -296,7 +299,9 @@ static int rgaoverlay_activate(AVFilterContext *ctx)
     ff_rkrga_filter_frame(&r->rga,
                           inlink_main, NULL,
                           inlink_overlay, NULL);
-    ff_outlink_set_status(outlink, AVERROR_EOF, AV_NOPTS_VALUE);
+
+    pts = av_rescale_q(pts, inlink_main->time_base, outlink->time_base);
+    ff_outlink_set_status(outlink, AVERROR_EOF, pts);
     return 0;
 }
 
diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
index 3aa9285d5b8..9b39efb1c77 100644
--- a/libavfilter/vf_vpp_rkrga.c
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -392,24 +392,26 @@ static int rgavpp_activate(AVFilterContext *ctx)
     AVFilterLink *outlink = ctx->outputs[0];
     RGAVppContext      *r = ctx->priv;
     AVFrame *in = NULL;
-    int ret, status = 0;
+    int ret, at_eof = 0, status = 0;
     int64_t pts = AV_NOPTS_VALUE;
 
     FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);
 
-    if (!r->rga.eof) {
+    if (r->rga.eof)
+        at_eof = 1;
+    else {
         ret = ff_inlink_consume_frame(inlink, &in);
         if (ret < 0)
             return ret;
 
         if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {
             if (status == AVERROR_EOF) {
-                r->rga.eof = 1;
+                at_eof = 1;
             }
         }
     }
 
-    if (in || r->rga.eof) {
+    if (in) {
         ret = ff_rkrga_filter_frame(&r->rga, inlink, in, NULL, NULL);
         av_frame_free(&in);
         if (ret < 0)
@@ -417,8 +419,10 @@ static int rgavpp_activate(AVFilterContext *ctx)
         else if (!r->rga.got_frame)
             goto not_ready;
 
-        if (r->rga.eof)
+        if (at_eof) {
+            r->rga.eof = 1;
             goto eof;
+        }
 
         if (r->rga.got_frame) {
             r->rga.got_frame = 0;
@@ -427,15 +431,19 @@ static int rgavpp_activate(AVFilterContext *ctx)
     }
 
 not_ready:
-    if (r->rga.eof)
+    if (at_eof) {
+        r->rga.eof = 1;
         goto eof;
+    }
 
     FF_FILTER_FORWARD_WANTED(outlink, inlink);
     return FFERROR_NOT_READY;
 
 eof:
+    ff_rkrga_filter_frame(&r->rga, inlink, NULL, NULL, NULL);
+
     pts = av_rescale_q(pts, inlink->time_base, outlink->time_base);
-    ff_outlink_set_status(outlink, status, pts);
+    ff_outlink_set_status(outlink, AVERROR_EOF, pts);
     return 0;
 }
 

From 7a0200bdfa45d5a3396bf914cdd90bde9ff50696 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sun, 10 Mar 2024 23:59:00 +0800
Subject: [PATCH 041/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

Don't return EAGAIN in draining/eof to avoid a potential frame loss.

Credit by @mcerveny

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 1688acc6cb1..afbb59fbdd0 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -774,6 +774,8 @@ static int rkmpp_encode_frame(AVCodecContext *avctx, AVPacket *packet,
 
 get:
     ret = rkmpp_get_packet(avctx, packet);
+    if (!frame && ret == AVERROR(EAGAIN))
+        goto send;
     if (ret == AVERROR_EOF ||
         ret == AVERROR(EAGAIN))
         *got_packet = 0;

From c7de8d3827da61474ea652eb1687c12509f26403 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 13 Mar 2024 15:28:23 +0800
Subject: [PATCH 042/103] lavc/rkmppenc: add profile tier option to HEVC
 encoder

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 6 ++++++
 libavcodec/rkmppenc.h | 5 +++++
 2 files changed, 11 insertions(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index afbb59fbdd0..62cf63280e7 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -308,9 +308,11 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
 
     mpp_enc_cfg_set_s32(cfg, "rc:fps_in_flex", 0);
     mpp_enc_cfg_set_s32(cfg, "rc:fps_in_num", fps_num);
+    mpp_enc_cfg_set_s32(cfg, "rc:fps_in_denom", fps_den);
     mpp_enc_cfg_set_s32(cfg, "rc:fps_in_denorm", fps_den);
     mpp_enc_cfg_set_s32(cfg, "rc:fps_out_flex", 0);
     mpp_enc_cfg_set_s32(cfg, "rc:fps_out_num",fps_num);
+    mpp_enc_cfg_set_s32(cfg, "rc:fps_out_denom", fps_den);
     mpp_enc_cfg_set_s32(cfg, "rc:fps_out_denorm", fps_den);
 
     mpp_enc_cfg_set_s32(cfg, "rc:gop", FFMAX(avctx->gop_size, 1));
@@ -448,6 +450,10 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
             avctx->level = r->level;
             mpp_enc_cfg_set_s32(cfg, "h265:profile", avctx->profile);
             mpp_enc_cfg_set_s32(cfg, "h265:level", avctx->level);
+            if (avctx->level >= 120) {
+                mpp_enc_cfg_set_s32(cfg, "h265:tier", r->tier);
+                av_log(avctx, AV_LOG_VERBOSE, "Tier is set to %d\n", r->tier);
+            }
 
             switch (avctx->profile) {
             case AV_PROFILE_HEVC_MAIN:
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index 0851054ddd4..3ad8662b3ea 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -72,6 +72,7 @@ typedef struct RKMPPEncContext {
     int                qp_min_i;
     int                surfaces;
     int                profile;
+    int                tier;
     int                level;
     int                coder;
     int                dct8x8;
@@ -150,6 +151,10 @@ static const AVOption hevc_options[] = {
     { "profile", "Set the encoding profile restriction", OFFSET(profile), AV_OPT_TYPE_INT,
             { .i64 = AV_PROFILE_HEVC_MAIN }, -1, AV_PROFILE_HEVC_MAIN, VE, "profile" },
         { "main",       NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_PROFILE_HEVC_MAIN }, INT_MIN, INT_MAX, VE, "profile" },
+    { "tier", "Set the encoding profile tier restriction", OFFSET(tier), AV_OPT_TYPE_INT,
+            { .i64 = 1 }, 0, 1, VE, "tier" },
+        { "main",       NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, INT_MIN, INT_MAX, VE, "tier" },
+        { "high",       NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, INT_MIN, INT_MAX, VE, "tier" },
     { "level", "Set the encoding level restriction", OFFSET(level), AV_OPT_TYPE_INT,
             { .i64 = 0 }, FF_LEVEL_UNKNOWN, 186, VE, "level" },
         { "1",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 30 }, 0, 0, VE, "level" },

From 76203202f6f509e23bf8249d4f78802cabb9ea0d Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 13 Mar 2024 21:45:36 +0800
Subject: [PATCH 043/103] lavc/rkmppenc: add low_delay flag support for RKMPP
 encoders

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 14 ++++++++++----
 libavcodec/rkmppenc.h |  6 ++----
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 62cf63280e7..bc1471f2e53 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -681,7 +681,7 @@ static void rkmpp_free_packet_buf(void *opaque, uint8_t *data)
     mpp_packet_deinit(&mpp_pkt);
 }
 
-static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet)
+static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout)
 {
     RKMPPEncContext *r = avctx->priv_data;
     MppPacket mpp_pkt = NULL;
@@ -690,6 +690,11 @@ static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet)
     MppBuffer mpp_buf = NULL;
     int ret, key_frame = 0;
 
+    if ((ret = r->mapi->control(r->mctx, MPP_SET_OUTPUT_TIMEOUT, (MppParam)&timeout)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set output timeout: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
     if ((ret = r->mapi->encode_get_packet(r->mctx, &mpp_pkt)) != MPP_OK) {
         int log_level = (ret == MPP_NOK) ? AV_LOG_DEBUG : AV_LOG_ERROR;
         ret = (ret == MPP_NOK) ? AVERROR(EAGAIN) : AVERROR_EXTERNAL;
@@ -759,10 +764,11 @@ static int rkmpp_encode_frame(AVCodecContext *avctx, AVPacket *packet,
 {
     RKMPPEncContext *r = avctx->priv_data;
     MPPEncFrame *mpp_enc_frame = NULL;
-    int surfaces = r->surfaces;
     int ret;
+    int timeout = (avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
+                  ? MPP_TIMEOUT_BLOCK : MPP_TIMEOUT_NON_BLOCK;
 
-    if (get_used_frame_count(r->frame_list) > surfaces)
+    if (get_used_frame_count(r->frame_list) > H26X_ASYNC_FRAMES)
         goto get;
 
     mpp_enc_frame = rkmpp_submit_frame(avctx, (AVFrame *)frame);
@@ -779,7 +785,7 @@ static int rkmpp_encode_frame(AVCodecContext *avctx, AVPacket *packet,
         return ret;
 
 get:
-    ret = rkmpp_get_packet(avctx, packet);
+    ret = rkmpp_get_packet(avctx, packet, timeout);
     if (!frame && ret == AVERROR(EAGAIN))
         goto send;
     if (ret == AVERROR_EOF ||
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index 3ad8662b3ea..e34c227b306 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -38,7 +38,8 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 
-#define H26X_HEADER_SIZE 1024
+#define H26X_HEADER_SIZE  1024
+#define H26X_ASYNC_FRAMES 4
 #define ALIGN_DOWN(a, b) ((a) & ~((b)-1))
 
 typedef struct MPPEncFrame {
@@ -70,7 +71,6 @@ typedef struct RKMPPEncContext {
     int                qp_min;
     int                qp_max_i;
     int                qp_min_i;
-    int                surfaces;
     int                profile;
     int                tier;
     int                level;
@@ -106,8 +106,6 @@ static const AVRational mpp_tb = { 1, 1000000 };
             { .i64 = -1 }, -1, 51, VE, "qp_max_i" }, \
     { "qp_min_i", "Set the min QP value for I frame", OFFSET(qp_min_i), AV_OPT_TYPE_INT, \
             { .i64 = -1 }, -1, 51, VE, "qp_min_i" }, \
-    { "surfaces", "Set the maximum surfaces to be used for encoding", OFFSET(surfaces), AV_OPT_TYPE_INT, \
-            { .i64 = 4 }, 1, 16, VE, "surfaces" },
 
 static const AVOption h264_options[] = {
     RKMPP_ENC_COMMON_OPTS

From 1fa586ac7fa224bde0100def5e5f3406f6c2e663 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 13 Mar 2024 22:46:11 +0800
Subject: [PATCH 044/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

Switch the decoder logic to the lower latency one. This results
in slightly higher CPU usage in exchange for low latency and
better compatibility.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 120 +++++++++++++++++++++---------------------
 libavcodec/rkmppdec.h |   4 +-
 2 files changed, 61 insertions(+), 63 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index dae44efc122..200208688a7 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -112,10 +112,9 @@ static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
     RKMPPDecContext *r = avctx->priv_data;
 
     r->eof = 0;
+    r->draining = 0;
     r->info_change = 0;
     r->errinfo_cnt = 0;
-    r->queue_cnt = 0;
-    r->queue_size = 0;
 
     if (r->mapi) {
         r->mapi->reset(r->mctx);
@@ -649,6 +648,10 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     MppFrame mpp_frame = NULL;
     int ret;
 
+    /* should not provide any frame after EOS */
+    if (r->eof)
+        return AVERROR_EOF;
+
     if ((ret = r->mapi->control(r->mctx, MPP_SET_OUTPUT_TIMEOUT, (MppParam)&timeout)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to set output timeout: %d\n", ret);
         return AVERROR_EXTERNAL;
@@ -660,7 +663,8 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         return AVERROR_EXTERNAL;
     }
     if (!mpp_frame) {
-        av_log(avctx, AV_LOG_DEBUG, "Timeout getting decoded frame\n");
+        if (timeout != MPP_TIMEOUT_NON_BLOCK)
+            av_log(avctx, AV_LOG_DEBUG, "Timeout getting decoded frame\n");
         return AVERROR(EAGAIN);
     }
     if (mpp_frame_get_eos(mpp_frame)) {
@@ -819,6 +823,8 @@ static int rkmpp_send_eos(AVCodecContext *avctx)
         ret = r->mapi->decode_put_packet(r->mctx, mpp_pkt);
     } while (ret != MPP_OK);
 
+    r->draining = 1;
+
     mpp_packet_deinit(&mpp_pkt);
     return 0;
 }
@@ -830,6 +836,10 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
     int64_t pts = PTS_TO_MPP_PTS(pkt->pts, avctx->pkt_timebase);
     int ret;
 
+    /* avoid sending new data after EOS */
+    if (r->draining)
+        return AVERROR(EOF);
+
     if ((ret = mpp_packet_init(&mpp_pkt, pkt->data, pkt->size)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to init packet: %d\n", ret);
         return AVERROR_EXTERNAL;
@@ -849,72 +859,63 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
 
 static int rkmpp_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 {
-    AVCodecInternal *avci = avctx->internal;
     RKMPPDecContext *r = avctx->priv_data;
     AVPacket *pkt = &r->last_pkt;
-    int retry_cnt = 0;
-    int ret_send, ret_get;
+    int ret;
 
     if (r->info_change && !r->buf_group)
         return AVERROR_EOF;
 
-    if (!avci->draining) {
+    /* no more frames after EOS */
+    if (r->eof)
+        return AVERROR_EOF;
+
+    /* drain remain frames */
+    if (r->draining) {
+        ret = rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+        goto exit;
+    }
+
+    while (1) {
         if (!pkt->size) {
-            switch (ff_decode_get_packet(avctx, pkt)) {
-            case AVERROR_EOF:
-                av_log(avctx, AV_LOG_DEBUG, "Decoder draining\n");
-                ret_send = rkmpp_send_eos(avctx);
-                if (ret_send < 0)
-                    return ret_send;
-                goto get_frame;
-            case AVERROR(EAGAIN):
-                av_log(avctx, AV_LOG_TRACE, "Decoder could not get packet, retrying\n");
-                return AVERROR(EAGAIN);
+            ret = ff_decode_get_packet(avctx, pkt);
+            if (ret == AVERROR_EOF) {
+                av_log(avctx, AV_LOG_DEBUG, "Decoder is at EOF\n");
+                /* send EOS and start draining */
+                rkmpp_send_eos(avctx);
+                ret = rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+                goto exit;
+            } else if (ret == AVERROR(EAGAIN)) {
+                /* not blocking so that we can feed data ASAP */
+                ret = rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_NON_BLOCK);
+                goto exit;
+            } else if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Decoder failed to get packet: %d\n", ret);
+                goto exit;
+            }
+        } else {
+            /* send pending data to decoder */
+            ret = rkmpp_send_packet(avctx, pkt);
+            if (ret == AVERROR(EAGAIN)) {
+                /* some streams might need more packets to start returning frames */
+                ret = rkmpp_get_frame(avctx, frame, 100);
+                if (ret != AVERROR(EAGAIN))
+                    goto exit;
+            } else if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Decoder failed to send packet: %d\n", ret);
+                goto exit;
+            } else {
+                av_packet_unref(pkt);
+                pkt->size = 0;
             }
         }
-send_pkt:
-        /* there is definitely a packet to send to decoder */
-        ret_send = rkmpp_send_packet(avctx, pkt);
-        if (ret_send == 0) {
-            /* send successful, continue until decoder input buffer is full */
-            av_packet_unref(pkt);
-            r->queue_cnt++;
-            if (r->queue_size <= 0 ||
-                r->queue_cnt < r->queue_size)
-                return AVERROR(EAGAIN);
-        } else if (ret_send < 0 && ret_send != AVERROR(EAGAIN)) {
-            /* something went wrong, raise error */
-            av_log(avctx, AV_LOG_ERROR, "Decoder failed to send data: %d", ret_send);
-            return ret_send;
-        } else
-            /* input buffer is full, estimate queue size */
-            r->queue_size = FFMAX(r->queue_cnt, r->queue_size);
     }
 
-    if (r->eof)
-        return AVERROR_EOF;
-
-get_frame:
-    /* were here only when draining and buffer is full */
-    ret_get = rkmpp_get_frame(avctx, frame, 100);
-    if (ret_get == AVERROR_EOF)
-        av_log(avctx, AV_LOG_DEBUG, "Decoder is at EOF\n");
-    /* EAGAIN should never happen during draining */
-    else if (avci->draining && ret_get == AVERROR(EAGAIN)) {
-        if (retry_cnt++ < MAX_RETRY_COUNT)
-            goto get_frame;
-        else
-            ret_get = AVERROR_BUG;
-    }
-    /* this is not likely but lets handle it in case synchronization issues of MPP */
-    else if (ret_get == AVERROR(EAGAIN) && ret_send == AVERROR(EAGAIN))
-        goto send_pkt;
-    else if (ret_get < 0 && ret_get != AVERROR(EAGAIN))
-        av_log(avctx, AV_LOG_ERROR, "Decoder failed to get frame: %d\n", ret_get);
-    else
-        r->queue_cnt--;
-
-    return ret_get;
+exit:
+    if (r->draining &&
+        ret == AVERROR(EAGAIN))
+        ret = AVERROR_EOF;
+    return ret;
 }
 
 static void rkmpp_decode_flush(AVCodecContext *avctx)
@@ -926,10 +927,9 @@ static void rkmpp_decode_flush(AVCodecContext *avctx)
 
     if ((ret = r->mapi->reset(r->mctx)) == MPP_OK) {
         r->eof = 0;
+        r->draining = 0;
         r->info_change = 0;
         r->errinfo_cnt = 0;
-        r->queue_cnt = 0;
-        r->queue_size = 0;
 
         av_packet_unref(&r->last_pkt);
     } else
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index 6a4cd6bf68b..0eba15000e4 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -41,7 +41,6 @@
 #include "libavutil/pixdesc.h"
 
 #define MAX_ERRINFO_COUNT 100
-#define MAX_RETRY_COUNT   100
 
 typedef struct RKMPPDecContext {
     AVClass       *class;
@@ -55,10 +54,9 @@ typedef struct RKMPPDecContext {
 
     AVPacket       last_pkt;
     int            eof;
+    int            draining;
     int            info_change;
     int            errinfo_cnt;
-    int            queue_cnt;
-    int            queue_size;
 
     int            deint;
     int            afbc;

From 9de0f4b79395528a8e0a0ad6cd4809cea0c5e14e Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 18 Mar 2024 23:46:01 +0800
Subject: [PATCH 045/103] lavu/hwcontext_rkmpp: add BE formats

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 40 ++++++++++++++++++++++++-------------
 1 file changed, 26 insertions(+), 14 deletions(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index 18f0f82dd74..b4db605842f 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -62,20 +62,32 @@ static const struct {
     { AV_PIX_FMT_YVYU422,  DRM_FORMAT_YVYU,     },
     { AV_PIX_FMT_UYVY422,  DRM_FORMAT_UYVY,     },
     /* packed RGB */
-    { AV_PIX_FMT_RGB555LE, DRM_FORMAT_XRGB1555, },
-    { AV_PIX_FMT_BGR555LE, DRM_FORMAT_XBGR1555, },
-    { AV_PIX_FMT_RGB565LE, DRM_FORMAT_RGB565,   },
-    { AV_PIX_FMT_BGR565LE, DRM_FORMAT_BGR565,   },
-    { AV_PIX_FMT_RGB24,    DRM_FORMAT_RGB888,   },
-    { AV_PIX_FMT_BGR24,    DRM_FORMAT_BGR888,   },
-    { AV_PIX_FMT_RGBA,     DRM_FORMAT_ABGR8888, },
-    { AV_PIX_FMT_RGB0,     DRM_FORMAT_XBGR8888, },
-    { AV_PIX_FMT_BGRA,     DRM_FORMAT_ARGB8888, },
-    { AV_PIX_FMT_BGR0,     DRM_FORMAT_XRGB8888, },
-    { AV_PIX_FMT_ARGB,     DRM_FORMAT_BGRA8888, },
-    { AV_PIX_FMT_0RGB,     DRM_FORMAT_BGRX8888, },
-    { AV_PIX_FMT_ABGR,     DRM_FORMAT_RGBA8888, },
-    { AV_PIX_FMT_0BGR,     DRM_FORMAT_RGBX8888, },
+    { AV_PIX_FMT_RGB444LE,  DRM_FORMAT_XRGB4444, },
+    { AV_PIX_FMT_RGB444BE,  DRM_FORMAT_XRGB4444    | DRM_FORMAT_BIG_ENDIAN, },
+    { AV_PIX_FMT_BGR444LE,  DRM_FORMAT_XBGR4444, },
+    { AV_PIX_FMT_BGR444BE,  DRM_FORMAT_XBGR4444    | DRM_FORMAT_BIG_ENDIAN, },
+    { AV_PIX_FMT_RGB555LE,  DRM_FORMAT_XRGB1555, },
+    { AV_PIX_FMT_RGB555BE,  DRM_FORMAT_XRGB1555    | DRM_FORMAT_BIG_ENDIAN, },
+    { AV_PIX_FMT_BGR555LE,  DRM_FORMAT_XBGR1555, },
+    { AV_PIX_FMT_BGR555BE,  DRM_FORMAT_XBGR1555    | DRM_FORMAT_BIG_ENDIAN, },
+    { AV_PIX_FMT_RGB565LE,  DRM_FORMAT_RGB565,   },
+    { AV_PIX_FMT_RGB565BE,  DRM_FORMAT_RGB565      | DRM_FORMAT_BIG_ENDIAN, },
+    { AV_PIX_FMT_BGR565LE,  DRM_FORMAT_BGR565,   },
+    { AV_PIX_FMT_BGR565BE,  DRM_FORMAT_BGR565      | DRM_FORMAT_BIG_ENDIAN, },
+    { AV_PIX_FMT_RGB24,     DRM_FORMAT_RGB888,   },
+    { AV_PIX_FMT_BGR24,     DRM_FORMAT_BGR888,   },
+    { AV_PIX_FMT_RGBA,      DRM_FORMAT_ABGR8888, },
+    { AV_PIX_FMT_RGB0,      DRM_FORMAT_XBGR8888, },
+    { AV_PIX_FMT_BGRA,      DRM_FORMAT_ARGB8888, },
+    { AV_PIX_FMT_BGR0,      DRM_FORMAT_XRGB8888, },
+    { AV_PIX_FMT_ARGB,      DRM_FORMAT_BGRA8888, },
+    { AV_PIX_FMT_0RGB,      DRM_FORMAT_BGRX8888, },
+    { AV_PIX_FMT_ABGR,      DRM_FORMAT_RGBA8888, },
+    { AV_PIX_FMT_0BGR,      DRM_FORMAT_RGBX8888, },
+    { AV_PIX_FMT_X2RGB10LE, DRM_FORMAT_XRGB2101010, },
+    { AV_PIX_FMT_X2RGB10BE, DRM_FORMAT_XRGB2101010 | DRM_FORMAT_BIG_ENDIAN, },
+    { AV_PIX_FMT_X2BGR10LE, DRM_FORMAT_XBGR2101010, },
+    { AV_PIX_FMT_X2BGR10BE, DRM_FORMAT_XBGR2101010 | DRM_FORMAT_BIG_ENDIAN, },
 };
 
 static int rkmpp_device_create(AVHWDeviceContext *hwdev, const char *device,

From ab1bad703430069457490acc584f762f05d66976 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 18 Mar 2024 23:57:18 +0800
Subject: [PATCH 046/103] lavc/rkmppenc: add RKMPP MJPEG encoder

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure              |   1 +
 libavcodec/Makefile    |   1 +
 libavcodec/allcodecs.c |   1 +
 libavcodec/rkmppenc.c  | 131 ++++++++++++++++++++++++++++++++---------
 libavcodec/rkmppenc.h  |  47 +++++++++++++--
 5 files changed, 149 insertions(+), 32 deletions(-)

diff --git a/configure b/configure
index 31e00e26893..01fddf28e07 100755
--- a/configure
+++ b/configure
@@ -3266,6 +3266,7 @@ mjpeg_cuvid_decoder_deps="cuvid"
 mjpeg_qsv_decoder_select="qsvdec"
 mjpeg_qsv_encoder_deps="libmfx"
 mjpeg_qsv_encoder_select="qsvenc"
+mjpeg_rkmpp_encoder_deps="rkmpp"
 mjpeg_vaapi_encoder_deps="VAEncPictureParameterBufferJPEG"
 mjpeg_vaapi_encoder_select="cbs_jpeg jpegtables vaapi_encode"
 mp3_mf_encoder_deps="mediafoundation"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 9932419fa01..aaf1ba9f7ca 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -502,6 +502,7 @@ OBJS-$(CONFIG_MJPEG_ENCODER)           += mjpegenc.o mjpegenc_common.o \
 OBJS-$(CONFIG_MJPEGB_DECODER)          += mjpegbdec.o
 OBJS-$(CONFIG_MJPEG_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MJPEG_QSV_ENCODER)       += qsvenc_jpeg.o
+OBJS-$(CONFIG_MJPEG_RKMPP_ENCODER)     += rkmppenc.o
 OBJS-$(CONFIG_MJPEG_VAAPI_ENCODER)     += vaapi_encode_mjpeg.o
 OBJS-$(CONFIG_MLP_DECODER)             += mlpdec.o mlpdsp.o
 OBJS-$(CONFIG_MLP_ENCODER)             += mlpenc.o mlp.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 8c346c9e967..3b6e8267159 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -878,6 +878,7 @@ extern const FFCodec ff_libkvazaar_encoder;
 extern const FFCodec ff_mjpeg_cuvid_decoder;
 extern const FFCodec ff_mjpeg_qsv_encoder;
 extern const FFCodec ff_mjpeg_qsv_decoder;
+extern const FFCodec ff_mjpeg_rkmpp_encoder;
 extern const FFCodec ff_mjpeg_vaapi_encoder;
 extern const FFCodec ff_mp3_mf_encoder;
 extern const FFCodec ff_mpeg1_cuvid_decoder;
diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index bc1471f2e53..6bf851658cf 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -30,13 +30,14 @@
 static MppCodingType rkmpp_get_coding_type(AVCodecContext *avctx)
 {
     switch (avctx->codec_id) {
-    case AV_CODEC_ID_H264: return MPP_VIDEO_CodingAVC;
-    case AV_CODEC_ID_HEVC: return MPP_VIDEO_CodingHEVC;
-    default:               return MPP_VIDEO_CodingUnused;
+    case AV_CODEC_ID_H264:  return MPP_VIDEO_CodingAVC;
+    case AV_CODEC_ID_HEVC:  return MPP_VIDEO_CodingHEVC;
+    case AV_CODEC_ID_MJPEG: return MPP_VIDEO_CodingMJPEG;
+    default:                return MPP_VIDEO_CodingUnused;
     }
 }
 
-static MppFrameFormat rkmpp_get_mpp_fmt(enum AVPixelFormat pix_fmt)
+static MppFrameFormat rkmpp_get_mpp_fmt_h26x(enum AVPixelFormat pix_fmt)
 {
     switch (pix_fmt) {
     case AV_PIX_FMT_GRAY8:   return MPP_FMT_YUV400;
@@ -64,6 +65,33 @@ static MppFrameFormat rkmpp_get_mpp_fmt(enum AVPixelFormat pix_fmt)
     }
 }
 
+static MppFrameFormat rkmpp_get_mpp_fmt_mjpeg(enum AVPixelFormat pix_fmt)
+{
+    switch (pix_fmt) {
+    case AV_PIX_FMT_YUV420P:   return MPP_FMT_YUV420P;
+    case AV_PIX_FMT_NV12:      return MPP_FMT_YUV420SP;
+    case AV_PIX_FMT_YUYV422:   return MPP_FMT_YUV422_YUYV;
+    case AV_PIX_FMT_UYVY422:   return MPP_FMT_YUV422_UYVY;
+    case AV_PIX_FMT_RGB444BE:  return MPP_FMT_RGB444;
+    case AV_PIX_FMT_BGR444BE:  return MPP_FMT_BGR444;
+    case AV_PIX_FMT_RGB555BE:  return MPP_FMT_RGB555;
+    case AV_PIX_FMT_BGR555BE:  return MPP_FMT_BGR555;
+    case AV_PIX_FMT_RGB565BE:  return MPP_FMT_RGB565;
+    case AV_PIX_FMT_BGR565BE:  return MPP_FMT_BGR565;
+    case AV_PIX_FMT_RGBA:
+    case AV_PIX_FMT_RGB0:      return MPP_FMT_RGBA8888;
+    case AV_PIX_FMT_BGRA:
+    case AV_PIX_FMT_BGR0:      return MPP_FMT_BGRA8888;
+    case AV_PIX_FMT_ARGB:
+    case AV_PIX_FMT_0RGB:      return MPP_FMT_ARGB8888;
+    case AV_PIX_FMT_ABGR:
+    case AV_PIX_FMT_0BGR:      return MPP_FMT_ABGR8888;
+    case AV_PIX_FMT_X2RGB10BE: return MPP_FMT_RGB101010;
+    case AV_PIX_FMT_X2BGR10BE: return MPP_FMT_BGR101010;
+    default:                   return MPP_FMT_BUTT;
+    }
+}
+
 static uint32_t rkmpp_get_drm_afbc_format(MppFrameFormat mpp_fmt)
 {
     switch (mpp_fmt & MPP_FRAME_FMT_MASK) {
@@ -231,6 +259,13 @@ static int rkmpp_set_enc_cfg_prep(AVCodecContext *avctx, AVFrame *frame)
 
     pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
     is_afbc = drm_is_afbc(drm_desc->objects[0].format_modifier);
+    if (is_afbc &&
+        !(avctx->codec_id == AV_CODEC_ID_H264 ||
+          avctx->codec_id == AV_CODEC_ID_HEVC)) {
+        av_log(avctx, AV_LOG_ERROR, "AFBC is not supported in codec '%s'\n",
+               avcodec_get_name(avctx->codec_id));
+        return AVERROR(ENOSYS);
+    }
     if (!is_afbc) {
         ret = get_byte_stride(&drm_desc->objects[0],
                               &drm_desc->layers[0],
@@ -317,7 +352,7 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
 
     mpp_enc_cfg_set_s32(cfg, "rc:gop", FFMAX(avctx->gop_size, 1));
 
-    rc_mode = r->rc_mode;
+    rc_mode = avctx->codec_id == AV_CODEC_ID_MJPEG ? MPP_ENC_RC_MODE_FIXQP : r->rc_mode;
     if (rc_mode == MPP_ENC_RC_MODE_BUTT) {
         if (r->qp_init >= 0)
             rc_mode = MPP_ENC_RC_MODE_FIXQP;
@@ -342,7 +377,6 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
     switch (rc_mode) {
     case MPP_ENC_RC_MODE_FIXQP:
         /* do not setup bitrate on FIXQP mode */
-        min_bps = max_bps = avctx->bit_rate;
         break;
     case MPP_ENC_RC_MODE_VBR:
     case MPP_ENC_RC_MODE_AVBR:
@@ -359,12 +393,15 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
         min_bps = avctx->bit_rate * 15 / 16;
         break;
     }
-    mpp_enc_cfg_set_u32(cfg, "rc:bps_target", avctx->bit_rate);
-    mpp_enc_cfg_set_s32(cfg, "rc:bps_max", max_bps);
-    mpp_enc_cfg_set_s32(cfg, "rc:bps_min", min_bps);
-
-    av_log(avctx, AV_LOG_VERBOSE, "Bitrate Target/Min/Max is set to %ld/%d/%d\n",
-           avctx->bit_rate, min_bps, max_bps);
+    if (rc_mode == MPP_ENC_RC_MODE_CBR ||
+        rc_mode == MPP_ENC_RC_MODE_VBR ||
+        rc_mode == MPP_ENC_RC_MODE_AVBR) {
+        mpp_enc_cfg_set_u32(cfg, "rc:bps_target", avctx->bit_rate);
+        mpp_enc_cfg_set_s32(cfg, "rc:bps_max", max_bps);
+        mpp_enc_cfg_set_s32(cfg, "rc:bps_min", min_bps);
+        av_log(avctx, AV_LOG_VERBOSE, "Bitrate Target/Min/Max is set to %ld/%d/%d\n",
+               avctx->bit_rate, min_bps, max_bps);
+    }
 
     if (avctx->rc_buffer_size > 0 &&
         (rc_mode == MPP_ENC_RC_MODE_CBR ||
@@ -409,6 +446,17 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
             mpp_enc_cfg_set_s32(cfg, "rc:qp_min_i", qp_min_i);
         }
         break;
+    case AV_CODEC_ID_MJPEG:
+        {
+            qp_init = r->qp_init >= 1 ? r->qp_init : 80;
+            qp_max = r->qp_max >= 1 ? r->qp_max : 99;
+            qp_min = r->qp_min >= 1 ? r->qp_min : 1;
+            /* jpeg use special codec config to control qtable */
+            mpp_enc_cfg_set_s32(cfg, "jpeg:q_factor", qp_init);
+            mpp_enc_cfg_set_s32(cfg, "jpeg:qf_max", qp_max);
+            mpp_enc_cfg_set_s32(cfg, "jpeg:qf_min", qp_min);
+        }
+        break;
     default:
         return AVERROR(EINVAL);
     }
@@ -464,6 +512,8 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
             av_log(avctx, AV_LOG_VERBOSE, "Level is set to %d\n", avctx->level / 3);
         }
         break;
+    case AV_CODEC_ID_MJPEG:
+        break;
     default:
         return AVERROR(EINVAL);
     }
@@ -473,15 +523,15 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
         return AVERROR_EXTERNAL;
     }
 
-    sei_mode = MPP_ENC_SEI_MODE_DISABLE;
-    if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_SEI_CFG, &sei_mode)) != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set SEI config: %d\n", ret);
-        return AVERROR_EXTERNAL;
-    }
-
-    header_mode = MPP_ENC_HEADER_MODE_EACH_IDR;
     if (avctx->codec_id == AV_CODEC_ID_H264 ||
         avctx->codec_id == AV_CODEC_ID_HEVC) {
+        sei_mode = MPP_ENC_SEI_MODE_DISABLE;
+        if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_SEI_CFG, &sei_mode)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to set SEI config: %d\n", ret);
+            return AVERROR_EXTERNAL;
+        }
+
+        header_mode = MPP_ENC_HEADER_MODE_EACH_IDR;
         if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_HEADER_MODE, &header_mode)) != MPP_OK) {
             av_log(avctx, AV_LOG_ERROR, "Failed to set header mode: %d\n", ret);
             return AVERROR_EXTERNAL;
@@ -572,6 +622,13 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     plane0 = &layer->planes[0];
 
     is_afbc = drm_is_afbc(drm_desc->objects[0].format_modifier);
+    if (is_afbc &&
+        !(avctx->codec_id == AV_CODEC_ID_H264 ||
+          avctx->codec_id == AV_CODEC_ID_HEVC)) {
+        av_log(avctx, AV_LOG_ERROR, "AFBC is not supported in codec '%s'\n",
+               avcodec_get_name(avctx->codec_id));
+        goto exit;
+    }
     if (is_afbc) {
         uint32_t drm_afbc_fmt = rkmpp_get_drm_afbc_format(mpp_fmt);
         int afbc_offset_y = 0;
@@ -654,7 +711,9 @@ static int rkmpp_send_frame(AVCodecContext *avctx, MPPEncFrame *mpp_enc_frame)
     if (frame && (ret = rkmpp_set_enc_cfg_prep(avctx, frame)) < 0)
         goto exit;
 
-    if (frame && frame->pict_type == AV_PICTURE_TYPE_I) {
+    if ((avctx->codec_id == AV_CODEC_ID_H264 ||
+         avctx->codec_id == AV_CODEC_ID_HEVC) &&
+         frame && frame->pict_type == AV_PICTURE_TYPE_I) {
         if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_IDR_FRAME, NULL)) != MPP_OK) {
             av_log(avctx, AV_LOG_ERROR, "Failed to set IDR frame: %d\n", ret);
             ret = AVERROR_EXTERNAL;
@@ -765,10 +824,13 @@ static int rkmpp_encode_frame(AVCodecContext *avctx, AVPacket *packet,
     RKMPPEncContext *r = avctx->priv_data;
     MPPEncFrame *mpp_enc_frame = NULL;
     int ret;
-    int timeout = (avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
-                  ? MPP_TIMEOUT_BLOCK : MPP_TIMEOUT_NON_BLOCK;
+    int timeout = (avctx->codec_id == AV_CODEC_ID_H264 ||
+                   avctx->codec_id == AV_CODEC_ID_HEVC ||
+                   avctx->codec_id == AV_CODEC_ID_MJPEG) &&
+                   !(avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
+                   ? MPP_TIMEOUT_NON_BLOCK : MPP_TIMEOUT_BLOCK;
 
-    if (get_used_frame_count(r->frame_list) > H26X_ASYNC_FRAMES)
+    if (get_used_frame_count(r->frame_list) > r->async_frames)
         goto get;
 
     mpp_enc_frame = rkmpp_submit_frame(avctx, (AVFrame *)frame);
@@ -804,6 +866,7 @@ static int rkmpp_encode_close(AVCodecContext *avctx)
     RKMPPEncContext *r = avctx->priv_data;
 
     r->cfg_init = 0;
+    r->async_frames = 0;
 
     if (r->mapi) {
         r->mapi->reset(r->mctx);
@@ -859,13 +922,18 @@ static int rkmpp_encode_init(AVCodecContext *avctx)
     int output_timeout = MPP_TIMEOUT_NON_BLOCK;
     int ret;
 
+    r->cfg_init = 0;
+    r->async_frames = 0;
+
     if ((coding_type = rkmpp_get_coding_type(avctx)) == MPP_VIDEO_CodingUnused) {
         av_log(avctx, AV_LOG_ERROR, "Unknown codec id: %d\n", avctx->codec_id);
         return AVERROR(ENOSYS);
     }
 
     pix_fmt = avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME ? avctx->sw_pix_fmt : avctx->pix_fmt;
-    mpp_fmt = rkmpp_get_mpp_fmt(pix_fmt) & MPP_FRAME_FMT_MASK;
+    mpp_fmt = avctx->codec_id == AV_CODEC_ID_MJPEG
+              ? rkmpp_get_mpp_fmt_mjpeg(pix_fmt) : rkmpp_get_mpp_fmt_h26x(pix_fmt);
+    mpp_fmt &= MPP_FRAME_FMT_MASK;
 
     if (mpp_fmt == MPP_FMT_BUTT) {
         av_log(avctx, AV_LOG_ERROR, "Unsupported input pixel format '%s'\n",
@@ -920,6 +988,12 @@ static int rkmpp_encode_init(AVCodecContext *avctx)
     if ((ret = rkmpp_set_enc_cfg(avctx)) < 0)
         goto fail;
 
+    if (avctx->codec_id == AV_CODEC_ID_H264 ||
+        avctx->codec_id == AV_CODEC_ID_HEVC)
+        r->async_frames = H26X_ASYNC_FRAMES;
+    else if (avctx->codec_id == AV_CODEC_ID_MJPEG)
+        r->async_frames = MJPEG_ASYNC_FRAMES;
+
     if (avctx->codec_id == AV_CODEC_ID_H264 ||
         avctx->codec_id == AV_CODEC_ID_HEVC) {
         RK_U8 enc_hdr_buf[H26X_HEADER_SIZE];
@@ -929,7 +1003,7 @@ static int rkmpp_encode_init(AVCodecContext *avctx)
         memset(enc_hdr_buf, 0, H26X_HEADER_SIZE);
 
         if ((ret = mpp_packet_init(&mpp_pkt,
-	                           (void *)enc_hdr_buf,
+                                   (void *)enc_hdr_buf,
                                    H26X_HEADER_SIZE)) != MPP_OK || !mpp_pkt) {
             av_log(avctx, AV_LOG_ERROR, "Failed to init extra info packet: %d\n", ret);
             ret = AVERROR_EXTERNAL;
@@ -1006,8 +1080,11 @@ static int rkmpp_encode_init(AVCodecContext *avctx)
 }
 
 #if CONFIG_H264_RKMPP_ENCODER
-DEFINE_RKMPP_ENCODER(h264, H264)
+DEFINE_RKMPP_ENCODER(h264, H264, h26x)
 #endif
 #if CONFIG_HEVC_RKMPP_ENCODER
-DEFINE_RKMPP_ENCODER(hevc, HEVC)
+DEFINE_RKMPP_ENCODER(hevc, HEVC, h26x)
+#endif
+#if CONFIG_MJPEG_RKMPP_ENCODER
+DEFINE_RKMPP_ENCODER(mjpeg, MJPEG, mjpeg)
 #endif
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index e34c227b306..d90c84ca91c 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -38,8 +38,9 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 
-#define H26X_HEADER_SIZE  1024
-#define H26X_ASYNC_FRAMES 4
+#define H26X_HEADER_SIZE   1024
+#define H26X_ASYNC_FRAMES  4
+#define MJPEG_ASYNC_FRAMES 8
 #define ALIGN_DOWN(a, b) ((a) & ~((b)-1))
 
 typedef struct MPPEncFrame {
@@ -64,6 +65,7 @@ typedef struct RKMPPEncContext {
     enum AVPixelFormat pix_fmt;
 
     MPPEncFrame       *frame_list;
+    int                async_frames;
 
     int                rc_mode;
     int                qp_init;
@@ -171,7 +173,17 @@ static const AVOption hevc_options[] = {
     { NULL }
 };
 
-static const enum AVPixelFormat rkmpp_enc_pix_fmts[] = {
+static const AVOption mjpeg_options[] = {
+    { "qp_init", "Set the initial QP/Q_Factor value", OFFSET(qp_init), AV_OPT_TYPE_INT, \
+            { .i64 = -1 }, -1, 99, VE, "qmin" }, \
+    { "qp_max", "Set the max QP/Q_Factor value", OFFSET(qp_max), AV_OPT_TYPE_INT, \
+            { .i64 = -1 }, -1, 99, VE, "qp_max" }, \
+    { "qp_min", "Set the min QP/Q_Factor value", OFFSET(qp_min), AV_OPT_TYPE_INT, \
+            { .i64 = -1 }, -1, 99, VE, "qp_min" }, \
+    { NULL }
+};
+
+static const enum AVPixelFormat rkmpp_enc_pix_fmts_h26x[] = {
     AV_PIX_FMT_GRAY8,
     AV_PIX_FMT_YUV420P,
     AV_PIX_FMT_YUV422P,
@@ -197,6 +209,31 @@ static const enum AVPixelFormat rkmpp_enc_pix_fmts[] = {
     AV_PIX_FMT_NONE,
 };
 
+static const enum AVPixelFormat rkmpp_enc_pix_fmts_mjpeg[] = {
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_NV12,
+    AV_PIX_FMT_YUYV422,
+    AV_PIX_FMT_UYVY422,
+    AV_PIX_FMT_RGB444BE,
+    AV_PIX_FMT_BGR444BE,
+    AV_PIX_FMT_RGB555BE,
+    AV_PIX_FMT_BGR555BE,
+    AV_PIX_FMT_RGB565BE,
+    AV_PIX_FMT_BGR565BE,
+    AV_PIX_FMT_RGBA,
+    AV_PIX_FMT_RGB0,
+    AV_PIX_FMT_BGRA,
+    AV_PIX_FMT_BGR0,
+    AV_PIX_FMT_ARGB,
+    AV_PIX_FMT_0RGB,
+    AV_PIX_FMT_ABGR,
+    AV_PIX_FMT_0BGR,
+    AV_PIX_FMT_X2RGB10BE,
+    AV_PIX_FMT_X2BGR10BE,
+    AV_PIX_FMT_DRM_PRIME,
+    AV_PIX_FMT_NONE,
+};
+
 static const AVCodecHWConfigInternal *const rkmpp_enc_hw_configs[] = {
     HW_CONFIG_ENCODER_DEVICE(NONE,      RKMPP),
     HW_CONFIG_ENCODER_FRAMES(DRM_PRIME, RKMPP),
@@ -210,7 +247,7 @@ static const FFCodecDefault rkmpp_enc_defaults[] = {
     { NULL }
 };
 
-#define DEFINE_RKMPP_ENCODER(x, X) \
+#define DEFINE_RKMPP_ENCODER(x, X, xx) \
 static const AVClass x##_rkmpp_encoder_class = { \
     .class_name = #x "_rkmpp_encoder", \
     .item_name  = av_default_item_name, \
@@ -230,7 +267,7 @@ const FFCodec ff_##x##_rkmpp_encoder = { \
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE, \
     .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | \
                       FF_CODEC_CAP_INIT_CLEANUP, \
-    .p.pix_fmts     = rkmpp_enc_pix_fmts, \
+    .p.pix_fmts     = rkmpp_enc_pix_fmts_##xx, \
     .hw_configs     = rkmpp_enc_hw_configs, \
     .defaults       = rkmpp_enc_defaults, \
     .p.wrapper_name = "rkmpp", \

From 733309bc7e9436784b631431665fe25a3335a279 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 26 Mar 2024 22:35:48 +0800
Subject: [PATCH 047/103] fixup! README: update for ffmpeg-rockchip

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 README.md | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 4dad27b8c0d..f23235cc1ea 100644
--- a/README.md
+++ b/README.md
@@ -40,6 +40,7 @@ The documentation is available on the [Wiki](https://github.com/nyanmisaka/ffmpe
 ```
  V..... h264_rkmpp           Rockchip MPP (Media Process Platform) H264 encoder (codec h264)
  V..... hevc_rkmpp           Rockchip MPP (Media Process Platform) HEVC encoder (codec hevc)
+ V..... mjpeg_rkmpp          Rockchip MPP (Media Process Platform) MJPEG encoder (codec mjpeg)
 ```
 
 ### Filters
@@ -80,7 +81,7 @@ The documentation is available on the [Wiki](https://github.com/nyanmisaka/ffmpe
 ```
 
 ## Todo
-* Support MPP MJPEG/JPEG decoder and encoder
+* Support MPP MJPEG/JPEG decoder
 * Support MPP VP8 video encoder
 * ...
 

From 257e7ebf7d38c54e32743af8c424483d63237a23 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 28 Mar 2024 21:25:55 +0800
Subject: [PATCH 048/103] fixup! lavu: add RKMPP hwcontext

Fix yuv420p/yuv422p encoding at specific resolutions.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 39 +++++++++++++++++++++----------------
 1 file changed, 22 insertions(+), 17 deletions(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index b4db605842f..0c43e7b03f9 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -42,25 +42,25 @@ static const struct {
     uint32_t drm_format;
 } supported_formats[] = {
     /* grayscale */
-    { AV_PIX_FMT_GRAY8,    DRM_FORMAT_R8        },
-    /* planar YUV */
-    { AV_PIX_FMT_YUV420P,  DRM_FORMAT_YUV420,   },
-    { AV_PIX_FMT_YUV422P,  DRM_FORMAT_YUV422,   },
-    { AV_PIX_FMT_YUV444P,  DRM_FORMAT_YUV444,   },
+    { AV_PIX_FMT_GRAY8,     DRM_FORMAT_R8        },
+    /* fully-planar YUV */
+    { AV_PIX_FMT_YUV420P,   DRM_FORMAT_YUV420,   },
+    { AV_PIX_FMT_YUV422P,   DRM_FORMAT_YUV422,   },
+    { AV_PIX_FMT_YUV444P,   DRM_FORMAT_YUV444,   },
     /* semi-planar YUV */
-    { AV_PIX_FMT_NV12,     DRM_FORMAT_NV12,     },
-    { AV_PIX_FMT_NV21,     DRM_FORMAT_NV21,     },
-    { AV_PIX_FMT_NV16,     DRM_FORMAT_NV16,     },
-    { AV_PIX_FMT_NV24,     DRM_FORMAT_NV24,     },
+    { AV_PIX_FMT_NV12,      DRM_FORMAT_NV12,     },
+    { AV_PIX_FMT_NV21,      DRM_FORMAT_NV21,     },
+    { AV_PIX_FMT_NV16,      DRM_FORMAT_NV16,     },
+    { AV_PIX_FMT_NV24,      DRM_FORMAT_NV24,     },
     /* semi-planar YUV 10-bit */
-    { AV_PIX_FMT_P010,     DRM_FORMAT_P010,     },
-    { AV_PIX_FMT_P210,     DRM_FORMAT_P210,     },
-    { AV_PIX_FMT_NV15,     DRM_FORMAT_NV15,     },
-    { AV_PIX_FMT_NV20,     DRM_FORMAT_NV20,     },
+    { AV_PIX_FMT_P010,      DRM_FORMAT_P010,     },
+    { AV_PIX_FMT_P210,      DRM_FORMAT_P210,     },
+    { AV_PIX_FMT_NV15,      DRM_FORMAT_NV15,     },
+    { AV_PIX_FMT_NV20,      DRM_FORMAT_NV20,     },
     /* packed YUV */
-    { AV_PIX_FMT_YUYV422,  DRM_FORMAT_YUYV,     },
-    { AV_PIX_FMT_YVYU422,  DRM_FORMAT_YVYU,     },
-    { AV_PIX_FMT_UYVY422,  DRM_FORMAT_UYVY,     },
+    { AV_PIX_FMT_YUYV422,   DRM_FORMAT_YUYV,     },
+    { AV_PIX_FMT_YVYU422,   DRM_FORMAT_YVYU,     },
+    { AV_PIX_FMT_UYVY422,   DRM_FORMAT_UYVY,     },
     /* packed RGB */
     { AV_PIX_FMT_RGB444LE,  DRM_FORMAT_XRGB4444, },
     { AV_PIX_FMT_RGB444BE,  DRM_FORMAT_XRGB4444    | DRM_FORMAT_BIG_ENDIAN, },
@@ -162,8 +162,11 @@ static int rkmpp_get_aligned_linesize(enum AVPixelFormat pix_fmt, int width, int
 {
     const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(pix_fmt);
     const int is_rgb = pixdesc->flags & AV_PIX_FMT_FLAG_RGB;
+    const int is_yuv = !is_rgb && pixdesc->nb_components >= 2;
     const int is_planar = pixdesc->flags & AV_PIX_FMT_FLAG_PLANAR;
     const int is_packed_fmt = is_rgb || (!is_rgb && !is_planar);
+    const int is_fully_planar = is_planar &&
+                                pixdesc->comp[1].plane != pixdesc->comp[2].plane;
     int linesize;
 
     if (pix_fmt == AV_PIX_FMT_NV15 ||
@@ -178,6 +181,8 @@ static int rkmpp_get_aligned_linesize(enum AVPixelFormat pix_fmt, int width, int
     if (is_packed_fmt) {
         const int pixel_width = av_get_padded_bits_per_pixel(pixdesc) / 8;
         linesize = FFALIGN(linesize / pixel_width, 8) * pixel_width;
+    } else if (is_yuv && is_fully_planar) {
+        linesize = FFALIGN(linesize, 16);
     } else
         linesize = FFALIGN(linesize, 64);
 
@@ -242,7 +247,7 @@ static AVBufferRef *rkmpp_drm_pool_alloc(void *opaque, size_t size)
         layer->planes[i].object_index = 0;
         layer->planes[i].offset =
             layer->planes[i-1].offset +
-            layer->planes[i-1].pitch * (hwfc->height >> (i > 1 ? pixdesc->log2_chroma_h : 0));
+            layer->planes[i-1].pitch * (FFALIGN(hwfc->height, 2) >> (i > 1 ? pixdesc->log2_chroma_h : 0));
         layer->planes[i].pitch =
             rkmpp_get_aligned_linesize(hwfc->sw_format, hwfc->width, i);
     }

From ba84e56c51d9cde1f3b1fead2a21e4d271028709 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 28 Mar 2024 21:26:43 +0800
Subject: [PATCH 049/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

Update encoder input size quirks.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 6bf851658cf..1b96ee1f210 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -550,7 +550,10 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     const AVDRMFrameDescriptor *drm_desc;
     const AVDRMLayerDescriptor *layer;
     const AVDRMPlaneDescriptor *plane0;
-    const AVPixFmtDescriptor *pix_desc;
+    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
+    const int is_planar = pix_desc->flags & AV_PIX_FMT_FLAG_PLANAR;
+    const int is_rgb = pix_desc->flags & AV_PIX_FMT_FLAG_RGB;
+    const int is_yuv = !is_rgb && pix_desc->nb_components >= 2;
     int hor_stride = 0, ver_stride = 0;
     MppBufferInfo buf_info = { 0 };
     MppFrameFormat mpp_fmt = r->mpp_fmt;
@@ -603,9 +606,19 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     if (drm_desc->objects[0].fd < 0)
         goto exit;
 
+    /* planar YUV quirks */
     if ((r->pix_fmt == AV_PIX_FMT_YUV420P ||
-         r->pix_fmt == AV_PIX_FMT_YUV422P) && (drm_frame->width % 2)) {
-        av_log(avctx, AV_LOG_ERROR, "Unsupported width %d, not 2-aligned\n", drm_frame->width);
+         r->pix_fmt == AV_PIX_FMT_YUV422P ||
+         r->pix_fmt == AV_PIX_FMT_NV24) && (drm_frame->width % 2)) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported width '%d', not 2-aligned\n",
+               drm_frame->width);
+        goto exit;
+    }
+    /* packed RGB/YUV quirks */
+    if ((is_rgb || (is_yuv && !is_planar)) &&
+        (drm_frame->width % 2 || drm_frame->height % 2)) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported size '%dx%d', not 2-aligned\n",
+               drm_frame->width, drm_frame->height);
         goto exit;
     }
 
@@ -647,7 +660,6 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     }
     mpp_frame_set_fmt(mpp_frame, mpp_fmt);
 
-    pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
     if (is_afbc) {
         hor_stride = plane0->pitch;
         if ((ret = get_afbc_byte_stride(pix_desc, &hor_stride, 1)) < 0)

From 6f88a29491856de8cc258f7a94be761c3b3145c4 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 24 Apr 2024 21:04:52 +0800
Subject: [PATCH 050/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

Add `dump_extra` bsf to h264/hevc_rkmpp decoder since
in rtsp, sequence header is passed through sdp and video
stream may not have sequence header.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure             | 4 ++--
 libavcodec/rkmppdec.c | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/configure b/configure
index 01fddf28e07..c0086fe4fe5 100755
--- a/configure
+++ b/configure
@@ -3236,7 +3236,7 @@ h264_omx_encoder_deps="omx"
 h264_qsv_decoder_select="h264_mp4toannexb_bsf qsvdec"
 h264_qsv_encoder_select="atsc_a53 qsvenc"
 h264_rkmpp_decoder_deps="rkmpp"
-h264_rkmpp_decoder_select="h264_mp4toannexb_bsf"
+h264_rkmpp_decoder_select="h264_mp4toannexb_bsf dump_extradata_bsf"
 h264_rkmpp_encoder_deps="rkmpp"
 h264_vaapi_encoder_select="atsc_a53 cbs_h264 vaapi_encode"
 h264_v4l2m2m_decoder_deps="v4l2_m2m h264_v4l2_m2m"
@@ -3255,7 +3255,7 @@ hevc_nvenc_encoder_select="atsc_a53"
 hevc_qsv_decoder_select="hevc_mp4toannexb_bsf qsvdec"
 hevc_qsv_encoder_select="hevcparse qsvenc"
 hevc_rkmpp_decoder_deps="rkmpp"
-hevc_rkmpp_decoder_select="hevc_mp4toannexb_bsf"
+hevc_rkmpp_decoder_select="hevc_mp4toannexb_bsf dump_extradata_bsf"
 hevc_rkmpp_encoder_deps="rkmpp"
 hevc_vaapi_encoder_deps="VAEncPictureParameterBufferHEVC"
 hevc_vaapi_encoder_select="atsc_a53 cbs_h265 vaapi_encode"
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 200208688a7..c6905ce9891 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -940,10 +940,10 @@ static void rkmpp_decode_flush(AVCodecContext *avctx)
 DEFINE_RKMPP_DECODER(h263, H263, NULL)
 #endif
 #if CONFIG_H264_RKMPP_DECODER
-DEFINE_RKMPP_DECODER(h264, H264, "h264_mp4toannexb")
+DEFINE_RKMPP_DECODER(h264, H264, "h264_mp4toannexb,dump_extra")
 #endif
 #if CONFIG_HEVC_RKMPP_DECODER
-DEFINE_RKMPP_DECODER(hevc, HEVC, "hevc_mp4toannexb")
+DEFINE_RKMPP_DECODER(hevc, HEVC, "hevc_mp4toannexb,dump_extra")
 #endif
 #if CONFIG_VP8_RKMPP_DECODER
 DEFINE_RKMPP_DECODER(vp8, VP8, NULL)

From 09cd2a2d18f0b2b557976b8e66ec2fd71e21db1a Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 4 May 2024 16:12:05 +0800
Subject: [PATCH 051/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 1b96ee1f210..388b9c3596d 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -451,6 +451,7 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
             qp_init = r->qp_init >= 1 ? r->qp_init : 80;
             qp_max = r->qp_max >= 1 ? r->qp_max : 99;
             qp_min = r->qp_min >= 1 ? r->qp_min : 1;
+            qp_max_i = qp_min_i = 0;
             /* jpeg use special codec config to control qtable */
             mpp_enc_cfg_set_s32(cfg, "jpeg:q_factor", qp_init);
             mpp_enc_cfg_set_s32(cfg, "jpeg:qf_max", qp_max);

From 2093e2b984896c8655474eb73c32c237fb1c451e Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 21 May 2024 00:13:38 +0800
Subject: [PATCH 052/103] fixup! lsws/input: add NV15 and NV20 formats support

add unscaled copy from nv15/nv20 to yuv420p1x/yuv422p1x

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libswscale/swscale_unscaled.c | 68 +++++++++++++++++++++++++++++++++++
 1 file changed, 68 insertions(+)

diff --git a/libswscale/swscale_unscaled.c b/libswscale/swscale_unscaled.c
index a5c9917799e..1d75e757acf 100644
--- a/libswscale/swscale_unscaled.c
+++ b/libswscale/swscale_unscaled.c
@@ -221,6 +221,61 @@ static int nv24ToPlanarWrapper(SwsContext *c, const uint8_t *src[],
     return srcSliceH;
 }
 
+static int nv15_20ToPlanarWrapper(SwsContext *c, const uint8_t *src[],
+                                  int srcStride[], int srcSliceY,
+                                  int srcSliceH, uint8_t *dstParam[],
+                                  int dstStride[])
+{
+    const AVPixFmtDescriptor *src_format = av_pix_fmt_desc_get(c->srcFormat);
+    const AVPixFmtDescriptor *dst_format = av_pix_fmt_desc_get(c->dstFormat);
+    int vsub = 1 << dst_format->log2_chroma_h;
+    uint16_t *dstY = (uint16_t*)(dstParam[0] + dstStride[0] * srcSliceY);
+    uint16_t *dstU = (uint16_t*)(dstParam[1] + dstStride[1] * srcSliceY / vsub);
+    uint16_t *dstV = (uint16_t*)(dstParam[2] + dstStride[2] * srcSliceY / vsub);
+    int x, y;
+
+    /* Calculate net shift required for values. */
+    const int shift[3] = {
+        dst_format->comp[0].depth + dst_format->comp[0].shift -
+        src_format->comp[0].depth - src_format->comp[0].shift,
+        dst_format->comp[1].depth + dst_format->comp[1].shift -
+        src_format->comp[1].depth - src_format->comp[1].shift,
+        dst_format->comp[2].depth + dst_format->comp[2].shift -
+        src_format->comp[2].depth - src_format->comp[2].shift,
+    };
+
+    for (y = srcSliceH; y > 0; y--) {
+        const uint8_t *tsrcY = src[0];
+        uint16_t *tdstY = dstY;
+        for (x = c->srcW / 4; x > 0; x--) {
+            *tdstY++ = (((tsrcY[1] & 0x3 ) << 8) | (tsrcY[0]        & 0xFF)) << shift[0];
+            *tdstY++ = (((tsrcY[2] & 0xF ) << 6) | ((tsrcY[1] >> 2) & 0x3F)) << shift[0];
+            *tdstY++ = (((tsrcY[3] & 0x3F) << 4) | ((tsrcY[2] >> 4) & 0xF )) << shift[0];
+            *tdstY++ = (((tsrcY[4] & 0xFF) << 2) | ((tsrcY[3] >> 6) & 0x3 )) << shift[0];
+            tsrcY += 5;
+        }
+        src[0] += srcStride[0];
+        dstY += dstStride[0] / sizeof(uint16_t);
+    }
+
+    for (y = srcSliceH / vsub; y > 0; y--) {
+        const uint8_t *tsrcUV = src[1];
+        uint16_t *tdstU = dstU, *tdstV = dstV;
+        for (x = c->chrSrcW / 2; x > 0; x--) {
+            *tdstU++ = (((tsrcUV[1] & 0x3 ) << 8) | (tsrcUV[0]        & 0xFF)) << shift[1];
+            *tdstV++ = (((tsrcUV[2] & 0xf ) << 6) | ((tsrcUV[1] >> 2) & 0x3F)) << shift[2];
+            *tdstU++ = (((tsrcUV[3] & 0x3F) << 4) | ((tsrcUV[2] >> 4) & 0xF )) << shift[1];
+            *tdstV++ = (((tsrcUV[4] & 0xFF) << 2) | ((tsrcUV[3] >> 6) & 0x3 )) << shift[2];
+            tsrcUV += 5;
+        }
+        src[1] += srcStride[1];
+        dstU += dstStride[1] / sizeof(uint16_t);
+        dstV += dstStride[2] / sizeof(uint16_t);
+    }
+
+    return srcSliceH;
+}
+
 static int planarToP01xWrapper(SwsContext *c, const uint8_t *src8[],
                                int srcStride[], int srcSliceY,
                                int srcSliceH, uint8_t *dstParam8[],
@@ -2004,6 +2059,19 @@ void ff_get_unscaled_swscale(SwsContext *c)
         (srcFormat == AV_PIX_FMT_NV24 || srcFormat == AV_PIX_FMT_NV42)) {
         c->convert_unscaled = nv24ToPlanarWrapper;
     }
+    /* nv15_to_yuv420p1x & nv20_to_yuv422p1x */
+    if ((srcFormat == AV_PIX_FMT_NV15 &&
+         (dstFormat == AV_PIX_FMT_YUV420P10 ||
+          dstFormat == AV_PIX_FMT_YUV420P12 ||
+          dstFormat == AV_PIX_FMT_YUV420P14 ||
+          dstFormat == AV_PIX_FMT_YUV420P16)) ||
+        (srcFormat == AV_PIX_FMT_NV20 &&
+         (dstFormat == AV_PIX_FMT_YUV422P10 ||
+          dstFormat == AV_PIX_FMT_YUV422P12 ||
+          dstFormat == AV_PIX_FMT_YUV422P14 ||
+          dstFormat == AV_PIX_FMT_YUV422P16))) {
+        c->convert_unscaled = nv15_20ToPlanarWrapper;
+    }
     /* yuv2bgr */
     if ((srcFormat == AV_PIX_FMT_YUV420P || srcFormat == AV_PIX_FMT_YUV422P ||
          srcFormat == AV_PIX_FMT_YUVA420P) && isAnyRGB(dstFormat) &&

From 9efe5bcff082d6538702d01c9b7126f40da27361 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 30 May 2024 11:11:35 +0800
Subject: [PATCH 053/103] fixup! lavu: add RKMPP hwcontext

fix the rga fully-planar alignment regression.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index 0c43e7b03f9..8184db11d31 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -182,7 +182,7 @@ static int rkmpp_get_aligned_linesize(enum AVPixelFormat pix_fmt, int width, int
         const int pixel_width = av_get_padded_bits_per_pixel(pixdesc) / 8;
         linesize = FFALIGN(linesize / pixel_width, 8) * pixel_width;
     } else if (is_yuv && is_fully_planar) {
-        linesize = FFALIGN(linesize, 16);
+        linesize = FFALIGN(linesize, 8);
     } else
         linesize = FFALIGN(linesize, 64);
 

From 8164ff7dadd655d78a28340ddc9fcef9af6999bb Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 17 Jul 2024 00:35:05 +0800
Subject: [PATCH 054/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

fix mpeg4 rkmpp hardware decoding.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure             | 2 +-
 libavcodec/rkmppdec.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/configure b/configure
index c0086fe4fe5..666e4d96b6e 100755
--- a/configure
+++ b/configure
@@ -3291,7 +3291,7 @@ mpeg4_omx_encoder_deps="omx"
 mpeg4_v4l2m2m_decoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 mpeg4_v4l2m2m_encoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 mpeg4_rkmpp_decoder_deps="rkmpp"
-mpeg4_rkmpp_decoder_select="mpeg4_unpack_bframes_bsf"
+mpeg4_rkmpp_decoder_select="mpeg4_unpack_bframes_bsf dump_extradata_bsf"
 msmpeg4_crystalhd_decoder_select="crystalhd"
 vc1_crystalhd_decoder_select="crystalhd"
 vc1_cuvid_decoder_deps="cuvid"
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index c6905ce9891..32174c08747 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -961,5 +961,5 @@ DEFINE_RKMPP_DECODER(mpeg1, MPEG1VIDEO, NULL)
 DEFINE_RKMPP_DECODER(mpeg2, MPEG2VIDEO, NULL)
 #endif
 #if CONFIG_MPEG4_RKMPP_DECODER
-DEFINE_RKMPP_DECODER(mpeg4, MPEG4, "mpeg4_unpack_bframes")
+DEFINE_RKMPP_DECODER(mpeg4, MPEG4, "dump_extra,mpeg4_unpack_bframes")
 #endif

From 27443ed8eb5bef454df5c27700144df585b6d561 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 2 Sep 2024 00:35:35 +0800
Subject: [PATCH 055/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

switch to require_pkg_config for librga.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/configure b/configure
index 666e4d96b6e..c2555819ddd 100755
--- a/configure
+++ b/configure
@@ -6923,8 +6923,8 @@ enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp rockchip/rk
                                { enabled libdrm ||
                                  die "ERROR: rkmpp requires --enable-libdrm"; }
                              }
-enabled rkrga             && require rkrga rga/RgaApi.h c_RkRgaBlit -lrga &&
-                             { require rkrga rga/im2d.h querystring -lrga &&
+enabled rkrga             && { require_pkg_config rkrga librga rga/RgaApi.h c_RkRgaBlit &&
+                               require_pkg_config rkrga librga rga/im2d.h querystring &&
                                { enabled rkmpp ||
                                  die "ERROR: rkrga requires --enable-rkmpp"; }
                              }

From 5ddd3d4f5b98c4abd7e2e3633c35ee4a93f2f33e Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Fri, 20 Sep 2024 01:50:24 +0800
Subject: [PATCH 056/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

support keyframe-only decoding: '-skip_frame nokey'

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 15 +++++++++++++++
 libavcodec/rkmppdec.h |  1 +
 2 files changed, 16 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 32174c08747..f50fac3b633 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -115,6 +115,7 @@ static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
     r->draining = 0;
     r->info_change = 0;
     r->errinfo_cnt = 0;
+    r->got_frame = 0;
 
     if (r->mapi) {
         r->mapi->reset(r->mctx);
@@ -212,6 +213,9 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
         goto fail;
     }
 
+    if (avctx->skip_frame == AVDISCARD_NONKEY)
+        r->deint = 0;
+
     if ((ret = r->mapi->control(r->mctx, MPP_DEC_SET_ENABLE_DEINTERLACE, &r->deint)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to set enable deinterlace: %d\n", ret);
         ret = AVERROR_EXTERNAL;
@@ -751,6 +755,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     } else {
         av_log(avctx, AV_LOG_DEBUG, "Received a frame\n");
         r->errinfo_cnt = 0;
+        r->got_frame = 1;
 
         switch (avctx->pix_fmt) {
         case AV_PIX_FMT_DRM_PRIME:
@@ -840,6 +845,15 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
     if (r->draining)
         return AVERROR(EOF);
 
+    /* do not skip non-key pkt until got any frame */
+    if (r->got_frame &&
+        avctx->skip_frame == AVDISCARD_NONKEY &&
+        !(pkt->flags & AV_PKT_FLAG_KEY)) {
+        av_log(avctx, AV_LOG_TRACE, "Skip packet without key flag "
+               "at pts %"PRId64"\n", pkt->pts);
+        return 0;
+    }
+
     if ((ret = mpp_packet_init(&mpp_pkt, pkt->data, pkt->size)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to init packet: %d\n", ret);
         return AVERROR_EXTERNAL;
@@ -930,6 +944,7 @@ static void rkmpp_decode_flush(AVCodecContext *avctx)
         r->draining = 0;
         r->info_change = 0;
         r->errinfo_cnt = 0;
+        r->got_frame = 0;
 
         av_packet_unref(&r->last_pkt);
     } else
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index 0eba15000e4..b5d94b2d881 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -57,6 +57,7 @@ typedef struct RKMPPDecContext {
     int            draining;
     int            info_change;
     int            errinfo_cnt;
+    int            got_frame;
 
     int            deint;
     int            afbc;

From 521affc277903d28f6f304c23eba51f6f7dcb6e3 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 16 Oct 2024 16:26:57 +0800
Subject: [PATCH 057/103] fixup! lavu: add RKMPP hwcontext

add initial support for rk3576

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 18 ++++++++------
 libavutil/hwcontext_rkmpp.h | 49 ++++++++++++++++++++++++++++++++++---
 2 files changed, 56 insertions(+), 11 deletions(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index 8184db11d31..98da3c17e17 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -52,6 +52,7 @@ static const struct {
     { AV_PIX_FMT_NV21,      DRM_FORMAT_NV21,     },
     { AV_PIX_FMT_NV16,      DRM_FORMAT_NV16,     },
     { AV_PIX_FMT_NV24,      DRM_FORMAT_NV24,     },
+    { AV_PIX_FMT_NV42,      DRM_FORMAT_NV42,     },
     /* semi-planar YUV 10-bit */
     { AV_PIX_FMT_P010,      DRM_FORMAT_P010,     },
     { AV_PIX_FMT_P210,      DRM_FORMAT_P210,     },
@@ -96,15 +97,15 @@ static int rkmpp_device_create(AVHWDeviceContext *hwdev, const char *device,
     AVRKMPPDeviceContext *hwctx = hwdev->hwctx;
     AVDictionaryEntry *opt_d = NULL;
 
-    hwctx->flags = MPP_BUFFER_FLAGS_DMA32 | MPP_BUFFER_FLAGS_CACHABLE;
+    hwctx->flags = MPP_BUFFER_FLAGS_DMA32;
 
     opt_d = av_dict_get(opts, "dma32", NULL, 0);
     if (opt_d && !strtol(opt_d->value, NULL, 10))
         hwctx->flags &= ~MPP_BUFFER_FLAGS_DMA32;
 
     opt_d = av_dict_get(opts, "cacheable", NULL, 0);
-    if (opt_d && !strtol(opt_d->value, NULL, 10))
-        hwctx->flags &= ~MPP_BUFFER_FLAGS_CACHABLE;
+    if (opt_d && strtol(opt_d->value, NULL, 10))
+        hwctx->flags |= MPP_BUFFER_FLAGS_CACHABLE;
 
     return 0;
 }
@@ -299,7 +300,8 @@ static int rkmpp_frames_init(AVHWFramesContext *hwfc)
             return AVERROR(ENOMEM);
     }
 
-    ret = mpp_buffer_group_get_internal(&avfc->buf_group, MPP_BUFFER_TYPE_DRM | hwctx->flags);
+    ret = mpp_buffer_group_get_internal(&avfc->buf_group,
+                                        MPP_BUFFER_TYPE_DRM | hwctx->flags | avfc->flags);
     if (ret != MPP_OK) {
         av_log(hwfc, AV_LOG_ERROR, "Failed to get MPP internal buffer group: %d\n", ret);
         return AVERROR_EXTERNAL;
@@ -356,13 +358,13 @@ typedef struct RKMPPDRMMapping {
 static void rkmpp_unmap_frame(AVHWFramesContext *hwfc,
                               HWMapDescriptor *hwmap)
 {
-    AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    AVRKMPPFramesContext *avfc = hwfc->hwctx;
     RKMPPDRMMapping *map = hwmap->priv;
 
     for (int i = 0; i < map->nb_regions; i++) {
 #if HAVE_LINUX_DMA_BUF_H
         struct dma_buf_sync sync = { .flags = DMA_BUF_SYNC_END | map->sync_flags };
-        if (hwctx->flags & MPP_BUFFER_FLAGS_CACHABLE)
+        if (avfc->flags & MPP_BUFFER_FLAGS_CACHABLE)
             ioctl(map->object[i], DMA_BUF_IOCTL_SYNC, &sync);
 #endif
         if (map->address[i] && map->unmap[i])
@@ -375,7 +377,7 @@ static void rkmpp_unmap_frame(AVHWFramesContext *hwfc,
 static int rkmpp_map_frame(AVHWFramesContext *hwfc,
                            AVFrame *dst, const AVFrame *src, int flags)
 {
-    AVRKMPPDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    AVRKMPPFramesContext *avfc = hwfc->hwctx;
     const AVRKMPPDRMFrameDescriptor *desc = (AVRKMPPDRMFrameDescriptor *)src->data[0];
 #if HAVE_LINUX_DMA_BUF_H
     struct dma_buf_sync sync_start = { 0 };
@@ -435,7 +437,7 @@ static int rkmpp_map_frame(AVHWFramesContext *hwfc,
 #if HAVE_LINUX_DMA_BUF_H
         /* We're not checking for errors here because the kernel may not
          * support the ioctl, in which case its okay to carry on */
-        if (hwctx->flags & MPP_BUFFER_FLAGS_CACHABLE)
+        if (avfc->flags & MPP_BUFFER_FLAGS_CACHABLE)
             ioctl(desc->drm_desc.objects[i].fd, DMA_BUF_IOCTL_SYNC, &sync_start);
 #endif
     }
diff --git a/libavutil/hwcontext_rkmpp.h b/libavutil/hwcontext_rkmpp.h
index 3097f275308..75394699c35 100644
--- a/libavutil/hwcontext_rkmpp.h
+++ b/libavutil/hwcontext_rkmpp.h
@@ -47,18 +47,57 @@
 #ifndef DRM_FORMAT_Y210
 #define DRM_FORMAT_Y210         fourcc_code('Y', '2', '1', '0')
 #endif
+#ifndef DRM_FORMAT_VUY888
+#define DRM_FORMAT_VUY888       fourcc_code('V', 'U', '2', '4')
+#endif
 
+/* ARM AFBC (16x16) */
 #ifndef DRM_FORMAT_MOD_VENDOR_ARM
-#define DRM_FORMAT_MOD_VENDOR_ARM 0x08
+#define DRM_FORMAT_MOD_VENDOR_ARM          0x08
 #endif
 #ifndef DRM_FORMAT_MOD_ARM_TYPE_AFBC
-#define DRM_FORMAT_MOD_ARM_TYPE_AFBC 0x00
+#define DRM_FORMAT_MOD_ARM_TYPE_AFBC       0x00
+#endif
+#ifndef AFBC_FORMAT_MOD_BLOCK_SIZE_16x16
+#define AFBC_FORMAT_MOD_BLOCK_SIZE_16x16   (1ULL)
+#endif
+#ifndef AFBC_FORMAT_MOD_SPARSE
+#define AFBC_FORMAT_MOD_SPARSE             (1ULL << 6)
 #endif
 
 #define drm_is_afbc(mod) \
         ((mod >> 52) == (DRM_FORMAT_MOD_ARM_TYPE_AFBC | \
                 (DRM_FORMAT_MOD_VENDOR_ARM << 4)))
 
+/* Rockchip RFBC (64x4) */
+#undef  DRM_FORMAT_MOD_VENDOR_ROCKCHIP
+#define DRM_FORMAT_MOD_VENDOR_ROCKCHIP     0x0b
+#undef  DRM_FORMAT_MOD_ROCKCHIP_TYPE_SHIFT
+#define DRM_FORMAT_MOD_ROCKCHIP_TYPE_SHIFT 52
+#undef  DRM_FORMAT_MOD_ROCKCHIP_TYPE_MASK
+#define DRM_FORMAT_MOD_ROCKCHIP_TYPE_MASK  0xf
+#undef  DRM_FORMAT_MOD_ROCKCHIP_TYPE_RFBC
+#define DRM_FORMAT_MOD_ROCKCHIP_TYPE_RFBC  0x1
+#undef  ROCKCHIP_RFBC_BLOCK_SIZE_64x4
+#define ROCKCHIP_RFBC_BLOCK_SIZE_64x4      (1ULL)
+
+#undef  fourcc_mod_code
+#define fourcc_mod_code(vendor, val) \
+        ((((__u64)DRM_FORMAT_MOD_VENDOR_## vendor) << 56) | ((val) & 0x00ffffffffffffffULL))
+
+#undef  DRM_FORMAT_MOD_ROCKCHIP_CODE
+#define DRM_FORMAT_MOD_ROCKCHIP_CODE(__type, __val) \
+	fourcc_mod_code(ROCKCHIP, ((__u64)(__type) << DRM_FORMAT_MOD_ROCKCHIP_TYPE_SHIFT) | \
+			((__val) & 0x000fffffffffffffULL))
+
+#undef  DRM_FORMAT_MOD_ROCKCHIP_RFBC
+#define DRM_FORMAT_MOD_ROCKCHIP_RFBC(mode) \
+	DRM_FORMAT_MOD_ROCKCHIP_CODE(DRM_FORMAT_MOD_ROCKCHIP_TYPE_RFBC, mode)
+
+#define drm_is_rfbc(mod) \
+        (((mod >> 56) & 0xff) == DRM_FORMAT_MOD_VENDOR_ROCKCHIP) && \
+        (((mod >> 52) & DRM_FORMAT_MOD_ROCKCHIP_TYPE_MASK) == DRM_FORMAT_MOD_ROCKCHIP_TYPE_RFBC)
+
 /**
  * DRM Prime Frame descriptor for RKMPP HWDevice.
  */
@@ -85,6 +124,10 @@ typedef struct AVRKMPPFramesContext {
      * MPP buffer group.
      */
     MppBufferGroup buf_group;
+    /**
+     * MPP buffer allocation flags at frames context level.
+     */
+    int flags;
 
     /**
      * The descriptors of all frames in the pool after creation.
@@ -102,7 +145,7 @@ typedef struct AVRKMPPFramesContext {
  */
 typedef struct AVRKMPPDeviceContext {
     /**
-     * MPP buffer allocation flags.
+     * MPP buffer allocation flags at device context level.
      */
     int flags;
 } AVRKMPPDeviceContext;

From f7617540aacc57cb3bede7de9f9c1c8237bb3e62 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 16 Oct 2024 16:27:25 +0800
Subject: [PATCH 058/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

add initial support for rk3576

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c     | 129 ++++++++++++++++++++++++++-------
 libavfilter/rkrga_common.h     |   9 ++-
 libavfilter/vf_overlay_rkrga.c |   7 +-
 libavfilter/vf_vpp_rkrga.c     |   7 +-
 4 files changed, 116 insertions(+), 36 deletions(-)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 72dbe8c29f4..1e15480e745 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -42,6 +42,9 @@ typedef struct RGAFormatMap {
     enum _Rga_SURF_FORMAT rga_fmt;
 } RGAFormatMap;
 
+#define RK_FORMAT_YCbCr_444_SP (0x32 << 8)
+#define RK_FORMAT_YCrCb_444_SP (0x33 << 8)
+
 #define YUV_FORMATS \
     { AV_PIX_FMT_GRAY8,    RK_FORMAT_YCbCr_400 },        /* RGA2 only */ \
     { AV_PIX_FMT_YUV420P,  RK_FORMAT_YCbCr_420_P },      /* RGA2 only */ \
@@ -49,6 +52,8 @@ typedef struct RGAFormatMap {
     { AV_PIX_FMT_NV12,     RK_FORMAT_YCbCr_420_SP }, \
     { AV_PIX_FMT_NV21,     RK_FORMAT_YCrCb_420_SP }, \
     { AV_PIX_FMT_NV16,     RK_FORMAT_YCbCr_422_SP }, \
+    { AV_PIX_FMT_NV24,     RK_FORMAT_YCbCr_444_SP },     /* RGA2-Pro only */ \
+    { AV_PIX_FMT_NV42,     RK_FORMAT_YCrCb_444_SP },     /* RGA2-Pro only */ \
     { AV_PIX_FMT_P010,     RK_FORMAT_YCbCr_420_SP_10B }, /* RGA3 only */ \
     { AV_PIX_FMT_P210,     RK_FORMAT_YCbCr_422_SP_10B }, /* RGA3 only */ \
     { AV_PIX_FMT_NV15,     RK_FORMAT_YCbCr_420_SP_10B }, /* RGA2 only input, aka P010 compact */ \
@@ -154,6 +159,7 @@ static uint32_t get_drm_afbc_format(enum AVPixelFormat pix_fmt)
     case AV_PIX_FMT_NV15:     return DRM_FORMAT_YUV420_10BIT;
     case AV_PIX_FMT_NV16:     return DRM_FORMAT_YUYV;
     case AV_PIX_FMT_NV20:     return DRM_FORMAT_Y210;
+    case AV_PIX_FMT_NV24:     return DRM_FORMAT_VUY888;
     case AV_PIX_FMT_RGB565LE: return DRM_FORMAT_RGB565;
     case AV_PIX_FMT_BGR565LE: return DRM_FORMAT_BGR565;
     case AV_PIX_FMT_RGB24:    return DRM_FORMAT_RGB888;
@@ -166,6 +172,18 @@ static uint32_t get_drm_afbc_format(enum AVPixelFormat pix_fmt)
     }
 }
 
+static uint32_t get_drm_rfbc_format(enum AVPixelFormat pix_fmt)
+{
+    switch (pix_fmt) {
+    case AV_PIX_FMT_NV12:     return DRM_FORMAT_YUV420_8BIT;
+    case AV_PIX_FMT_NV15:     return DRM_FORMAT_YUV420_10BIT;
+    case AV_PIX_FMT_NV16:     return DRM_FORMAT_YUYV;
+    case AV_PIX_FMT_NV20:     return DRM_FORMAT_Y210;
+    case AV_PIX_FMT_NV24:     return DRM_FORMAT_VUY888;
+    default:                  return DRM_FORMAT_INVALID;
+    }
+}
+
 static int is_pixel_stride_rga3_compat(int ws, int hs,
                                        enum _Rga_SURF_FORMAT fmt)
 {
@@ -339,14 +357,24 @@ static int verify_rga_frame_info_io_dynamic(AVFilterContext *avctx,
                av_get_pix_fmt_name(out->pix_fmt));
         return AVERROR(ENOSYS);
     }
-    if (r->is_rga2_used && in->crop && in->pix_desc->comp[0].depth >= 10) {
-        av_log(avctx, AV_LOG_ERROR, "Cropping 10-bit '%s' input is not supported if RGA2 is requested\n",
+    if (!r->has_rga2p && r->is_rga2_used && in->crop && in->pix_desc->comp[0].depth >= 10) {
+        av_log(avctx, AV_LOG_ERROR, "Cropping 10-bit '%s' input is not supported if RGA2 (non-Pro) is requested\n",
                av_get_pix_fmt_name(in->pix_fmt));
         return AVERROR(ENOSYS);
     }
-    if (r->is_rga2_used &&
+    if (r->is_rga2_used && !r->has_rga2p &&
         (out->act_w > 4096 || out->act_h > 4096)) {
-        av_log(avctx, AV_LOG_ERROR, "Max supported output size of RGA2 is 4096x4096\n");
+        av_log(avctx, AV_LOG_ERROR, "Max supported output size of RGA2 (non-Pro) is 4096x4096\n");
+        return AVERROR(EINVAL);
+    }
+    if (!r->is_rga2_used &&
+        (in->act_w < 68 || in->act_h < 2)) {
+        av_log(avctx, AV_LOG_ERROR, "Min supported input size of RGA3 is 68x2\n");
+        return AVERROR(EINVAL);
+    }
+    if (!r->is_rga2_used &&
+        (out->act_w > 8128 || out->act_h > 8128)) {
+        av_log(avctx, AV_LOG_ERROR, "Max supported output size of RGA3 is 8128x8128\n");
         return AVERROR(EINVAL);
     }
 
@@ -367,7 +395,8 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
     const AVDRMLayerDescriptor *layer;
     const AVDRMPlaneDescriptor *plane0;
     RGAFrame **frame_list = NULL;
-    int ret, is_afbc = 0;
+    int is_afbc = 0, is_rfbc = 0;
+    int ret, is_fbc = 0;
 
     if (pat_preproc && !nb_link)
         return NULL;
@@ -392,7 +421,9 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
         return NULL;
 
     is_afbc = drm_is_afbc(desc->objects[0].format_modifier);
-    if (!is_afbc) {
+    is_rfbc = drm_is_rfbc(desc->objects[0].format_modifier);
+    is_fbc = is_afbc || is_rfbc;
+    if (!is_fbc) {
         ret = get_pixel_stride(&desc->objects[0],
                                &desc->layers[0],
                                (in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB),
@@ -417,8 +448,8 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
         info.blend    = (do_overlay && !pat_preproc) ? in_info->blend_mode : 0;
     }
 
-    if (is_afbc && (r->is_rga2_used || out_info->scheduler_core == 0x4)) {
-        av_log(ctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported by RGA2\n",
+    if (is_fbc && !r->has_rga2p && (r->is_rga2_used || out_info->scheduler_core == 0x4)) {
+        av_log(ctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported by RGA2 (non-Pro)\n",
                av_get_pix_fmt_name(in_info->pix_fmt));
         return NULL;
     }
@@ -450,33 +481,40 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
                      in_info->act_w, in_info->act_h,
                      w_stride, h_stride, in_info->rga_fmt);
 
-    if (is_afbc) {
+    if (is_fbc) {
         int afbc_offset_y = 0;
-        uint32_t drm_afbc_fmt = get_drm_afbc_format(in_info->pix_fmt);
+        int fbc_align_w =
+            is_afbc ? RK_RGA_AFBC_16x16_STRIDE_ALIGN : RK_RGA_RFBC_64x4_STRIDE_ALIGN_W;
+        int fbc_align_h =
+            is_afbc ? RK_RGA_AFBC_16x16_STRIDE_ALIGN : RK_RGA_RFBC_64x4_STRIDE_ALIGN_H;
+        uint32_t drm_fbc_fmt =
+            is_afbc ? get_drm_afbc_format(in_info->pix_fmt) : get_drm_rfbc_format(in_info->pix_fmt);
 
         if (rga_frame->frame->crop_top > 0) {
-            afbc_offset_y = rga_frame->frame->crop_top;
+            afbc_offset_y = is_afbc ? rga_frame->frame->crop_top : 0;
             info.rect.yoffset += afbc_offset_y;
         }
 
         layer = &desc->layers[0];
         plane0 = &layer->planes[0];
-        if (drm_afbc_fmt == layer->format) {
+        if (drm_fbc_fmt == layer->format) {
             info.rect.wstride = plane0->pitch;
             if ((ret = get_afbc_pixel_stride(in_info->bytes_pp, &info.rect.wstride, 1)) < 0)
                 return NULL;
 
-            if (info.rect.wstride % RK_RGA_AFBC_STRIDE_ALIGN)
-                info.rect.wstride = FFALIGN(inlink->w, RK_RGA_AFBC_STRIDE_ALIGN);
+            if (info.rect.wstride % fbc_align_w)
+                info.rect.wstride = FFALIGN(inlink->w, fbc_align_w);
 
-            info.rect.hstride = FFALIGN(inlink->h + afbc_offset_y, RK_RGA_AFBC_STRIDE_ALIGN);
+            info.rect.hstride = FFALIGN(inlink->h + afbc_offset_y, fbc_align_h);
         } else {
-            av_log(ctx, AV_LOG_ERROR, "Input format '%s' with AFBC modifier is not supported\n",
+            av_log(ctx, AV_LOG_ERROR, "Input format '%s' with AFBC/RFBC modifier is not supported\n",
                    av_get_pix_fmt_name(in_info->pix_fmt));
             return NULL;
         }
 
-        info.rd_mode = 1 << 1; /* IM_FBC_MODE */
+        info.rd_mode =
+            is_afbc ? (1 << 1)  /* IM_AFBC16x16_MODE */
+                    : (1 << 4); /* IM_RKFBC64x4_MODE */
     }
 
     rga_frame->info = info;
@@ -532,8 +570,8 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
         goto fail;
 
     if (r->is_rga2_used || out_info->scheduler_core == 0x4) {
-        if (pat_preproc && (info.rect.width > 4096 || info.rect.height > 4096)) {
-            av_log(ctx, AV_LOG_ERROR, "Max supported output size of RGA2 is 4096x4096\n");
+        if (!r->has_rga2p && pat_preproc && (info.rect.width > 4096 || info.rect.height > 4096)) {
+            av_log(ctx, AV_LOG_ERROR, "Max supported output size of RGA2 (non-Pro) is 4096x4096\n");
             goto fail;
         }
         if (r->afbc_out && !pat_preproc) {
@@ -587,8 +625,8 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
             goto exit;
         }
 
-        w_stride = FFALIGN(pat_preproc ? inlink->w : outlink->w, RK_RGA_AFBC_STRIDE_ALIGN);
-        h_stride = FFALIGN(pat_preproc ? inlink->h : outlink->h, RK_RGA_AFBC_STRIDE_ALIGN);
+        w_stride = FFALIGN(pat_preproc ? inlink->w : outlink->w, RK_RGA_AFBC_16x16_STRIDE_ALIGN);
+        h_stride = FFALIGN(pat_preproc ? inlink->h : outlink->h, RK_RGA_AFBC_16x16_STRIDE_ALIGN);
 
         if ((info.rect.format == RK_FORMAT_YCbCr_420_SP_10B ||
              info.rect.format == RK_FORMAT_YCbCr_422_SP_10B) && (w_stride % 64)) {
@@ -610,7 +648,7 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
 
         info.rect.wstride = w_stride;
         info.rect.hstride = h_stride;
-        info.rd_mode = 1 << 1; /* IM_FBC_MODE */
+        info.rd_mode = 1 << 1; /* IM_AFBC16x16_MODE */
 
         desc->objects[0].format_modifier =
             DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
@@ -646,12 +684,19 @@ static av_cold int init_hwframes_ctx(AVFilterContext *avctx)
     AVHWFramesContext *hwfc_in;
     AVHWFramesContext *hwfc_out;
     AVBufferRef       *hwfc_out_ref;
+    AVHWDeviceContext *device_ctx;
+    AVRKMPPFramesContext *rkmpp_fc;
     int                ret;
 
     if (!inlink->hw_frames_ctx)
         return AVERROR(EINVAL);
 
     hwfc_in = (AVHWFramesContext *)inlink->hw_frames_ctx->data;
+    device_ctx = (AVHWDeviceContext *)hwfc_in->device_ref->data;
+
+    if (!device_ctx || device_ctx->type != AV_HWDEVICE_TYPE_RKMPP)
+        return AVERROR(EINVAL);
+
     hwfc_out_ref = av_hwframe_ctx_alloc(hwfc_in->device_ref);
     if (!hwfc_out_ref)
         return AVERROR(ENOMEM);
@@ -662,6 +707,9 @@ static av_cold int init_hwframes_ctx(AVFilterContext *avctx)
     hwfc_out->width     = outlink->w;
     hwfc_out->height    = outlink->h;
 
+    rkmpp_fc = hwfc_out->hwctx;
+    rkmpp_fc->flags |= MPP_BUFFER_FLAGS_CACHABLE;
+
     ret = av_hwframe_ctx_init(hwfc_out_ref);
     if (ret < 0) {
         av_buffer_unref(&hwfc_out_ref);
@@ -683,6 +731,7 @@ static av_cold int init_pat_preproc_hwframes_ctx(AVFilterContext *avctx)
     AVHWFramesContext *hwfc_in0, *hwfc_in1;
     AVHWFramesContext *hwfc_pat;
     AVBufferRef       *hwfc_pat_ref;
+    AVHWDeviceContext *device_ctx0;
     int                ret;
 
     if (!inlink0->hw_frames_ctx || !inlink1->hw_frames_ctx)
@@ -690,6 +739,11 @@ static av_cold int init_pat_preproc_hwframes_ctx(AVFilterContext *avctx)
 
     hwfc_in0 = (AVHWFramesContext *)inlink0->hw_frames_ctx->data;
     hwfc_in1 = (AVHWFramesContext *)inlink1->hw_frames_ctx->data;
+    device_ctx0 = (AVHWDeviceContext *)hwfc_in0->device_ref->data;
+
+    if (!device_ctx0 || device_ctx0->type != AV_HWDEVICE_TYPE_RKMPP)
+        return AVERROR(EINVAL);
+
     hwfc_pat_ref = av_hwframe_ctx_alloc(hwfc_in0->device_ref);
     if (!hwfc_pat_ref)
         return AVERROR(ENOMEM);
@@ -743,6 +797,15 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
                av_get_pix_fmt_name(AV_PIX_FMT_P210));
         return AVERROR(ENOSYS);
     }
+    /* NV24/NV42 requires RGA2-Pro */
+    if (!r->has_rga2p &&
+        (src->pix_fmt == AV_PIX_FMT_NV24 ||
+         dst->pix_fmt == AV_PIX_FMT_NV42)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' and '%s' are only supported by RGA2-Pro\n",
+               av_get_pix_fmt_name(AV_PIX_FMT_NV24),
+               av_get_pix_fmt_name(AV_PIX_FMT_NV42));
+        return AVERROR(ENOSYS);
+    }
     /* Input formats that requires RGA2 */
     if (!r->has_rga2 &&
         (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
@@ -803,11 +866,15 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
     if (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
         src->pix_fmt == AV_PIX_FMT_YUV420P ||
         src->pix_fmt == AV_PIX_FMT_YUV422P ||
+        src->pix_fmt == AV_PIX_FMT_NV24 ||
+        src->pix_fmt == AV_PIX_FMT_NV42 ||
         src->pix_fmt == AV_PIX_FMT_RGB555LE ||
         src->pix_fmt == AV_PIX_FMT_BGR555LE ||
         dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
         dst->pix_fmt == AV_PIX_FMT_YUV420P ||
         dst->pix_fmt == AV_PIX_FMT_YUV422P ||
+        dst->pix_fmt == AV_PIX_FMT_NV24 ||
+        dst->pix_fmt == AV_PIX_FMT_NV42 ||
         dst->pix_fmt == AV_PIX_FMT_RGB555LE ||
         dst->pix_fmt == AV_PIX_FMT_BGR555LE ||
         dst->pix_fmt == AV_PIX_FMT_ARGB ||
@@ -841,8 +908,11 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
     if ((ret = verify_rga_frame_info_io_dynamic(avctx, src, dst)) < 0)
         return ret;
 
-    if (r->is_rga2_used)
+    if (r->is_rga2_used) {
         r->scheduler_core = 0x4;
+        if (r->has_rga2p)
+            r->scheduler_core |= 0x8;
+    }
 
     /* Prioritize RGA3 on multicore RGA hw to avoid dma32 & algorithm quirks as much as possible */
     if (r->has_rga3 && r->has_rga2e && !r->is_rga2_used &&
@@ -918,6 +988,7 @@ av_cold int ff_rkrga_init(AVFilterContext *avctx, RKRGAParam *param)
 {
     RKRGAContext *r = avctx->priv;
     int i, ret;
+    int rga_core_mask = 0x7;
     const char *rga_ver = querystring(RGA_VERSION);
 
     r->got_frame = 0;
@@ -925,6 +996,7 @@ av_cold int ff_rkrga_init(AVFilterContext *avctx, RKRGAParam *param)
     r->has_rga2  = !!strstr(rga_ver, "RGA_2");
     r->has_rga2l = !!strstr(rga_ver, "RGA_2_lite");
     r->has_rga2e = !!strstr(rga_ver, "RGA_2_Enhance");
+    r->has_rga2p = !!strstr(rga_ver, "RGA_2_PRO");
     r->has_rga3  = !!strstr(rga_ver, "RGA_3");
 
     if (!(r->has_rga2 || r->has_rga3)) {
@@ -932,18 +1004,21 @@ av_cold int ff_rkrga_init(AVFilterContext *avctx, RKRGAParam *param)
         return AVERROR(ENOSYS);
     }
 
+    if (r->has_rga2p)
+        rga_core_mask = 0xf;
+
     /* RGA core */
-    if (r->scheduler_core && !(r->has_rga2 && r->has_rga3)) {
+    if (r->scheduler_core && !(r->has_rga2 && r->has_rga3) && !r->has_rga2p) {
         av_log(avctx, AV_LOG_WARNING, "Scheduler core cannot be set on non-multicore RGA hw, ignoring\n");
         r->scheduler_core = 0;
     }
-    if (r->scheduler_core && r->scheduler_core != (r->scheduler_core & 0x7)) {
+    if (r->scheduler_core && r->scheduler_core != (r->scheduler_core & rga_core_mask)) {
         av_log(avctx, AV_LOG_WARNING, "Invalid scheduler core set, ignoring\n");
         r->scheduler_core = 0;
     }
     if (r->scheduler_core && r->scheduler_core == (r->scheduler_core & 0x3))
-        r->has_rga2 = r->has_rga2l = r->has_rga2e = 0;
-    if (r->scheduler_core == 0x4)
+        r->has_rga2 = r->has_rga2l = r->has_rga2e = r->has_rga2p = 0;
+    if (r->scheduler_core == 0x4 && !r->has_rga2p)
         r->has_rga3 = 0;
 
     r->filter_frame = param->filter_frame;
diff --git a/libavfilter/rkrga_common.h b/libavfilter/rkrga_common.h
index 2ce2cebc190..a6988bf2285 100644
--- a/libavfilter/rkrga_common.h
+++ b/libavfilter/rkrga_common.h
@@ -34,10 +34,12 @@
 #include "libavutil/hwcontext.h"
 #include "libavutil/hwcontext_rkmpp.h"
 
-#define ALIGN_DOWN(a, b) ((a) & ~((b)-1))
-#define RK_RGA_YUV_ALIGN         2
-#define RK_RGA_AFBC_STRIDE_ALIGN 16
+#define RK_RGA_YUV_ALIGN                2
+#define RK_RGA_AFBC_16x16_STRIDE_ALIGN  16
+#define RK_RGA_RFBC_64x4_STRIDE_ALIGN_W 64
+#define RK_RGA_RFBC_64x4_STRIDE_ALIGN_H 4
 
+#define ALIGN_DOWN(a, b) ((a) & ~((b)-1))
 #define FF_INLINK_IDX(link)  ((int)((link)->dstpad - (link)->dst->input_pads))
 #define FF_OUTLINK_IDX(link) ((int)((link)->srcpad - (link)->src->output_pads))
 
@@ -90,6 +92,7 @@ typedef struct RKRGAContext {
     int has_rga2;
     int has_rga2l;
     int has_rga2e;
+    int has_rga2p;
     int has_rga3;
     int is_rga2_used;
     int is_overlay_offset_valid;
diff --git a/libavfilter/vf_overlay_rkrga.c b/libavfilter/vf_overlay_rkrga.c
index 18d0ff70b0c..14659a32cc1 100644
--- a/libavfilter/vf_overlay_rkrga.c
+++ b/libavfilter/vf_overlay_rkrga.c
@@ -142,9 +142,9 @@ static av_cold int set_size_info(AVFilterContext *ctx,
 
     outlink->w = r->var_values[VAR_MW];
     outlink->h = r->var_values[VAR_MH];
-    if (outlink->w < 2 || outlink->w > 8128 ||
-        outlink->h < 2 || outlink->h > 8128) {
-        av_log(ctx, AV_LOG_ERROR, "Supported output size is range from 2x2 ~ 8128x8128\n");
+    if (outlink->w < 2 || outlink->w > 8192 ||
+        outlink->h < 2 || outlink->h > 8192) {
+        av_log(ctx, AV_LOG_ERROR, "Supported output size is range from 2x2 ~ 8192x8192\n");
         return AVERROR(EINVAL);
     }
 
@@ -326,6 +326,7 @@ static const AVOption rgaoverlay_options[] = {
         { "rga3_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE0 */
         { "rga3_core1", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE1 */
         { "rga2_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 4 }, 0, 0, FLAGS, "core" }, /* RGA2_SCHEDULER_CORE0 */
+        { "rga2_core1", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 8 }, 0, 0, FLAGS, "core" }, /* RGA2_SCHEDULER_CORE1 */
     { "async_depth", "Set the internal parallelization depth", OFFSET(rga.async_depth), AV_OPT_TYPE_INT, { .i64 = 2 }, 0, 4, .flags = FLAGS },
     { "afbc", "Enable AFBC (Arm Frame Buffer Compression) to save bandwidth", OFFSET(rga.afbc_out), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },
     { NULL },
diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
index 9b39efb1c77..b38226329ac 100644
--- a/libavfilter/vf_vpp_rkrga.c
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -227,9 +227,9 @@ static av_cold int set_size_info(AVFilterContext *ctx,
 
     outlink->w = w;
     outlink->h = h;
-    if (outlink->w < 2 || outlink->w > 8128 ||
-        outlink->h < 2 || outlink->h > 8128) {
-        av_log(ctx, AV_LOG_ERROR, "Supported output size is range from 2x2 ~ 8128x8128\n");
+    if (outlink->w < 2 || outlink->w > 8192 ||
+        outlink->h < 2 || outlink->h > 8192) {
+        av_log(ctx, AV_LOG_ERROR, "Supported output size is range from 2x2 ~ 8192x8192\n");
         return AVERROR(EINVAL);
     }
 
@@ -477,6 +477,7 @@ static av_cold void rgavpp_uninit(AVFilterContext *ctx)
         { "rga3_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE0 */ \
         { "rga3_core1", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, "core" }, /* RGA3_SCHEDULER_CORE1 */ \
         { "rga2_core0", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 4 }, 0, 0, FLAGS, "core" }, /* RGA2_SCHEDULER_CORE0 */ \
+        { "rga2_core1", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 8 }, 0, 0, FLAGS, "core" }, /* RGA2_SCHEDULER_CORE1 */ \
     { "async_depth", "Set the internal parallelization depth", OFFSET(rga.async_depth), AV_OPT_TYPE_INT, { .i64 = 2 }, 0, 4, .flags = FLAGS }, \
     { "afbc", "Enable AFBC (Arm Frame Buffer Compression) to save bandwidth", OFFSET(rga.afbc_out), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },
 

From 4eea7f7fe34e7c4bdf42605079a64271a8e46708 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 16 Oct 2024 16:28:16 +0800
Subject: [PATCH 059/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

add initial support for rk3576

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 89 +++++++++++++++++++++++++++++++++++++------
 libavcodec/rkmppdec.h |  5 ++-
 2 files changed, 81 insertions(+), 13 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index f50fac3b633..86243920986 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -30,6 +30,8 @@
 
 #include "rkmppdec.h"
 
+#include <fcntl.h>
+#include <unistd.h>
 #if CONFIG_RKRGA
 #include <rga/im2d.h>
 #endif
@@ -57,6 +59,7 @@ static uint32_t rkmpp_get_drm_format(MppFrameFormat mpp_fmt)
     case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV15;
     case MPP_FMT_YUV422SP:          return DRM_FORMAT_NV16;
     case MPP_FMT_YUV422SP_10BIT:    return DRM_FORMAT_NV20;
+    case MPP_FMT_YUV444SP:          return DRM_FORMAT_NV24;
     default:                        return DRM_FORMAT_INVALID;
     }
 }
@@ -68,6 +71,7 @@ static uint32_t rkmpp_get_drm_afbc_format(MppFrameFormat mpp_fmt)
     case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_YUV420_10BIT;
     case MPP_FMT_YUV422SP:          return DRM_FORMAT_YUYV;
     case MPP_FMT_YUV422SP_10BIT:    return DRM_FORMAT_Y210;
+    case MPP_FMT_YUV444SP:          return DRM_FORMAT_VUY888;
     default:                        return DRM_FORMAT_INVALID;
     }
 }
@@ -79,6 +83,7 @@ static uint32_t rkmpp_get_av_format(MppFrameFormat mpp_fmt)
     case MPP_FMT_YUV420SP_10BIT:    return AV_PIX_FMT_NV15;
     case MPP_FMT_YUV422SP:          return AV_PIX_FMT_NV16;
     case MPP_FMT_YUV422SP_10BIT:    return AV_PIX_FMT_NV20;
+    case MPP_FMT_YUV444SP:          return AV_PIX_FMT_NV24;
     default:                        return AV_PIX_FMT_NONE;
     }
 }
@@ -107,6 +112,35 @@ static int get_afbc_byte_stride(const AVPixFmtDescriptor *desc,
     return (*stride > 0) ? 0 : AVERROR(EINVAL);
 }
 
+static void read_soc_name(AVCodecContext *avctx, char *name, int size)
+{
+    const char *dt_path = "/proc/device-tree/compatible";
+    int fd = open(dt_path, O_RDONLY);
+
+    if (fd < 0) {
+        av_log(avctx, AV_LOG_VERBOSE, "Unable to open '%s' for reading SoC name\n", dt_path);
+    } else {
+        ssize_t soc_name_len = 0;
+
+        snprintf(name, size - 1, "unknown");
+        soc_name_len = read(fd, name, size - 1);
+        if (soc_name_len > 0) {
+            name[soc_name_len] = '\0';
+            /* replacing the termination character to space */
+            for (char *ptr = name;; ptr = name) {
+                ptr += av_strnlen(name, size);
+                if (ptr >= name + soc_name_len - 1)
+                    break;
+                *ptr = ' ';
+            }
+
+            av_log(avctx, AV_LOG_VERBOSE, "Found SoC name from device-tree: '%s'\n", name);
+        }
+
+        close(fd);
+    }
+}
+
 static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
 {
     RKMPPDecContext *r = avctx->priv_data;
@@ -116,6 +150,7 @@ static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
     r->info_change = 0;
     r->errinfo_cnt = 0;
     r->got_frame = 0;
+    r->use_rfbc = 0;
 
     if (r->mapi) {
         r->mapi->reset(r->mctx);
@@ -141,6 +176,7 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
     RKMPPDecContext *r = avctx->priv_data;
     MppCodingType coding_type = MPP_VIDEO_CodingUnused;
     const char *opts_env = NULL;
+    char soc_name[MAX_SOC_NAME_LENGTH];
     int ret, is_fmt_supported = 0;
     enum AVPixelFormat pix_fmts[3] = { AV_PIX_FMT_DRM_PRIME,
                                        AV_PIX_FMT_NV12,
@@ -153,9 +189,11 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
     case AV_PIX_FMT_YUVJ420P:
+        pix_fmts[1] = AV_PIX_FMT_NV12;
         is_fmt_supported = 1;
         break;
     case AV_PIX_FMT_YUV420P10:
+        pix_fmts[1] = AV_PIX_FMT_NV15;
         is_fmt_supported =
             avctx->codec_id == AV_CODEC_ID_H264 ||
             avctx->codec_id == AV_CODEC_ID_HEVC ||
@@ -163,10 +201,20 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
             avctx->codec_id == AV_CODEC_ID_AV1;
         break;
     case AV_PIX_FMT_YUV422P:
+        pix_fmts[1] = AV_PIX_FMT_NV16;
+        is_fmt_supported =
+            avctx->codec_id == AV_CODEC_ID_H264;
+        break;
     case AV_PIX_FMT_YUV422P10:
+        pix_fmts[1] = AV_PIX_FMT_NV20;
         is_fmt_supported =
             avctx->codec_id == AV_CODEC_ID_H264;
         break;
+    case AV_PIX_FMT_YUV444P:
+        pix_fmts[1] = AV_PIX_FMT_NV24;
+        is_fmt_supported =
+            avctx->codec_id == AV_CODEC_ID_HEVC;
+        break;
     case AV_PIX_FMT_NONE: /* fallback to drm_prime */
         is_fmt_supported = 1;
         avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
@@ -225,16 +273,27 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
     if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME)
         r->afbc = 0;
 
+    if (r->afbc > RKMPP_DEC_AFBC_OFF) {
+        read_soc_name(avctx, soc_name, sizeof(soc_name));
+        r->use_rfbc = !!strstr(soc_name, "rk3576");
+    }
+
     if (r->afbc == RKMPP_DEC_AFBC_ON_RGA) {
 #if CONFIG_RKRGA
         const char *rga_ver = querystring(RGA_VERSION);
-        int has_rga3 = !!strstr(rga_ver, "RGA_3");
-        int is_rga3_compat = avctx->width >= 68 &&
-                             avctx->width <= 8176 &&
-                             avctx->height >= 2 &&
-                             avctx->height <= 8176;
-
-        if (!has_rga3 || !is_rga3_compat) {
+        int has_rga2p = !!strstr(rga_ver, "RGA_2_PRO");
+        int has_rga3  = !!strstr(rga_ver, "RGA_3");
+        int is_rga2p_compat = avctx->width >= 2 &&
+                              avctx->width <= 8192 &&
+                              avctx->height >= 2 &&
+                              avctx->height <= 8192;
+        int is_rga3_compat  = avctx->width >= 68 &&
+                              avctx->width <= 8176 &&
+                              avctx->height >= 2 &&
+                              avctx->height <= 8176;
+
+        r->use_rfbc = r->use_rfbc || has_rga2p;
+        if (!((has_rga2p && is_rga2p_compat) || (has_rga3 && is_rga3_compat))) {
 #endif
             av_log(avctx, AV_LOG_VERBOSE, "AFBC is requested without capable RGA, ignoring\n");
             r->afbc = RKMPP_DEC_AFBC_OFF;
@@ -290,6 +349,7 @@ static int rkmpp_set_buffer_group(AVCodecContext *avctx,
 {
     RKMPPDecContext *r = avctx->priv_data;
     AVHWFramesContext *hwfc = NULL;
+    AVRKMPPFramesContext *rkmpp_fc = NULL;
     int i, ret, decoder_pool_size;
 
     if (!r->hwdevice)
@@ -317,15 +377,15 @@ static int rkmpp_set_buffer_group(AVCodecContext *avctx,
     hwfc->width     = FFALIGN(width,  16);
     hwfc->height    = FFALIGN(height, 16);
 
-    if (r->buf_mode == RKMPP_DEC_HALF_INTERNAL) {
-        AVRKMPPFramesContext *rkmpp_fc = NULL;
+    rkmpp_fc = hwfc->hwctx;
+    rkmpp_fc->flags |= MPP_BUFFER_FLAGS_CACHABLE;
 
+    if (r->buf_mode == RKMPP_DEC_HALF_INTERNAL) {
         if ((ret = av_hwframe_ctx_init(r->hwframe)) < 0) {
             av_log(avctx, AV_LOG_ERROR, "Failed to init RKMPP frame pool\n");
             goto fail;
         }
 
-        rkmpp_fc = hwfc->hwctx;
         r->buf_group = rkmpp_fc->buf_group;
         goto attach;
     } else if (r->buf_mode != RKMPP_DEC_PURE_EXTERNAL) {
@@ -539,7 +599,8 @@ static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mp
 
     if (is_afbc) {
         desc->drm_desc.objects[0].format_modifier =
-            DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
+            r->use_rfbc ? DRM_FORMAT_MOD_ROCKCHIP_RFBC(ROCKCHIP_RFBC_BLOCK_SIZE_64x4)
+                        : DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_BLOCK_SIZE_16x16);
 
         layer->format = rkmpp_get_drm_afbc_format(mpp_fmt);
         layer->nb_planes = 1;
@@ -551,7 +612,7 @@ static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mp
             return ret;
 
         /* MPP specific AFBC src_y offset, not memory address offset */
-        frame->crop_top = mpp_frame_get_offset_y(mpp_frame);
+        frame->crop_top = r->use_rfbc ? 0 : mpp_frame_get_offset_y(mpp_frame);
     } else {
         layer->format = rkmpp_get_drm_format(mpp_fmt);
         layer->nb_planes = 2;
@@ -561,6 +622,9 @@ static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mp
         layer->planes[1].object_index = 0;
         layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mpp_frame);
         layer->planes[1].pitch  = layer->planes[0].pitch;
+
+        if (avctx->sw_pix_fmt == AV_PIX_FMT_NV24)
+            layer->planes[1].pitch *= 2;
     }
 
     if ((ret = frame_create_buf(frame, mpp_frame, mpp_frame_get_buf_size(mpp_frame),
@@ -767,6 +831,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
             break;
         case AV_PIX_FMT_NV12:
         case AV_PIX_FMT_NV16:
+        case AV_PIX_FMT_NV24:
         case AV_PIX_FMT_NV15:
         case AV_PIX_FMT_NV20:
             {
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index b5d94b2d881..d51a40cb969 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -35,12 +35,14 @@
 #include "hwconfig.h"
 #include "internal.h"
 
+#include "libavutil/avstring.h"
 #include "libavutil/hwcontext_rkmpp.h"
 #include "libavutil/mastering_display_metadata.h"
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 
-#define MAX_ERRINFO_COUNT 100
+#define MAX_ERRINFO_COUNT   100
+#define MAX_SOC_NAME_LENGTH 128
 
 typedef struct RKMPPDecContext {
     AVClass       *class;
@@ -58,6 +60,7 @@ typedef struct RKMPPDecContext {
     int            info_change;
     int            errinfo_cnt;
     int            got_frame;
+    int            use_rfbc;
 
     int            deint;
     int            afbc;

From 9d81e50866eb5b6ea941d4a9b8d484b136acb557 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 16 Oct 2024 16:28:38 +0800
Subject: [PATCH 060/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

add initial support for rk3576

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 388b9c3596d..a1b65d332bd 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -259,6 +259,11 @@ static int rkmpp_set_enc_cfg_prep(AVCodecContext *avctx, AVFrame *frame)
 
     pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
     is_afbc = drm_is_afbc(drm_desc->objects[0].format_modifier);
+    if (!is_afbc &&
+        drm_desc->objects[0].format_modifier != DRM_FORMAT_MOD_LINEAR) {
+        av_log(avctx, AV_LOG_ERROR, "Only linear and AFBC modifiers are supported\n");
+        return AVERROR(ENOSYS);
+    }
     if (is_afbc &&
         !(avctx->codec_id == AV_CODEC_ID_H264 ||
           avctx->codec_id == AV_CODEC_ID_HEVC)) {
@@ -532,7 +537,8 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
             return AVERROR_EXTERNAL;
         }
 
-        header_mode = MPP_ENC_HEADER_MODE_EACH_IDR;
+        header_mode = (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)
+                      ? MPP_ENC_HEADER_MODE_DEFAULT : MPP_ENC_HEADER_MODE_EACH_IDR;
         if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_HEADER_MODE, &header_mode)) != MPP_OK) {
             av_log(avctx, AV_LOG_ERROR, "Failed to set header mode: %d\n", ret);
             return AVERROR_EXTERNAL;
@@ -636,6 +642,11 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     plane0 = &layer->planes[0];
 
     is_afbc = drm_is_afbc(drm_desc->objects[0].format_modifier);
+    if (!is_afbc &&
+        drm_desc->objects[0].format_modifier != DRM_FORMAT_MOD_LINEAR) {
+        av_log(avctx, AV_LOG_ERROR, "Only linear and AFBC modifiers are supported\n");
+        goto exit;
+    }
     if (is_afbc &&
         !(avctx->codec_id == AV_CODEC_ID_H264 ||
           avctx->codec_id == AV_CODEC_ID_HEVC)) {

From c5e745e3c16312bfbba9ec4ed83f7e4e82b6ca75 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 23 Oct 2024 21:42:03 +0800
Subject: [PATCH 061/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

fix nv24/nv42 check on rga2p

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 1e15480e745..99ec67c6214 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -800,6 +800,8 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
     /* NV24/NV42 requires RGA2-Pro */
     if (!r->has_rga2p &&
         (src->pix_fmt == AV_PIX_FMT_NV24 ||
+         src->pix_fmt == AV_PIX_FMT_NV42 ||
+         dst->pix_fmt == AV_PIX_FMT_NV24 ||
          dst->pix_fmt == AV_PIX_FMT_NV42)) {
         av_log(avctx, AV_LOG_ERROR, "'%s' and '%s' are only supported by RGA2-Pro\n",
                av_get_pix_fmt_name(AV_PIX_FMT_NV24),

From 57b7952f6ae8497fc8091eb1a0cf33c2a238b50d Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 11 Nov 2024 00:27:52 +0800
Subject: [PATCH 062/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

fix artifacts caused by delayed release of MppPacket data.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 23 ++++++++++-------------
 libavcodec/rkmppenc.h |  2 +-
 2 files changed, 11 insertions(+), 14 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index a1b65d332bd..23fd0f4e045 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -758,12 +758,6 @@ static int rkmpp_send_frame(AVCodecContext *avctx, MPPEncFrame *mpp_enc_frame)
     return ret;
 }
 
-static void rkmpp_free_packet_buf(void *opaque, uint8_t *data)
-{
-    MppPacket mpp_pkt = opaque;
-    mpp_packet_deinit(&mpp_pkt);
-}
-
 static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout)
 {
     RKMPPEncContext *r = avctx->priv_data;
@@ -794,13 +788,15 @@ static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout
     }
     av_log(avctx, AV_LOG_DEBUG, "Received a packet\n");
 
-    packet->data = mpp_packet_get_data(mpp_pkt);
-    packet->size = mpp_packet_get_length(mpp_pkt);
-    packet->buf = av_buffer_create(packet->data, packet->size, rkmpp_free_packet_buf,
-                                   mpp_pkt, AV_BUFFER_FLAG_READONLY);
-    if (!packet->buf) {
-        ret = AVERROR(ENOMEM);
-        goto exit;
+    /* freeing MppPacket data in buffer callbacks is not supported in async mode */
+    {
+        size_t mpp_pkt_length = mpp_packet_get_length(mpp_pkt);
+
+        if ((ret = ff_alloc_packet(avctx, packet, mpp_pkt_length)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "ff_alloc_packet failed: %d\n", ret);
+            goto exit;
+        }
+        memcpy(packet->data, mpp_packet_get_data(mpp_pkt), mpp_pkt_length);
     }
 
     packet->time_base.num = avctx->time_base.num;
@@ -814,6 +810,7 @@ static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout
         ret = AVERROR_EXTERNAL;
         goto exit;
     }
+    mpp_packet_deinit(&mpp_pkt);
 
     mpp_meta_get_s32(mpp_meta, KEY_OUTPUT_INTRA, &key_frame);
     if (key_frame)
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index d90c84ca91c..225dbd2f768 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -244,7 +244,7 @@ static const AVCodecHWConfigInternal *const rkmpp_enc_hw_configs[] = {
 static const FFCodecDefault rkmpp_enc_defaults[] = {
     { "b",  "2M"  },
     { "g",  "250" },
-    { NULL }
+    { NULL },
 };
 
 #define DEFINE_RKMPP_ENCODER(x, X, xx) \

From 22959a80801d5c67e1ca57d34cbc1a021f666bdd Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 11 Nov 2024 15:27:31 +0800
Subject: [PATCH 063/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

fix leaks in mpp_enc_cfg.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 23fd0f4e045..1d243a559b2 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -889,6 +889,11 @@ static int rkmpp_encode_close(AVCodecContext *avctx)
     r->cfg_init = 0;
     r->async_frames = 0;
 
+    if (r->mcfg) {
+        mpp_enc_cfg_deinit(r->mcfg);
+        r->mcfg = NULL;
+    }
+
     if (r->mapi) {
         r->mapi->reset(r->mctx);
         mpp_destroy(r->mctx);

From 841da94b133ae0ded24bf4ae72f08d1cb32d7bcd Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 11 Nov 2024 20:14:12 +0800
Subject: [PATCH 064/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

switch from ff_alloc_packet() to ff_get_encode_buffer().

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 1d243a559b2..4db5579e33c 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -792,8 +792,8 @@ static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout
     {
         size_t mpp_pkt_length = mpp_packet_get_length(mpp_pkt);
 
-        if ((ret = ff_alloc_packet(avctx, packet, mpp_pkt_length)) < 0) {
-            av_log(avctx, AV_LOG_ERROR, "ff_alloc_packet failed: %d\n", ret);
+        if ((ret = ff_get_encode_buffer(avctx, packet, mpp_pkt_length, 0)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "ff_get_encode_buffer failed: %d\n", ret);
             goto exit;
         }
         memcpy(packet->data, mpp_packet_get_data(mpp_pkt), mpp_pkt_length);

From 9dbaf5a69d8f2ecf01d4a09daa5989987b1aede2 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 14 Nov 2024 14:43:52 +0800
Subject: [PATCH 065/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

fix packet deinit too early.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 4db5579e33c..3d96f9f10c9 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -810,7 +810,6 @@ static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout
         ret = AVERROR_EXTERNAL;
         goto exit;
     }
-    mpp_packet_deinit(&mpp_pkt);
 
     mpp_meta_get_s32(mpp_meta, KEY_OUTPUT_INTRA, &key_frame);
     if (key_frame)
@@ -830,6 +829,7 @@ static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout
     mpp_buffer_set_index(mpp_buf, -1);
     clear_unused_frames(r->frame_list);
 
+    mpp_packet_deinit(&mpp_pkt);
     return 0;
 
 exit:

From af480a2e1db9407e59aa6d1077c9007a98b1a178 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 18 Nov 2024 13:08:22 +0800
Subject: [PATCH 066/103] fixup! lavu: add RKMPP hwcontext

fix nv15/nv20 chroma pitch calc.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index 98da3c17e17..e5ee6e1c661 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -172,8 +172,7 @@ static int rkmpp_get_aligned_linesize(enum AVPixelFormat pix_fmt, int width, int
 
     if (pix_fmt == AV_PIX_FMT_NV15 ||
         pix_fmt == AV_PIX_FMT_NV20) {
-        const int log2_chroma_w = plane == 1 ? 1 : 0;
-        const int width_align_256_odds = FFALIGN(width << log2_chroma_w, 256) | 256;
+        const int width_align_256_odds = FFALIGN(width, 256) | 256;
         return FFALIGN(width_align_256_odds * 10 / 8, 64);
     }
 

From 411d2ec5d20b02366cfff95ef53b01ce16370d89 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 19 Nov 2024 16:30:58 +0800
Subject: [PATCH 067/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

fix some missing commas.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index 225dbd2f768..289b714bea6 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -143,7 +143,7 @@ static const AVOption h264_options[] = {
         { "cabac", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, INT_MIN, INT_MAX, VE, "coder" },
     { "8x8dct", "Set the high profile 8x8 transform", OFFSET(dct8x8), AV_OPT_TYPE_BOOL,
             { .i64 = 1 }, 0, 1, VE, "8x8dct" },
-    { NULL }
+    { NULL },
 };
 
 static const AVOption hevc_options[] = {
@@ -170,7 +170,7 @@ static const AVOption hevc_options[] = {
         { "6",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 180 }, 0, 0, VE, "level" },
         { "6.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 183 }, 0, 0, VE, "level" },
         { "6.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 186 }, 0, 0, VE, "level" },
-    { NULL }
+    { NULL },
 };
 
 static const AVOption mjpeg_options[] = {
@@ -180,7 +180,7 @@ static const AVOption mjpeg_options[] = {
             { .i64 = -1 }, -1, 99, VE, "qp_max" }, \
     { "qp_min", "Set the min QP/Q_Factor value", OFFSET(qp_min), AV_OPT_TYPE_INT, \
             { .i64 = -1 }, -1, 99, VE, "qp_min" }, \
-    { NULL }
+    { NULL },
 };
 
 static const enum AVPixelFormat rkmpp_enc_pix_fmts_h26x[] = {

From abfc47f288d10ea9ea4ff05ea4deea5e153ac709 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 19 Nov 2024 16:28:43 +0800
Subject: [PATCH 068/103] fixup! lavu: add RKMPP hwcontext

fix uninitialized hw_frames_ctx of mapped frames.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index e5ee6e1c661..0e06ec8d63d 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -42,7 +42,7 @@ static const struct {
     uint32_t drm_format;
 } supported_formats[] = {
     /* grayscale */
-    { AV_PIX_FMT_GRAY8,     DRM_FORMAT_R8        },
+    { AV_PIX_FMT_GRAY8,     DRM_FORMAT_R8,       },
     /* fully-planar YUV */
     { AV_PIX_FMT_YUV420P,   DRM_FORMAT_YUV420,   },
     { AV_PIX_FMT_YUV422P,   DRM_FORMAT_YUV422,   },
@@ -457,6 +457,7 @@ static int rkmpp_map_frame(AVHWFramesContext *hwfc,
 
     dst->width  = src->width;
     dst->height = src->height;
+    dst->hw_frames_ctx = NULL;
 
     err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,
                                 &rkmpp_unmap_frame, map);

From f22278710e93b84ce97c58505df5c8268fd62d14 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 23 Nov 2024 16:39:50 +0800
Subject: [PATCH 069/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

fix when decoding only a single packet containing an IDR frame.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 86243920986..65fdf468984 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -815,6 +815,12 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
             ret = AVERROR_EXTERNAL;
             goto exit;
         }
+
+        /* no more new pkts after EOS, retry to get frame */
+        if (r->draining) {
+            mpp_frame_deinit(&mpp_frame);
+            return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_MAX);
+        }
         goto exit;
     } else {
         av_log(avctx, AV_LOG_DEBUG, "Received a frame\n");

From b81c3bf1c40bbc34de3950451287fd4f5213bdd3 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 23 Nov 2024 16:40:02 +0800
Subject: [PATCH 070/103] fixup! lavu: add RKMPP hwcontext

fix fully-planar alignment again.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index 0e06ec8d63d..1b90c4357fa 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -182,7 +182,7 @@ static int rkmpp_get_aligned_linesize(enum AVPixelFormat pix_fmt, int width, int
         const int pixel_width = av_get_padded_bits_per_pixel(pixdesc) / 8;
         linesize = FFALIGN(linesize / pixel_width, 8) * pixel_width;
     } else if (is_yuv && is_fully_planar) {
-        linesize = FFALIGN(linesize, 8);
+        linesize = FFALIGN(linesize, 16 >> (plane ? pixdesc->log2_chroma_w : 0));
     } else
         linesize = FFALIGN(linesize, 64);
 

From 56590501f569ab6bed3c5aafe2ca122770474d75 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 20 Jan 2025 19:18:27 +0800
Subject: [PATCH 071/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

refine hw_device_ctx validation.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 65fdf468984..6d556c4d44e 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -322,13 +322,16 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
     }
 
     if (avctx->hw_device_ctx) {
-        r->hwdevice = av_buffer_ref(avctx->hw_device_ctx);
-        if (!r->hwdevice) {
-            ret = AVERROR(ENOMEM);
-            goto fail;
+        AVBufferRef *device_ref = avctx->hw_device_ctx;
+        AVHWDeviceContext *device_ctx = (AVHWDeviceContext *)device_ref->data;
+
+        if (device_ctx && device_ctx->type == AV_HWDEVICE_TYPE_RKMPP) {
+            r->hwdevice = av_buffer_ref(avctx->hw_device_ctx);
+            if (r->hwdevice)
+                av_log(avctx, AV_LOG_VERBOSE, "Picked up an existing RKMPP hardware device\n");
         }
-        av_log(avctx, AV_LOG_VERBOSE, "Picked up an existing RKMPP hardware device\n");
-    } else {
+    }
+    if (!r->hwdevice) {
         if ((ret = av_hwdevice_ctx_create(&r->hwdevice, AV_HWDEVICE_TYPE_RKMPP, NULL, NULL, 0)) < 0) {
             av_log(avctx, AV_LOG_ERROR, "Failed to create a RKMPP hardware device: %d\n", ret);
             goto fail;

From 4ca3b158de868bc1ac28152d5b47ac323c8390f9 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 20 Jan 2025 19:21:44 +0800
Subject: [PATCH 072/103] fixup! lavu: add RKMPP hwcontext

enable some YUVJ formats.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index 1b90c4357fa..cfe2e7019b9 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -45,8 +45,11 @@ static const struct {
     { AV_PIX_FMT_GRAY8,     DRM_FORMAT_R8,       },
     /* fully-planar YUV */
     { AV_PIX_FMT_YUV420P,   DRM_FORMAT_YUV420,   },
+    { AV_PIX_FMT_YUVJ420P,  DRM_FORMAT_YUV420,   },
     { AV_PIX_FMT_YUV422P,   DRM_FORMAT_YUV422,   },
+    { AV_PIX_FMT_YUVJ422P,  DRM_FORMAT_YUV422,   },
     { AV_PIX_FMT_YUV444P,   DRM_FORMAT_YUV444,   },
+    { AV_PIX_FMT_YUVJ444P,  DRM_FORMAT_YUV444,   },
     /* semi-planar YUV */
     { AV_PIX_FMT_NV12,      DRM_FORMAT_NV12,     },
     { AV_PIX_FMT_NV21,      DRM_FORMAT_NV21,     },

From ea8a622db1f92f7480f6f81318608fef9e4a5431 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 20 Jan 2025 19:22:27 +0800
Subject: [PATCH 073/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

enable some YUVJ formats.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 6d556c4d44e..0e2e8577b31 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -201,6 +201,7 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
             avctx->codec_id == AV_CODEC_ID_AV1;
         break;
     case AV_PIX_FMT_YUV422P:
+    case AV_PIX_FMT_YUVJ422P:
         pix_fmts[1] = AV_PIX_FMT_NV16;
         is_fmt_supported =
             avctx->codec_id == AV_CODEC_ID_H264;
@@ -211,6 +212,7 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
             avctx->codec_id == AV_CODEC_ID_H264;
         break;
     case AV_PIX_FMT_YUV444P:
+    case AV_PIX_FMT_YUVJ444P:
         pix_fmts[1] = AV_PIX_FMT_NV24;
         is_fmt_supported =
             avctx->codec_id == AV_CODEC_ID_HEVC;

From 37d4c2129ba7515b56e80ed581597058722da433 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 20 Jan 2025 19:22:55 +0800
Subject: [PATCH 074/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

enable some YUVJ formats.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 18 ++++++++++++++++++
 libavcodec/rkmppenc.h |  4 ++++
 2 files changed, 22 insertions(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 3d96f9f10c9..704d0d98285 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -41,8 +41,11 @@ static MppFrameFormat rkmpp_get_mpp_fmt_h26x(enum AVPixelFormat pix_fmt)
 {
     switch (pix_fmt) {
     case AV_PIX_FMT_GRAY8:   return MPP_FMT_YUV400;
+    case AV_PIX_FMT_YUVJ420P:
     case AV_PIX_FMT_YUV420P: return MPP_FMT_YUV420P;
+    case AV_PIX_FMT_YUVJ422P:
     case AV_PIX_FMT_YUV422P: return MPP_FMT_YUV422P;
+    case AV_PIX_FMT_YUVJ444P:
     case AV_PIX_FMT_YUV444P: return MPP_FMT_YUV444P;
     case AV_PIX_FMT_NV12:    return MPP_FMT_YUV420SP;
     case AV_PIX_FMT_NV21:    return MPP_FMT_YUV420SP_VU;
@@ -68,6 +71,7 @@ static MppFrameFormat rkmpp_get_mpp_fmt_h26x(enum AVPixelFormat pix_fmt)
 static MppFrameFormat rkmpp_get_mpp_fmt_mjpeg(enum AVPixelFormat pix_fmt)
 {
     switch (pix_fmt) {
+    case AV_PIX_FMT_YUVJ420P:
     case AV_PIX_FMT_YUV420P:   return MPP_FMT_YUV420P;
     case AV_PIX_FMT_NV12:      return MPP_FMT_YUV420SP;
     case AV_PIX_FMT_YUYV422:   return MPP_FMT_YUV422_YUYV;
@@ -292,7 +296,13 @@ static int rkmpp_set_enc_cfg_prep(AVCodecContext *avctx, AVFrame *frame)
     mpp_enc_cfg_set_s32(cfg, "prep:colorspace", avctx->colorspace);
     mpp_enc_cfg_set_s32(cfg, "prep:colorprim", avctx->color_primaries);
     mpp_enc_cfg_set_s32(cfg, "prep:colortrc", avctx->color_trc);
+
     mpp_enc_cfg_set_s32(cfg, "prep:colorrange", avctx->color_range);
+    if (r->pix_fmt == AV_PIX_FMT_YUVJ420P ||
+        r->pix_fmt == AV_PIX_FMT_YUVJ422P ||
+        r->pix_fmt == AV_PIX_FMT_YUVJ444P) {
+        mpp_enc_cfg_set_s32(cfg, "prep:colorrange", AVCOL_RANGE_JPEG);
+    }
 
     if (is_afbc) {
         const AVDRMLayerDescriptor *layer = &drm_desc->layers[0];
@@ -615,7 +625,9 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
 
     /* planar YUV quirks */
     if ((r->pix_fmt == AV_PIX_FMT_YUV420P ||
+         r->pix_fmt == AV_PIX_FMT_YUVJ420P ||
          r->pix_fmt == AV_PIX_FMT_YUV422P ||
+         r->pix_fmt == AV_PIX_FMT_YUVJ422P ||
          r->pix_fmt == AV_PIX_FMT_NV24) && (drm_frame->width % 2)) {
         av_log(avctx, AV_LOG_ERROR, "Unsupported width '%d', not 2-aligned\n",
                drm_frame->width);
@@ -636,7 +648,13 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     mpp_frame_set_colorspace(mpp_frame, avctx->colorspace);
     mpp_frame_set_color_primaries(mpp_frame, avctx->color_primaries);
     mpp_frame_set_color_trc(mpp_frame, avctx->color_trc);
+
     mpp_frame_set_color_range(mpp_frame, avctx->color_range);
+    if (r->pix_fmt == AV_PIX_FMT_YUVJ420P ||
+        r->pix_fmt == AV_PIX_FMT_YUVJ422P ||
+        r->pix_fmt == AV_PIX_FMT_YUVJ444P) {
+        mpp_frame_set_color_range(mpp_frame, AVCOL_RANGE_JPEG);
+    }
 
     layer = &drm_desc->layers[0];
     plane0 = &layer->planes[0];
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index 289b714bea6..d7f046fad4b 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -186,8 +186,11 @@ static const AVOption mjpeg_options[] = {
 static const enum AVPixelFormat rkmpp_enc_pix_fmts_h26x[] = {
     AV_PIX_FMT_GRAY8,
     AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_YUVJ420P,
     AV_PIX_FMT_YUV422P,
+    AV_PIX_FMT_YUVJ422P,
     AV_PIX_FMT_YUV444P,
+    AV_PIX_FMT_YUVJ444P,
     AV_PIX_FMT_NV12,
     AV_PIX_FMT_NV21,
     AV_PIX_FMT_NV16,
@@ -211,6 +214,7 @@ static const enum AVPixelFormat rkmpp_enc_pix_fmts_h26x[] = {
 
 static const enum AVPixelFormat rkmpp_enc_pix_fmts_mjpeg[] = {
     AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_YUVJ420P,
     AV_PIX_FMT_NV12,
     AV_PIX_FMT_YUYV422,
     AV_PIX_FMT_UYVY422,

From 4b0e6667111555d907591db9b76798c1e214ea8d Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 20 Jan 2025 19:23:14 +0800
Subject: [PATCH 075/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

enable some YUVJ formats.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c | 31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 99ec67c6214..0019eb81144 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -48,7 +48,9 @@ typedef struct RGAFormatMap {
 #define YUV_FORMATS \
     { AV_PIX_FMT_GRAY8,    RK_FORMAT_YCbCr_400 },        /* RGA2 only */ \
     { AV_PIX_FMT_YUV420P,  RK_FORMAT_YCbCr_420_P },      /* RGA2 only */ \
+    { AV_PIX_FMT_YUVJ420P, RK_FORMAT_YCbCr_420_P },      /* RGA2 only */ \
     { AV_PIX_FMT_YUV422P,  RK_FORMAT_YCbCr_422_P },      /* RGA2 only */ \
+    { AV_PIX_FMT_YUVJ422P, RK_FORMAT_YCbCr_422_P },      /* RGA2 only */ \
     { AV_PIX_FMT_NV12,     RK_FORMAT_YCbCr_420_SP }, \
     { AV_PIX_FMT_NV21,     RK_FORMAT_YCrCb_420_SP }, \
     { AV_PIX_FMT_NV16,     RK_FORMAT_YCbCr_422_SP }, \
@@ -322,6 +324,13 @@ static void set_colorspace_info(RGAFrameInfo *in_info, const AVFrame *in,
             out->color_range     = AVCOL_RANGE_JPEG;
         }
     }
+
+    /* yuvj2yuv */
+    if ((in_info->pix_fmt == AV_PIX_FMT_YUVJ420P ||
+         in_info->pix_fmt == AV_PIX_FMT_YUVJ422P) &&
+        !(out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB)) {
+        out->color_range = AVCOL_RANGE_JPEG;
+    }
 }
 
 static int verify_rga_frame_info_io_dynamic(AVFilterContext *avctx,
@@ -812,7 +821,9 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
     if (!r->has_rga2 &&
         (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
          src->pix_fmt == AV_PIX_FMT_YUV420P ||
+         src->pix_fmt == AV_PIX_FMT_YUVJ420P ||
          src->pix_fmt == AV_PIX_FMT_YUV422P ||
+         src->pix_fmt == AV_PIX_FMT_YUVJ422P ||
          src->pix_fmt == AV_PIX_FMT_RGB555LE ||
          src->pix_fmt == AV_PIX_FMT_BGR555LE)) {
         av_log(avctx, AV_LOG_ERROR, "'%s' as input is only supported by RGA2\n",
@@ -823,7 +834,9 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
     if (!r->has_rga2 &&
         (dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
          dst->pix_fmt == AV_PIX_FMT_YUV420P ||
+         dst->pix_fmt == AV_PIX_FMT_YUVJ420P ||
          dst->pix_fmt == AV_PIX_FMT_YUV422P ||
+         dst->pix_fmt == AV_PIX_FMT_YUVJ422P ||
          dst->pix_fmt == AV_PIX_FMT_RGB555LE ||
          dst->pix_fmt == AV_PIX_FMT_BGR555LE ||
          dst->pix_fmt == AV_PIX_FMT_ARGB ||
@@ -834,12 +847,24 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
                av_get_pix_fmt_name(dst->pix_fmt));
         return AVERROR(ENOSYS);
     }
+    /* non-YUVJ format to YUVJ format is not supported */
+    if ((dst->pix_fmt == AV_PIX_FMT_YUVJ420P ||
+         dst->pix_fmt == AV_PIX_FMT_YUVJ422P) &&
+         (src->pix_fmt != AV_PIX_FMT_YUVJ420P &&
+          src->pix_fmt != AV_PIX_FMT_YUVJ422P)) {
+        av_log(avctx, AV_LOG_ERROR, "'%s' to '%s' is not supported\n",
+               av_get_pix_fmt_name(src->pix_fmt),
+               av_get_pix_fmt_name(dst->pix_fmt));
+        return AVERROR(ENOSYS);
+    }
     /* P010/P210 requires RGA3 but it can't handle certain formats */
     if ((src->pix_fmt == AV_PIX_FMT_P010 ||
          src->pix_fmt == AV_PIX_FMT_P210) &&
          (dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
           dst->pix_fmt == AV_PIX_FMT_YUV420P ||
+          dst->pix_fmt == AV_PIX_FMT_YUVJ420P ||
           dst->pix_fmt == AV_PIX_FMT_YUV422P ||
+          dst->pix_fmt == AV_PIX_FMT_YUVJ422P ||
           dst->pix_fmt == AV_PIX_FMT_RGB555LE ||
           dst->pix_fmt == AV_PIX_FMT_BGR555LE ||
           dst->pix_fmt == AV_PIX_FMT_ARGB ||
@@ -856,7 +881,9 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
          dst->pix_fmt == AV_PIX_FMT_P210) &&
          (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
           src->pix_fmt == AV_PIX_FMT_YUV420P ||
+          src->pix_fmt == AV_PIX_FMT_YUVJ420P ||
           src->pix_fmt == AV_PIX_FMT_YUV422P ||
+          src->pix_fmt == AV_PIX_FMT_YUVJ422P ||
           src->pix_fmt == AV_PIX_FMT_RGB555LE ||
           src->pix_fmt == AV_PIX_FMT_BGR555LE)) {
         av_log(avctx, AV_LOG_ERROR, "'%s' to '%s' is not supported\n",
@@ -867,14 +894,18 @@ static av_cold int verify_rga_frame_info(AVFilterContext *avctx,
 
     if (src->pix_fmt == AV_PIX_FMT_GRAY8 ||
         src->pix_fmt == AV_PIX_FMT_YUV420P ||
+        src->pix_fmt == AV_PIX_FMT_YUVJ420P ||
         src->pix_fmt == AV_PIX_FMT_YUV422P ||
+        src->pix_fmt == AV_PIX_FMT_YUVJ422P ||
         src->pix_fmt == AV_PIX_FMT_NV24 ||
         src->pix_fmt == AV_PIX_FMT_NV42 ||
         src->pix_fmt == AV_PIX_FMT_RGB555LE ||
         src->pix_fmt == AV_PIX_FMT_BGR555LE ||
         dst->pix_fmt == AV_PIX_FMT_GRAY8 ||
         dst->pix_fmt == AV_PIX_FMT_YUV420P ||
+        dst->pix_fmt == AV_PIX_FMT_YUVJ420P ||
         dst->pix_fmt == AV_PIX_FMT_YUV422P ||
+        dst->pix_fmt == AV_PIX_FMT_YUVJ422P ||
         dst->pix_fmt == AV_PIX_FMT_NV24 ||
         dst->pix_fmt == AV_PIX_FMT_NV42 ||
         dst->pix_fmt == AV_PIX_FMT_RGB555LE ||

From ea9247abf49356626bd7e8408c43839e048d6d9d Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Fri, 7 Feb 2025 00:22:02 +0800
Subject: [PATCH 076/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

remove MAX_ERRINFO_COUNT.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 5 +----
 libavcodec/rkmppdec.h | 2 --
 2 files changed, 1 insertion(+), 6 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 0e2e8577b31..3399ca3e75a 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -148,7 +148,6 @@ static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
     r->eof = 0;
     r->draining = 0;
     r->info_change = 0;
-    r->errinfo_cnt = 0;
     r->got_frame = 0;
     r->use_rfbc = 0;
 
@@ -756,7 +755,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     }
     if (mpp_frame_get_errinfo(mpp_frame)) {
         av_log(avctx, AV_LOG_DEBUG, "Received a 'errinfo' frame\n");
-        ret = (r->errinfo_cnt++ > MAX_ERRINFO_COUNT) ? AVERROR_EXTERNAL : AVERROR(EAGAIN);
+        ret = AVERROR(EAGAIN);
         goto exit;
     }
 
@@ -829,7 +828,6 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         goto exit;
     } else {
         av_log(avctx, AV_LOG_DEBUG, "Received a frame\n");
-        r->errinfo_cnt = 0;
         r->got_frame = 1;
 
         switch (avctx->pix_fmt) {
@@ -1019,7 +1017,6 @@ static void rkmpp_decode_flush(AVCodecContext *avctx)
         r->eof = 0;
         r->draining = 0;
         r->info_change = 0;
-        r->errinfo_cnt = 0;
         r->got_frame = 0;
 
         av_packet_unref(&r->last_pkt);
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index d51a40cb969..704cad8e93e 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -41,7 +41,6 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 
-#define MAX_ERRINFO_COUNT   100
 #define MAX_SOC_NAME_LENGTH 128
 
 typedef struct RKMPPDecContext {
@@ -58,7 +57,6 @@ typedef struct RKMPPDecContext {
     int            eof;
     int            draining;
     int            info_change;
-    int            errinfo_cnt;
     int            got_frame;
     int            use_rfbc;
 

From 04f5eaa11c713577e41f201552ff8183af6508bf Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 10 Feb 2025 22:08:49 +0800
Subject: [PATCH 077/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

Remove `dump_extra` bsf from h264/hevc_rkmpp decoder. It causes
issues in some rstp streams, and users have been able to set
the -bsf:v option for video input in FFmpeg 7.0+.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure             | 4 ++--
 libavcodec/rkmppdec.c | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/configure b/configure
index c2555819ddd..829bc217473 100755
--- a/configure
+++ b/configure
@@ -3236,7 +3236,7 @@ h264_omx_encoder_deps="omx"
 h264_qsv_decoder_select="h264_mp4toannexb_bsf qsvdec"
 h264_qsv_encoder_select="atsc_a53 qsvenc"
 h264_rkmpp_decoder_deps="rkmpp"
-h264_rkmpp_decoder_select="h264_mp4toannexb_bsf dump_extradata_bsf"
+h264_rkmpp_decoder_select="h264_mp4toannexb_bsf"
 h264_rkmpp_encoder_deps="rkmpp"
 h264_vaapi_encoder_select="atsc_a53 cbs_h264 vaapi_encode"
 h264_v4l2m2m_decoder_deps="v4l2_m2m h264_v4l2_m2m"
@@ -3255,7 +3255,7 @@ hevc_nvenc_encoder_select="atsc_a53"
 hevc_qsv_decoder_select="hevc_mp4toannexb_bsf qsvdec"
 hevc_qsv_encoder_select="hevcparse qsvenc"
 hevc_rkmpp_decoder_deps="rkmpp"
-hevc_rkmpp_decoder_select="hevc_mp4toannexb_bsf dump_extradata_bsf"
+hevc_rkmpp_decoder_select="hevc_mp4toannexb_bsf"
 hevc_rkmpp_encoder_deps="rkmpp"
 hevc_vaapi_encoder_deps="VAEncPictureParameterBufferHEVC"
 hevc_vaapi_encoder_select="atsc_a53 cbs_h265 vaapi_encode"
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 3399ca3e75a..f77f06a6e7d 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -1028,10 +1028,10 @@ static void rkmpp_decode_flush(AVCodecContext *avctx)
 DEFINE_RKMPP_DECODER(h263, H263, NULL)
 #endif
 #if CONFIG_H264_RKMPP_DECODER
-DEFINE_RKMPP_DECODER(h264, H264, "h264_mp4toannexb,dump_extra")
+DEFINE_RKMPP_DECODER(h264, H264, "h264_mp4toannexb")
 #endif
 #if CONFIG_HEVC_RKMPP_DECODER
-DEFINE_RKMPP_DECODER(hevc, HEVC, "hevc_mp4toannexb,dump_extra")
+DEFINE_RKMPP_DECODER(hevc, HEVC, "hevc_mp4toannexb")
 #endif
 #if CONFIG_VP8_RKMPP_DECODER
 DEFINE_RKMPP_DECODER(vp8, VP8, NULL)

From a7817eed0ba530ad724aee452949dd4b7ae03fc2 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 22 Apr 2025 18:54:35 +0800
Subject: [PATCH 078/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

allow rkrga io on different hwctx.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c     | 36 ++++++++++++++++++++++++++--------
 libavfilter/vf_overlay_rkrga.c |  1 +
 libavfilter/vf_vpp_rkrga.c     |  2 ++
 3 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 0019eb81144..7ca88ccae9b 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -694,6 +694,7 @@ static av_cold int init_hwframes_ctx(AVFilterContext *avctx)
     AVHWFramesContext *hwfc_out;
     AVBufferRef       *hwfc_out_ref;
     AVHWDeviceContext *device_ctx;
+    AVBufferRef       *device_ref;
     AVRKMPPFramesContext *rkmpp_fc;
     int                ret;
 
@@ -701,12 +702,21 @@ static av_cold int init_hwframes_ctx(AVFilterContext *avctx)
         return AVERROR(EINVAL);
 
     hwfc_in = (AVHWFramesContext *)inlink->hw_frames_ctx->data;
-    device_ctx = (AVHWDeviceContext *)hwfc_in->device_ref->data;
+    device_ref = hwfc_in->device_ref;
+    device_ctx = (AVHWDeviceContext *)device_ref->data;
 
-    if (!device_ctx || device_ctx->type != AV_HWDEVICE_TYPE_RKMPP)
-        return AVERROR(EINVAL);
+    if (!device_ctx || device_ctx->type != AV_HWDEVICE_TYPE_RKMPP) {
+        if (avctx->hw_device_ctx) {
+            device_ref = avctx->hw_device_ctx;
+            device_ctx = (AVHWDeviceContext *)device_ref->data;
+        }
+        if (!device_ctx || device_ctx->type != AV_HWDEVICE_TYPE_RKMPP) {
+            av_log(avctx, AV_LOG_ERROR, "No RKMPP hardware context provided\n");
+            return AVERROR(EINVAL);
+        }
+    }
 
-    hwfc_out_ref = av_hwframe_ctx_alloc(hwfc_in->device_ref);
+    hwfc_out_ref = av_hwframe_ctx_alloc(device_ref);
     if (!hwfc_out_ref)
         return AVERROR(ENOMEM);
 
@@ -741,6 +751,7 @@ static av_cold int init_pat_preproc_hwframes_ctx(AVFilterContext *avctx)
     AVHWFramesContext *hwfc_pat;
     AVBufferRef       *hwfc_pat_ref;
     AVHWDeviceContext *device_ctx0;
+    AVBufferRef       *device_ref0;
     int                ret;
 
     if (!inlink0->hw_frames_ctx || !inlink1->hw_frames_ctx)
@@ -748,12 +759,21 @@ static av_cold int init_pat_preproc_hwframes_ctx(AVFilterContext *avctx)
 
     hwfc_in0 = (AVHWFramesContext *)inlink0->hw_frames_ctx->data;
     hwfc_in1 = (AVHWFramesContext *)inlink1->hw_frames_ctx->data;
-    device_ctx0 = (AVHWDeviceContext *)hwfc_in0->device_ref->data;
+    device_ref0 = hwfc_in0->device_ref;
+    device_ctx0 = (AVHWDeviceContext *)device_ref0->data;
 
-    if (!device_ctx0 || device_ctx0->type != AV_HWDEVICE_TYPE_RKMPP)
-        return AVERROR(EINVAL);
+    if (!device_ctx0 || device_ctx0->type != AV_HWDEVICE_TYPE_RKMPP) {
+        if (avctx->hw_device_ctx) {
+            device_ref0 = avctx->hw_device_ctx;
+            device_ctx0 = (AVHWDeviceContext *)device_ref0->data;
+        }
+        if (!device_ctx0 || device_ctx0->type != AV_HWDEVICE_TYPE_RKMPP) {
+            av_log(avctx, AV_LOG_ERROR, "No RKMPP hardware context provided\n");
+            return AVERROR(EINVAL);
+        }
+    }
 
-    hwfc_pat_ref = av_hwframe_ctx_alloc(hwfc_in0->device_ref);
+    hwfc_pat_ref = av_hwframe_ctx_alloc(device_ref0);
     if (!hwfc_pat_ref)
         return AVERROR(ENOMEM);
 
diff --git a/libavfilter/vf_overlay_rkrga.c b/libavfilter/vf_overlay_rkrga.c
index 14659a32cc1..8f36af5cb22 100644
--- a/libavfilter/vf_overlay_rkrga.c
+++ b/libavfilter/vf_overlay_rkrga.c
@@ -366,4 +366,5 @@ const AVFilter ff_vf_overlay_rkrga = {
     FILTER_SINGLE_PIXFMT(AV_PIX_FMT_DRM_PRIME),
     .preinit        = rgaoverlay_framesync_preinit,
     .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+    .flags          = AVFILTER_FLAG_HWDEVICE,
 };
diff --git a/libavfilter/vf_vpp_rkrga.c b/libavfilter/vf_vpp_rkrga.c
index b38226329ac..9c6515876bd 100644
--- a/libavfilter/vf_vpp_rkrga.c
+++ b/libavfilter/vf_vpp_rkrga.c
@@ -534,6 +534,7 @@ const AVFilter ff_vf_scale_rkrga = {
     FILTER_SINGLE_PIXFMT(AV_PIX_FMT_DRM_PRIME),
     .activate       = rgavpp_activate,
     .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+    .flags          = AVFILTER_FLAG_HWDEVICE,
 };
 
 #endif
@@ -574,6 +575,7 @@ const AVFilter ff_vf_vpp_rkrga = {
     FILTER_SINGLE_PIXFMT(AV_PIX_FMT_DRM_PRIME),
     .activate       = rgavpp_activate,
     .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+    .flags          = AVFILTER_FLAG_HWDEVICE,
 };
 
 #endif

From 5898b091ee6f7d833fa704cdde7a951df8e1b600 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 22 Apr 2025 19:19:30 +0800
Subject: [PATCH 079/103] lavc/rkmppenc: add UDU SEI support for H26x encoders

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 82 ++++++++++++++++++++++++++++++++++++++++++-
 libavcodec/rkmppenc.h | 12 +++++++
 2 files changed, 93 insertions(+), 1 deletion(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 704d0d98285..c3ff07deb08 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -182,6 +182,9 @@ static void clear_unused_frames(MPPEncFrame *list)
                 mpp_frame_deinit(&list->mpp_frame);
                 list->mpp_frame = NULL;
 
+                av_freep(&list->mpp_sei);
+                list->mpp_sei_sz = 0;
+
                 av_frame_free(&list->frame);
                 list->queued = 0;
             }
@@ -211,6 +214,9 @@ static void clear_frame_list(MPPEncFrame **list)
             frame->mpp_frame = NULL;
         }
 
+        av_freep(&frame->mpp_sei);
+        frame->mpp_sei_sz = 0;
+
         av_frame_free(&frame->frame);
         av_freep(&frame);
     }
@@ -492,6 +498,8 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
             mpp_enc_cfg_set_s32(cfg, "h264:trans8x8",
                                 (r->dct8x8 && avctx->profile == AV_PROFILE_H264_HIGH));
 
+            mpp_enc_cfg_set_s32(cfg, "h264:prefix_mode", r->prefix_mode);
+
             switch (avctx->profile) {
             case AV_PROFILE_H264_BASELINE:
                 av_log(avctx, AV_LOG_VERBOSE, "Profile is set to BASELINE\n"); break;
@@ -541,7 +549,7 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
 
     if (avctx->codec_id == AV_CODEC_ID_H264 ||
         avctx->codec_id == AV_CODEC_ID_HEVC) {
-        sei_mode = MPP_ENC_SEI_MODE_DISABLE;
+        sei_mode = r->udu_sei ? MPP_ENC_SEI_MODE_ONE_FRAME : MPP_ENC_SEI_MODE_DISABLE;
         if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_SEI_CFG, &sei_mode)) != MPP_OK) {
             av_log(avctx, AV_LOG_ERROR, "Failed to set SEI config: %d\n", ret);
             return AVERROR_EXTERNAL;
@@ -558,6 +566,70 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
     return 0;
 }
 
+static int rkmpp_prepare_udu_sei_data(AVCodecContext *avctx, MPPEncFrame *mpp_enc_frame)
+{
+    int i, ret, sei_count = 0;
+
+    if (!mpp_enc_frame ||
+        !mpp_enc_frame->frame ||
+        !mpp_enc_frame->mpp_frame)
+        return AVERROR(EINVAL);
+
+    /* user data unregistered SEI of H26X */
+    for (i = 0; i < mpp_enc_frame->frame->nb_side_data; i++) {
+        AVFrameSideData *sd = mpp_enc_frame->frame->side_data[i];
+        uint8_t *user_data = sd->data;
+        void *buf = NULL;
+
+        if (sd->type != AV_FRAME_DATA_SEI_UNREGISTERED)
+            continue;
+
+        if (sd->size < AV_UUID_LEN) {
+            av_log(avctx, AV_LOG_WARNING, "Invalid UDU SEI data: "
+                   "(%"SIZE_SPECIFIER" < UUID(%d-bytes)), skipping\n",
+                   sd->size, AV_UUID_LEN);
+            continue;
+        }
+
+        buf = av_fast_realloc(mpp_enc_frame->mpp_sei,
+                              &mpp_enc_frame->mpp_sei_sz,
+                              (sei_count + 1) * sizeof(*(mpp_enc_frame->mpp_sei)));
+        if (!buf) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to realloc UDU SEI buffer\n");
+            return AVERROR(ENOMEM);
+        } else {
+            mpp_enc_frame->mpp_sei = buf;
+
+            mpp_enc_frame->mpp_sei[sei_count].len   = sd->size - AV_UUID_LEN;
+            mpp_enc_frame->mpp_sei[sei_count].uuid  = (RK_U8 *)user_data;
+            mpp_enc_frame->mpp_sei[sei_count].pdata = &user_data[AV_UUID_LEN];
+
+            ++sei_count;
+        }
+    }
+
+    if (sei_count > 0) {
+        MppMeta mpp_meta = NULL;
+        MppEncUserDataSet *mpp_sei_set = &mpp_enc_frame->mpp_sei_set;
+
+        mpp_sei_set->datas = mpp_enc_frame->mpp_sei;
+        mpp_sei_set->count = sei_count;
+
+        mpp_meta = mpp_frame_get_meta(mpp_enc_frame->mpp_frame);
+        if (!mpp_meta) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get frame meta\n");
+            return AVERROR_EXTERNAL;
+        }
+        if ((ret = mpp_meta_set_ptr(mpp_meta, KEY_USER_DATAS,
+                                    mpp_sei_set)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to set the UDU SEI datas ptr\n");
+            return AVERROR_EXTERNAL;
+        }
+    }
+
+    return 0;
+}
+
 static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
 {
     RKMPPEncContext *r = avctx->priv_data;
@@ -728,6 +800,14 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
     mpp_frame_set_buffer(mpp_frame, mpp_buf);
     mpp_frame_set_buf_size(mpp_frame, drm_desc->objects[0].size);
 
+    if (r->udu_sei &&
+        (avctx->codec_id == AV_CODEC_ID_H264 ||
+         avctx->codec_id == AV_CODEC_ID_HEVC)) {
+        ret = rkmpp_prepare_udu_sei_data(avctx, mpp_enc_frame);
+        if (ret < 0)
+            goto exit;
+    }
+
     return mpp_enc_frame;
 
 exit:
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index d7f046fad4b..80c9d3500f3 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -37,6 +37,7 @@
 #include "libavutil/hwcontext_rkmpp.h"
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
+#include "libavutil/uuid.h"
 
 #define H26X_HEADER_SIZE   1024
 #define H26X_ASYNC_FRAMES  4
@@ -46,6 +47,9 @@
 typedef struct MPPEncFrame {
     AVFrame            *frame;
     MppFrame            mpp_frame;
+    MppEncUserDataSet   mpp_sei_set;
+    MppEncUserDataFull *mpp_sei;
+    int                 mpp_sei_sz;
     struct MPPEncFrame *next;
     int                 queued;
 } MPPEncFrame;
@@ -78,6 +82,8 @@ typedef struct RKMPPEncContext {
     int                level;
     int                coder;
     int                dct8x8;
+    int                udu_sei;
+    int                prefix_mode;
 } RKMPPEncContext;
 
 static const AVRational mpp_tb = { 1, 1000000 };
@@ -143,6 +149,10 @@ static const AVOption h264_options[] = {
         { "cabac", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, INT_MIN, INT_MAX, VE, "coder" },
     { "8x8dct", "Set the high profile 8x8 transform", OFFSET(dct8x8), AV_OPT_TYPE_BOOL,
             { .i64 = 1 }, 0, 1, VE, "8x8dct" },
+    { "udu_sei", "Pass on user data unregistered SEI if available", OFFSET(udu_sei), AV_OPT_TYPE_BOOL,
+            { .i64 = 0 }, 0, 1, VE, "udu_sei" },
+    { "prefix_mode", "Add prefix NAL between SEI info and encoded bitstream data", OFFSET(prefix_mode), AV_OPT_TYPE_BOOL,
+            { .i64 = 0 }, 0, 1, VE, "prefix_mode" },
     { NULL },
 };
 
@@ -170,6 +180,8 @@ static const AVOption hevc_options[] = {
         { "6",          NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 180 }, 0, 0, VE, "level" },
         { "6.1",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 183 }, 0, 0, VE, "level" },
         { "6.2",        NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 186 }, 0, 0, VE, "level" },
+    { "udu_sei", "Pass on user data unregistered SEI if available", OFFSET(udu_sei), AV_OPT_TYPE_BOOL,
+            { .i64 = 0 }, 0, 1, VE, "udu_sei" },
     { NULL },
 };
 

From 57d5befee96f229b05fa09334a4d7a6f95a324bd Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 22 Apr 2025 20:52:00 +0800
Subject: [PATCH 080/103] fixup! lavc/rkmppenc: add UDU SEI support for H26x
 encoders

polish the udu-sei impl.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 35 +++++++++++++++--------------------
 libavcodec/rkmppenc.h |  2 --
 2 files changed, 15 insertions(+), 22 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index c3ff07deb08..c0d9def16f9 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -182,8 +182,8 @@ static void clear_unused_frames(MPPEncFrame *list)
                 mpp_frame_deinit(&list->mpp_frame);
                 list->mpp_frame = NULL;
 
-                av_freep(&list->mpp_sei);
-                list->mpp_sei_sz = 0;
+                av_freep(&list->mpp_sei_set.datas);
+                list->mpp_sei_set.count = 0;
 
                 av_frame_free(&list->frame);
                 list->queued = 0;
@@ -214,8 +214,8 @@ static void clear_frame_list(MPPEncFrame **list)
             frame->mpp_frame = NULL;
         }
 
-        av_freep(&frame->mpp_sei);
-        frame->mpp_sei_sz = 0;
+        av_freep(&frame->mpp_sei_set.datas);
+        frame->mpp_sei_set.count = 0;
 
         av_frame_free(&frame->frame);
         av_freep(&frame);
@@ -577,6 +577,7 @@ static int rkmpp_prepare_udu_sei_data(AVCodecContext *avctx, MPPEncFrame *mpp_en
 
     /* user data unregistered SEI of H26X */
     for (i = 0; i < mpp_enc_frame->frame->nb_side_data; i++) {
+        MppEncUserDataSet *mpp_sei_set = &mpp_enc_frame->mpp_sei_set;
         AVFrameSideData *sd = mpp_enc_frame->frame->side_data[i];
         uint8_t *user_data = sd->data;
         void *buf = NULL;
@@ -591,37 +592,31 @@ static int rkmpp_prepare_udu_sei_data(AVCodecContext *avctx, MPPEncFrame *mpp_en
             continue;
         }
 
-        buf = av_fast_realloc(mpp_enc_frame->mpp_sei,
-                              &mpp_enc_frame->mpp_sei_sz,
-                              (sei_count + 1) * sizeof(*(mpp_enc_frame->mpp_sei)));
+        buf = av_fast_realloc(mpp_sei_set->datas,
+                              &mpp_sei_set->count,
+                              (sei_count + 1) * sizeof(*(mpp_sei_set->datas)));
         if (!buf) {
             av_log(avctx, AV_LOG_ERROR, "Failed to realloc UDU SEI buffer\n");
             return AVERROR(ENOMEM);
         } else {
-            mpp_enc_frame->mpp_sei = buf;
+            mpp_sei_set->datas = (MppEncUserDataFull *)buf;
 
-            mpp_enc_frame->mpp_sei[sei_count].len   = sd->size - AV_UUID_LEN;
-            mpp_enc_frame->mpp_sei[sei_count].uuid  = (RK_U8 *)user_data;
-            mpp_enc_frame->mpp_sei[sei_count].pdata = &user_data[AV_UUID_LEN];
+            mpp_sei_set->datas[sei_count].len   = sd->size - AV_UUID_LEN;
+            mpp_sei_set->datas[sei_count].uuid  = (RK_U8 *)user_data;
+            mpp_sei_set->datas[sei_count].pdata = &user_data[AV_UUID_LEN];
 
-            ++sei_count;
+            mpp_sei_set->count = ++sei_count;
         }
     }
 
     if (sei_count > 0) {
-        MppMeta mpp_meta = NULL;
-        MppEncUserDataSet *mpp_sei_set = &mpp_enc_frame->mpp_sei_set;
-
-        mpp_sei_set->datas = mpp_enc_frame->mpp_sei;
-        mpp_sei_set->count = sei_count;
-
-        mpp_meta = mpp_frame_get_meta(mpp_enc_frame->mpp_frame);
+        MppMeta mpp_meta = mpp_frame_get_meta(mpp_enc_frame->mpp_frame);
         if (!mpp_meta) {
             av_log(avctx, AV_LOG_ERROR, "Failed to get frame meta\n");
             return AVERROR_EXTERNAL;
         }
         if ((ret = mpp_meta_set_ptr(mpp_meta, KEY_USER_DATAS,
-                                    mpp_sei_set)) != MPP_OK) {
+                                    &mpp_enc_frame->mpp_sei_set)) != MPP_OK) {
             av_log(avctx, AV_LOG_ERROR, "Failed to set the UDU SEI datas ptr\n");
             return AVERROR_EXTERNAL;
         }
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index 80c9d3500f3..a857de85515 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -48,8 +48,6 @@ typedef struct MPPEncFrame {
     AVFrame            *frame;
     MppFrame            mpp_frame;
     MppEncUserDataSet   mpp_sei_set;
-    MppEncUserDataFull *mpp_sei;
-    int                 mpp_sei_sz;
     struct MPPEncFrame *next;
     int                 queued;
 } MPPEncFrame;

From 202fd767e2b6555eec4d2af270d675cfea9d6453 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 31 May 2025 17:57:55 +0800
Subject: [PATCH 081/103] lavf/rkrga: add alpha_format options for overlay
 filter

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c     | 9 ++++++---
 libavfilter/rkrga_common.h     | 1 +
 libavfilter/vf_overlay_rkrga.c | 5 +++++
 3 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 7ca88ccae9b..82b2f53ef6e 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -1114,15 +1114,18 @@ av_cold int ff_rkrga_init(AVFilterContext *avctx, RKRGAParam *param)
         }
     }
     if (avctx->nb_inputs > 1) {
-        const int premultiplied_alpha = r->in_rga_frame_infos[1].pix_desc->flags & AV_PIX_FMT_FLAG_ALPHA;
+        int need_premultiply = 0;
+
+        if (r->in_rga_frame_infos[1].pix_desc->flags & AV_PIX_FMT_FLAG_ALPHA)
+            need_premultiply = param->in_alpha_format == 0;
 
         /* IM_ALPHA_BLEND_DST_OVER */
         if (param->in_global_alpha > 0 && param->in_global_alpha < 0xff) {
-            r->in_rga_frame_infos[0].blend_mode = premultiplied_alpha ? (0x4 | (1 << 12)) : 0x4;
+            r->in_rga_frame_infos[0].blend_mode = need_premultiply ? (0x4 | (1 << 12)) : 0x4;
             r->in_rga_frame_infos[0].blend_mode |= (param->in_global_alpha & 0xff) << 16; /* fg_global_alpha */
             r->in_rga_frame_infos[0].blend_mode |= 0xff << 24;                            /* bg_global_alpha */
         } else
-            r->in_rga_frame_infos[0].blend_mode = premultiplied_alpha ? 0x504 : 0x501;
+            r->in_rga_frame_infos[0].blend_mode = need_premultiply ? 0x504 : 0x501;
 
         r->in_rga_frame_infos[1].overlay_x = FFMAX(param->overlay_x, 0);
         r->in_rga_frame_infos[1].overlay_y = FFMAX(param->overlay_y, 0);
diff --git a/libavfilter/rkrga_common.h b/libavfilter/rkrga_common.h
index a6988bf2285..9e884773308 100644
--- a/libavfilter/rkrga_common.h
+++ b/libavfilter/rkrga_common.h
@@ -110,6 +110,7 @@ typedef struct RKRGAParam {
 
     int in_rotate_mode;
     int in_global_alpha;
+    int in_alpha_format;
 
     int in_crop;
     int in_crop_x;
diff --git a/libavfilter/vf_overlay_rkrga.c b/libavfilter/vf_overlay_rkrga.c
index 8f36af5cb22..15fd71ef47c 100644
--- a/libavfilter/vf_overlay_rkrga.c
+++ b/libavfilter/vf_overlay_rkrga.c
@@ -52,6 +52,7 @@ typedef struct RGAOverlayContext {
     double var_values[VAR_VARS_NB];
     char *overlay_ox, *overlay_oy;
     int global_alpha;
+    int alpha_format;
     enum AVPixelFormat format;
 } RGAOverlayContext;
 
@@ -195,6 +196,7 @@ static av_cold int rgaoverlay_config_props(AVFilterLink *outlink)
     param.filter_frame    = NULL;
     param.out_sw_format   = out_format;
     param.in_global_alpha = r->global_alpha;
+    param.in_alpha_format = r->alpha_format;
     param.overlay_x       = r->var_values[VAR_OX];
     param.overlay_y       = r->var_values[VAR_OY];
 
@@ -312,6 +314,9 @@ static const AVOption rgaoverlay_options[] = {
     { "x", "Overlay x position", OFFSET(overlay_ox), AV_OPT_TYPE_STRING, { .str = "0" }, 0, 0, .flags = FLAGS },
     { "y", "Overlay y position", OFFSET(overlay_oy), AV_OPT_TYPE_STRING, { .str = "0" }, 0, 0, .flags = FLAGS },
     { "alpha", "Overlay global alpha", OFFSET(global_alpha), AV_OPT_TYPE_INT, { .i64 = 255 }, 0, 255, .flags = FLAGS },
+    { "alpha_format", "alpha format", OFFSET(alpha_format), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, FLAGS, "alpha_format" },
+        { "straight",      "The overlay input is unpremultiplied", 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, .flags = FLAGS, "alpha_format" },
+        { "premultiplied", "The overlay input is premultiplied",   0, AV_OPT_TYPE_CONST, { .i64 = 1 }, .flags = FLAGS, "alpha_format" },
     { "format", "Output video pixel format", OFFSET(format), AV_OPT_TYPE_PIXEL_FMT, { .i64 = AV_PIX_FMT_NONE }, INT_MIN, INT_MAX, .flags = FLAGS },
     { "eof_action", "Action to take when encountering EOF from secondary input ",
         OFFSET(fs.opt_eof_action), AV_OPT_TYPE_INT, { .i64 = EOF_ACTION_REPEAT },

From 0bf5184715e836d9a2627a1138ee911c2abcb702 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 31 May 2025 17:58:40 +0800
Subject: [PATCH 082/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

fix VUI full range flag in RKMPP encoded videos.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index c0d9def16f9..07a2523edcc 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -357,6 +357,17 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
     mpp_enc_cfg_set_s32(cfg, "prep:rotation", 0);
     mpp_enc_cfg_set_s32(cfg, "prep:flip", 0);
 
+    mpp_enc_cfg_set_s32(cfg, "prep:colorspace", avctx->colorspace);
+    mpp_enc_cfg_set_s32(cfg, "prep:colorprim", avctx->color_primaries);
+    mpp_enc_cfg_set_s32(cfg, "prep:colortrc", avctx->color_trc);
+
+    mpp_enc_cfg_set_s32(cfg, "prep:colorrange", avctx->color_range);
+    if (r->pix_fmt == AV_PIX_FMT_YUVJ420P ||
+        r->pix_fmt == AV_PIX_FMT_YUVJ422P ||
+        r->pix_fmt == AV_PIX_FMT_YUVJ444P) {
+        mpp_enc_cfg_set_s32(cfg, "prep:colorrange", AVCOL_RANGE_JPEG);
+    }
+
     if (avctx->framerate.den > 0 && avctx->framerate.num > 0)
         av_reduce(&fps_num, &fps_den, avctx->framerate.num, avctx->framerate.den, 65535);
     else

From 1a12af1ad3340236ab2021d3e233d583fd8cb967 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 31 May 2025 17:59:19 +0800
Subject: [PATCH 083/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

handle NOPTS in RKMPP decoders.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 28 ++++++++++++++++++++++++++--
 libavcodec/rkmppdec.h |  1 +
 2 files changed, 27 insertions(+), 2 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index f77f06a6e7d..b684c232cb8 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -145,6 +145,7 @@ static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
 {
     RKMPPDecContext *r = avctx->priv_data;
 
+    r->last_pts = AV_NOPTS_VALUE;
     r->eof = 0;
     r->draining = 0;
     r->info_change = 0;
@@ -912,7 +913,8 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
 {
     RKMPPDecContext *r = avctx->priv_data;
     MppPacket mpp_pkt = NULL;
-    int64_t pts = PTS_TO_MPP_PTS(pkt->pts, avctx->pkt_timebase);
+    int64_t mpp_pkt_pts = PTS_TO_MPP_PTS(pkt->pts, avctx->pkt_timebase);
+    int64_t last_pts = r->last_pts;
     int ret;
 
     /* avoid sending new data after EOS */
@@ -928,17 +930,39 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
         return 0;
     }
 
+    /* make up some pts if it's not available from pkt */
+    if (pkt->pts == AV_NOPTS_VALUE) {
+        int64_t pts_diff = 1;
+        AVRational framerate = { avctx->framerate.num,
+                                 avctx->framerate.den };
+
+        if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) {
+            if (!(framerate.num && framerate.den)) {
+                framerate.num = 25;
+                framerate.den = 1;
+            }
+            pts_diff = (avctx->pkt_timebase.den * framerate.den) /
+                       (avctx->pkt_timebase.num * framerate.num);
+        }
+        last_pts += pts_diff;
+
+        mpp_pkt_pts = PTS_TO_MPP_PTS(last_pts, avctx->pkt_timebase);
+    }
+
     if ((ret = mpp_packet_init(&mpp_pkt, pkt->data, pkt->size)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to init packet: %d\n", ret);
         return AVERROR_EXTERNAL;
     }
-    mpp_packet_set_pts(mpp_pkt, pts);
+    mpp_packet_set_pts(mpp_pkt, mpp_pkt_pts);
 
     if ((ret = r->mapi->decode_put_packet(r->mctx, mpp_pkt)) != MPP_OK) {
         av_log(avctx, AV_LOG_TRACE, "Decoder buffer is full\n");
         mpp_packet_deinit(&mpp_pkt);
         return AVERROR(EAGAIN);
     }
+    /* update the last pts */
+    r->last_pts = pkt->pts == AV_NOPTS_VALUE ? last_pts : pkt->pts;
+
     av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", pkt->size);
 
     mpp_packet_deinit(&mpp_pkt);
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index 704cad8e93e..5f7b9ac0768 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -53,6 +53,7 @@ typedef struct RKMPPDecContext {
     AVBufferRef   *hwdevice;
     AVBufferRef   *hwframe;
 
+    int64_t        last_pts;
     AVPacket       last_pkt;
     int            eof;
     int            draining;

From 40e7554d277f5420720ec576d8d9e510855dc1ca Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 31 May 2025 18:01:02 +0800
Subject: [PATCH 084/103] fixup! lavu: add RKMPP hwcontext

revert to the old behavior.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index cfe2e7019b9..c0a14bf6d2d 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -460,7 +460,6 @@ static int rkmpp_map_frame(AVHWFramesContext *hwfc,
 
     dst->width  = src->width;
     dst->height = src->height;
-    dst->hw_frames_ctx = NULL;
 
     err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,
                                 &rkmpp_unmap_frame, map);

From bb5cd086dc2cd26da6bade9020a9e3f086e449d0 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 31 May 2025 18:17:28 +0800
Subject: [PATCH 085/103] lavc/rkmppdec: add RKMPP MJPEG decoder

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 configure              |   3 +-
 libavcodec/Makefile    |   1 +
 libavcodec/allcodecs.c |   1 +
 libavcodec/rkmppdec.c  | 182 +++++++++++++++++++++++++++++++++++++----
 4 files changed, 172 insertions(+), 15 deletions(-)

diff --git a/configure b/configure
index 829bc217473..86a9e4d7019 100755
--- a/configure
+++ b/configure
@@ -3266,6 +3266,7 @@ mjpeg_cuvid_decoder_deps="cuvid"
 mjpeg_qsv_decoder_select="qsvdec"
 mjpeg_qsv_encoder_deps="libmfx"
 mjpeg_qsv_encoder_select="qsvenc"
+mjpeg_rkmpp_decoder_deps="rkmpp"
 mjpeg_rkmpp_encoder_deps="rkmpp"
 mjpeg_vaapi_encoder_deps="VAEncPictureParameterBufferJPEG"
 mjpeg_vaapi_encoder_select="cbs_jpeg jpegtables vaapi_encode"
@@ -6919,7 +6920,7 @@ enabled openssl           && { { check_pkg_config openssl "openssl >= 3.0.0" ope
                                die "ERROR: openssl not found"; }
 enabled pocketsphinx      && require_pkg_config pocketsphinx pocketsphinx pocketsphinx/pocketsphinx.h ps_init
 enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp rockchip/rk_mpi.h mpp_create &&
-                               require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.8" rockchip/rk_mpi.h mpp_create &&
+                               require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.9" rockchip/rk_mpi.h mpp_create &&
                                { enabled libdrm ||
                                  die "ERROR: rkmpp requires --enable-libdrm"; }
                              }
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index aaf1ba9f7ca..5c5b825de6a 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -502,6 +502,7 @@ OBJS-$(CONFIG_MJPEG_ENCODER)           += mjpegenc.o mjpegenc_common.o \
 OBJS-$(CONFIG_MJPEGB_DECODER)          += mjpegbdec.o
 OBJS-$(CONFIG_MJPEG_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MJPEG_QSV_ENCODER)       += qsvenc_jpeg.o
+OBJS-$(CONFIG_MJPEG_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MJPEG_RKMPP_ENCODER)     += rkmppenc.o
 OBJS-$(CONFIG_MJPEG_VAAPI_ENCODER)     += vaapi_encode_mjpeg.o
 OBJS-$(CONFIG_MLP_DECODER)             += mlpdec.o mlpdsp.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 3b6e8267159..2788f59fe14 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -878,6 +878,7 @@ extern const FFCodec ff_libkvazaar_encoder;
 extern const FFCodec ff_mjpeg_cuvid_decoder;
 extern const FFCodec ff_mjpeg_qsv_encoder;
 extern const FFCodec ff_mjpeg_qsv_decoder;
+extern const FFCodec ff_mjpeg_rkmpp_decoder;
 extern const FFCodec ff_mjpeg_rkmpp_encoder;
 extern const FFCodec ff_mjpeg_vaapi_encoder;
 extern const FFCodec ff_mp3_mf_encoder;
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index b684c232cb8..4bdf875e0fe 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -48,6 +48,7 @@ static MppCodingType rkmpp_get_coding_type(AVCodecContext *avctx)
     case AV_CODEC_ID_MPEG1VIDEO:    /* fallthrough */
     case AV_CODEC_ID_MPEG2VIDEO:    return MPP_VIDEO_CodingMPEG2;
     case AV_CODEC_ID_MPEG4:         return MPP_VIDEO_CodingMPEG4;
+    case AV_CODEC_ID_MJPEG:         return MPP_VIDEO_CodingMJPEG;
     default:                        return MPP_VIDEO_CodingUnused;
     }
 }
@@ -186,6 +187,9 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
     if (opts_env && av_set_options_string(r, opts_env, "=", " ") <= 0)
         av_log(avctx, AV_LOG_WARNING, "Unable to set decoder options from env\n");
 
+    if (avctx->codec_id == AV_CODEC_ID_MJPEG)
+        r->buf_mode = RKMPP_DEC_HALF_INTERNAL;
+
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
     case AV_PIX_FMT_YUVJ420P:
@@ -204,7 +208,8 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
     case AV_PIX_FMT_YUVJ422P:
         pix_fmts[1] = AV_PIX_FMT_NV16;
         is_fmt_supported =
-            avctx->codec_id == AV_CODEC_ID_H264;
+            avctx->codec_id == AV_CODEC_ID_H264 ||
+            avctx->codec_id == AV_CODEC_ID_MJPEG;
         break;
     case AV_PIX_FMT_YUV422P10:
         pix_fmts[1] = AV_PIX_FMT_NV20;
@@ -215,7 +220,8 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
     case AV_PIX_FMT_YUVJ444P:
         pix_fmts[1] = AV_PIX_FMT_NV24;
         is_fmt_supported =
-            avctx->codec_id == AV_CODEC_ID_HEVC;
+            avctx->codec_id == AV_CODEC_ID_HEVC ||
+            avctx->codec_id == AV_CODEC_ID_MJPEG;
         break;
     case AV_PIX_FMT_NONE: /* fallback to drm_prime */
         is_fmt_supported = 1;
@@ -629,7 +635,7 @@ static int rkmpp_export_frame(AVCodecContext *avctx, AVFrame *frame, MppFrame mp
         layer->planes[1].pitch  = layer->planes[0].pitch;
 
         if (avctx->sw_pix_fmt == AV_PIX_FMT_NV24)
-            layer->planes[1].pitch *= 2;
+            layer->planes[1].pitch <<= 1;
     }
 
     if ((ret = frame_create_buf(frame, mpp_frame, mpp_frame_get_buf_size(mpp_frame),
@@ -715,6 +721,30 @@ static void rkmpp_export_avctx_color_props(AVCodecContext *avctx, MppFrame mpp_f
         avctx->chroma_sample_location = val;
 }
 
+static int rkmpp_mjpeg_get_frame(AVCodecContext *avctx, MppFrame *mpp_frame_out, int timeout)
+{
+    RKMPPDecContext *r = avctx->priv_data;
+    MppPacket mpp_pkt = NULL;
+    MppFrame mpp_frame = NULL;
+    MppMeta frame_meta = NULL;
+    int ret;
+
+    if ((ret = r->mapi->decode_get_frame(r->mctx, &mpp_frame)) != MPP_OK)
+        return timeout == MPP_TIMEOUT_BLOCK ? ret : MPP_ERR_TIMEOUT;
+
+    if (mpp_frame) {
+        frame_meta = mpp_frame_get_meta(mpp_frame);
+        if (frame_meta &&
+            (ret = mpp_meta_get_packet(frame_meta, KEY_INPUT_PACKET, &mpp_pkt)) == MPP_OK) {
+            if (mpp_pkt)
+                mpp_packet_deinit(&mpp_pkt);
+        }
+    }
+
+    *mpp_frame_out = mpp_frame;
+    return MPP_OK;
+}
+
 static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 {
     RKMPPDecContext *r = avctx->priv_data;
@@ -725,16 +755,24 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     if (r->eof)
         return AVERROR_EOF;
 
+    if (avctx->codec_id == AV_CODEC_ID_MJPEG)
+        timeout = FFMAX(timeout, MPP_TIMEOUT_NON_BLOCK);
+
     if ((ret = r->mapi->control(r->mctx, MPP_SET_OUTPUT_TIMEOUT, (MppParam)&timeout)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to set output timeout: %d\n", ret);
         return AVERROR_EXTERNAL;
     }
 
-    ret = r->mapi->decode_get_frame(r->mctx, &mpp_frame);
+    if (avctx->codec_id == AV_CODEC_ID_MJPEG)
+        ret = rkmpp_mjpeg_get_frame(avctx, &mpp_frame, timeout);
+    else
+        ret = r->mapi->decode_get_frame(r->mctx, &mpp_frame);
+
     if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {
         av_log(avctx, AV_LOG_ERROR, "Failed to get frame: %d\n", ret);
         return AVERROR_EXTERNAL;
     }
+
     if (!mpp_frame) {
         if (timeout != MPP_TIMEOUT_NON_BLOCK)
             av_log(avctx, AV_LOG_DEBUG, "Timeout getting decoded frame\n");
@@ -754,13 +792,23 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         ret = AVERROR(EAGAIN);
         goto exit;
     }
-    if (mpp_frame_get_errinfo(mpp_frame)) {
-        av_log(avctx, AV_LOG_DEBUG, "Received a 'errinfo' frame\n");
+    if (ret = mpp_frame_get_errinfo(mpp_frame)) {
+        int ignore_err = (avctx->codec_id != AV_CODEC_ID_MJPEG) ||
+                         (avctx->err_recognition & AV_EF_IGNORE_ERR);
+        int log_level = ignore_err ? AV_LOG_DEBUG : AV_LOG_ERROR;
+
+        av_log(avctx, log_level, "Received a 'errinfo' frame: %d\n", ret);
+        if (avctx->codec_id == AV_CODEC_ID_MJPEG)
+            av_log(avctx, log_level, "The YCbCr format may not be supported. Supported: "
+                   "YUV420(2*2:1*1:1*1) | YUV422(2*1:1*1:1*1) | YUV444(1*1:1*1:1*1)\n");
+        if (!ignore_err)
+            r->eof = 1; /* bail out from the loop */
         ret = AVERROR(EAGAIN);
         goto exit;
     }
 
-    if (r->info_change = mpp_frame_get_info_change(mpp_frame)) {
+    if (r->info_change = mpp_frame_get_info_change(mpp_frame) ||
+        (avctx->codec_id == AV_CODEC_ID_MJPEG && !r->buf_group)) {
         char *opts = NULL;
         int fast_parse = r->fast_parse;
         int mpp_frame_mode = mpp_frame_get_mode(mpp_frame);
@@ -821,6 +869,10 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
             goto exit;
         }
 
+        /* there's no real info change, export the frame directly */
+        if (avctx->codec_id == AV_CODEC_ID_MJPEG)
+            goto export;
+
         /* no more new pkts after EOS, retry to get frame */
         if (r->draining) {
             mpp_frame_deinit(&mpp_frame);
@@ -828,6 +880,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         }
         goto exit;
     } else {
+export:
         av_log(avctx, AV_LOG_DEBUG, "Received a frame\n");
         r->got_frame = 1;
 
@@ -893,6 +946,13 @@ static int rkmpp_send_eos(AVCodecContext *avctx)
     MppPacket mpp_pkt = NULL;
     int ret;
 
+    /* unlike other video codecs, MJPEG decoder's I/O is 1-in-1-out,
+     * there's no need to send EOS and drain internally enqueued frames */
+    if (avctx->codec_id == AV_CODEC_ID_MJPEG) {
+        r->draining = 1;
+        return 0;
+    }
+
     if ((ret = mpp_packet_init(&mpp_pkt, NULL, 0)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to init 'EOS' packet: %d\n", ret);
         return AVERROR_EXTERNAL;
@@ -909,6 +969,57 @@ static int rkmpp_send_eos(AVCodecContext *avctx)
     return 0;
 }
 
+static int rkmpp_mjpeg_put_packet(AVCodecContext *avctx, MppPacket mpp_pkt_with_buf)
+{
+    RKMPPDecContext *r = avctx->priv_data;
+    MppBuffer mpp_buf = NULL;
+    MppFrame mpp_frame = NULL;
+    MppMeta pkt_meta = NULL;
+    size_t buf_sz = FFALIGN(avctx->width, 16) * FFALIGN(avctx->height, 16) << 2;
+    int ret;
+
+    if ((ret = mpp_frame_init(&mpp_frame)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP frame: %d\n", ret);
+        ret = MPP_ERR_UNKNOW;
+        goto fail;
+    }
+    if ((ret = mpp_buffer_get(r->buf_group, &mpp_buf, buf_sz)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get buffer for frame: %d\n", ret);
+        ret = MPP_ERR_UNKNOW;
+        goto fail;
+    }
+    if (!mpp_buf) {
+        ret = MPP_ERR_UNKNOW;
+        goto fail;
+    }
+    mpp_frame_set_buffer(mpp_frame, mpp_buf);
+    mpp_buffer_put(mpp_buf);
+
+    pkt_meta = mpp_packet_get_meta(mpp_pkt_with_buf);
+    if (!pkt_meta || !mpp_packet_has_meta(mpp_pkt_with_buf)) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get packet meta\n");
+        ret = MPP_ERR_UNKNOW;
+        goto fail;
+    }
+    if ((ret = mpp_meta_set_frame(pkt_meta, KEY_OUTPUT_FRAME, mpp_frame)) != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set the key output frame\n");
+        ret = MPP_ERR_UNKNOW;
+        goto fail;
+    }
+
+    if ((ret = r->mapi->decode_put_packet(r->mctx, mpp_pkt_with_buf)) != MPP_OK) {
+        av_log(avctx, AV_LOG_TRACE, "Failed to put packet: %d\n", ret);
+        goto fail;
+    }
+
+    return MPP_OK;
+
+fail:
+    if (mpp_frame)
+        mpp_frame_deinit(&mpp_frame);
+    return ret;
+}
+
 static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
 {
     RKMPPDecContext *r = avctx->priv_data;
@@ -949,15 +1060,54 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
         mpp_pkt_pts = PTS_TO_MPP_PTS(last_pts, avctx->pkt_timebase);
     }
 
-    if ((ret = mpp_packet_init(&mpp_pkt, pkt->data, pkt->size)) != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to init packet: %d\n", ret);
-        return AVERROR_EXTERNAL;
+    if (avctx->codec_id == AV_CODEC_ID_MJPEG) {
+        MppBuffer mpp_buf = NULL;
+
+        /* the input slot of the MJPEG decoder must be a DRM/DMA buffer,
+         * so borrow some from the frame buffer to write the pkt data */
+        if ((ret = mpp_buffer_get(r->buf_group, &mpp_buf, pkt->size)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get buffer for packet: %d\n", ret);
+            return AVERROR_EXTERNAL;
+        }
+        if (!mpp_buf)
+            return AVERROR(ENOMEM);
+
+        if ((ret = mpp_buffer_write(mpp_buf, 0, pkt->data, pkt->size)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to write buffer: %d\n", ret);
+            mpp_buffer_put(mpp_buf);
+            return AVERROR_EXTERNAL;
+        }
+        if ((ret = mpp_buffer_sync_partial_end(mpp_buf, 0, pkt->size)) != MPP_OK)
+            av_log(avctx, AV_LOG_DEBUG, "Failed to sync buffer write: %d\n", ret);
+
+        if ((ret = mpp_packet_init_with_buffer(&mpp_pkt, mpp_buf)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to init packet with buffer: %d\n", ret);
+            mpp_buffer_put(mpp_buf);
+            return AVERROR_EXTERNAL;
+        }
+        mpp_buffer_put(mpp_buf);
+        mpp_packet_set_pts(mpp_pkt, mpp_pkt_pts);
+
+        ret = rkmpp_mjpeg_put_packet(avctx, mpp_pkt);
+        if (ret == MPP_ERR_UNKNOW) {
+            if (mpp_pkt)
+                mpp_packet_deinit(&mpp_pkt);
+            return AVERROR_EXTERNAL;
+        }
+    } else {
+        if ((ret = mpp_packet_init(&mpp_pkt, pkt->data, pkt->size)) != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to init packet: %d\n", ret);
+            return AVERROR_EXTERNAL;
+        }
+        mpp_packet_set_pts(mpp_pkt, mpp_pkt_pts);
+
+        ret = r->mapi->decode_put_packet(r->mctx, mpp_pkt);
     }
-    mpp_packet_set_pts(mpp_pkt, mpp_pkt_pts);
 
-    if ((ret = r->mapi->decode_put_packet(r->mctx, mpp_pkt)) != MPP_OK) {
+    if (ret != MPP_OK) {
         av_log(avctx, AV_LOG_TRACE, "Decoder buffer is full\n");
-        mpp_packet_deinit(&mpp_pkt);
+        if (mpp_pkt)
+            mpp_packet_deinit(&mpp_pkt);
         return AVERROR(EAGAIN);
     }
     /* update the last pts */
@@ -965,7 +1115,8 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
 
     av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", pkt->size);
 
-    mpp_packet_deinit(&mpp_pkt);
+    if (mpp_pkt && avctx->codec_id != AV_CODEC_ID_MJPEG)
+        mpp_packet_deinit(&mpp_pkt);
     return 0;
 }
 
@@ -1075,3 +1226,6 @@ DEFINE_RKMPP_DECODER(mpeg2, MPEG2VIDEO, NULL)
 #if CONFIG_MPEG4_RKMPP_DECODER
 DEFINE_RKMPP_DECODER(mpeg4, MPEG4, "dump_extra,mpeg4_unpack_bframes")
 #endif
+#if CONFIG_MJPEG_RKMPP_DECODER
+DEFINE_RKMPP_DECODER(mjpeg, MJPEG, NULL)
+#endif

From bdcd952b128f3443602e2649da2ed1cd7ace0c9d Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 31 May 2025 18:10:35 +0800
Subject: [PATCH 086/103] fixup! README: update for ffmpeg-rockchip

update for mjpeg_rkmpp decoder.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/README.md b/README.md
index f23235cc1ea..c960e21f7cd 100644
--- a/README.md
+++ b/README.md
@@ -29,6 +29,7 @@ The documentation is available on the [Wiki](https://github.com/nyanmisaka/ffmpe
  V..... h263_rkmpp           Rockchip MPP (Media Process Platform) H263 decoder (codec h263)
  V..... h264_rkmpp           Rockchip MPP (Media Process Platform) H264 decoder (codec h264)
  V..... hevc_rkmpp           Rockchip MPP (Media Process Platform) HEVC decoder (codec hevc)
+ V..... mjpeg_rkmpp          Rockchip MPP (Media Process Platform) MJPEG decoder (codec mjpeg)
  V..... mpeg1_rkmpp          Rockchip MPP (Media Process Platform) MPEG1VIDEO decoder (codec mpeg1video)
  V..... mpeg2_rkmpp          Rockchip MPP (Media Process Platform) MPEG2VIDEO decoder (codec mpeg2video)
  V..... mpeg4_rkmpp          Rockchip MPP (Media Process Platform) MPEG4 decoder (codec mpeg4)
@@ -81,7 +82,6 @@ The documentation is available on the [Wiki](https://github.com/nyanmisaka/ffmpe
 ```
 
 ## Todo
-* Support MPP MJPEG/JPEG decoder
 * Support MPP VP8 video encoder
 * ...
 

From 5ab1a0b7ba4f0baead9d03d64933b8f8a7505dea Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sat, 31 May 2025 18:13:23 +0800
Subject: [PATCH 087/103] lavc/rkmppenc: add chroma_fmt option for MJPEG
 encoder

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 54 +++++++++++++++++++++++++++++++++++++++++++
 libavcodec/rkmppenc.h | 18 +++++++++++++++
 2 files changed, 72 insertions(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 07a2523edcc..d452c5d6dd5 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -73,9 +73,19 @@ static MppFrameFormat rkmpp_get_mpp_fmt_mjpeg(enum AVPixelFormat pix_fmt)
     switch (pix_fmt) {
     case AV_PIX_FMT_YUVJ420P:
     case AV_PIX_FMT_YUV420P:   return MPP_FMT_YUV420P;
+    case AV_PIX_FMT_YUVJ422P:
+    case AV_PIX_FMT_YUV422P:   return MPP_FMT_YUV422P;     /* RK3576+ only */
+    case AV_PIX_FMT_YUVJ444P:
+    case AV_PIX_FMT_YUV444P:   return MPP_FMT_YUV444P;     /* RK3576+ only */
     case AV_PIX_FMT_NV12:      return MPP_FMT_YUV420SP;
+    case AV_PIX_FMT_NV21:      return MPP_FMT_YUV420SP_VU; /* RK3576+ only */
+    case AV_PIX_FMT_NV16:      return MPP_FMT_YUV422SP;    /* RK3576+ only */
+    case AV_PIX_FMT_NV24:      return MPP_FMT_YUV444SP;    /* RK3576+ only */
     case AV_PIX_FMT_YUYV422:   return MPP_FMT_YUV422_YUYV;
     case AV_PIX_FMT_UYVY422:   return MPP_FMT_YUV422_UYVY;
+    case AV_PIX_FMT_YVYU422:   return MPP_FMT_YUV422_YVYU; /* RK3576+ only */
+
+    /* RGB: pre-RK3576 only */
     case AV_PIX_FMT_RGB444BE:  return MPP_FMT_RGB444;
     case AV_PIX_FMT_BGR444BE:  return MPP_FMT_BGR444;
     case AV_PIX_FMT_RGB555BE:  return MPP_FMT_RGB555;
@@ -105,6 +115,38 @@ static uint32_t rkmpp_get_drm_afbc_format(MppFrameFormat mpp_fmt)
     }
 }
 
+static MppFrameChromaFormat rkmpp_fix_chroma_fmt(int chroma_fmt,
+                                                 enum AVPixelFormat pix_fmt)
+{
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
+    int log2_chroma_sum = desc->log2_chroma_w + desc->log2_chroma_h;
+    int is_yuv = !(desc->flags & AV_PIX_FMT_FLAG_RGB) &&
+                 desc->nb_components >= 2;
+
+    if (!is_yuv)
+        return MPP_CHROMA_UNSPECIFIED;
+
+    switch (chroma_fmt) {
+    case -1:
+        return log2_chroma_sum == 0 ? MPP_CHROMA_444 :
+               log2_chroma_sum == 1 ? MPP_CHROMA_422 :
+                                      MPP_CHROMA_UNSPECIFIED;
+    case MPP_CHROMA_400:
+        return chroma_fmt;
+    case MPP_CHROMA_420:
+        return log2_chroma_sum <= 2 ?
+            chroma_fmt : MPP_CHROMA_UNSPECIFIED;
+    case MPP_CHROMA_422:
+        return log2_chroma_sum <= 1 ?
+            chroma_fmt : MPP_CHROMA_UNSPECIFIED;
+    case MPP_CHROMA_444:
+        return log2_chroma_sum == 0 ?
+            chroma_fmt : MPP_CHROMA_UNSPECIFIED;
+    default:
+        return MPP_CHROMA_UNSPECIFIED;
+    }
+}
+
 static int get_byte_stride(const AVDRMObjectDescriptor *object,
                            const AVDRMLayerDescriptor *layer,
                            int is_rgb, int is_planar,
@@ -310,6 +352,12 @@ static int rkmpp_set_enc_cfg_prep(AVCodecContext *avctx, AVFrame *frame)
         mpp_enc_cfg_set_s32(cfg, "prep:colorrange", AVCOL_RANGE_JPEG);
     }
 
+    if (avctx->codec_id == AV_CODEC_ID_MJPEG) {
+        /* always output full range if the MJPEG encoder supports CSC */
+        mpp_enc_cfg_set_s32(cfg, "prep:range_out", AVCOL_RANGE_JPEG);
+        mpp_enc_cfg_set_s32(cfg, "prep:format_out", rkmpp_fix_chroma_fmt(r->chroma_fmt, r->pix_fmt));
+    }
+
     if (is_afbc) {
         const AVDRMLayerDescriptor *layer = &drm_desc->layers[0];
         uint32_t drm_afbc_fmt = rkmpp_get_drm_afbc_format(mpp_fmt);
@@ -368,6 +416,12 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
         mpp_enc_cfg_set_s32(cfg, "prep:colorrange", AVCOL_RANGE_JPEG);
     }
 
+    if (avctx->codec_id == AV_CODEC_ID_MJPEG) {
+        /* always output full range if the MJPEG encoder supports CSC */
+        mpp_enc_cfg_set_s32(cfg, "prep:range_out", AVCOL_RANGE_JPEG);
+        mpp_enc_cfg_set_s32(cfg, "prep:format_out", rkmpp_fix_chroma_fmt(r->chroma_fmt, r->pix_fmt));
+    }
+
     if (avctx->framerate.den > 0 && avctx->framerate.num > 0)
         av_reduce(&fps_num, &fps_den, avctx->framerate.num, avctx->framerate.den, 65535);
     else
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index a857de85515..de8ec2d5241 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -82,6 +82,7 @@ typedef struct RKMPPEncContext {
     int                dct8x8;
     int                udu_sei;
     int                prefix_mode;
+    int                chroma_fmt;
 } RKMPPEncContext;
 
 static const AVRational mpp_tb = { 1, 1000000 };
@@ -190,6 +191,13 @@ static const AVOption mjpeg_options[] = {
             { .i64 = -1 }, -1, 99, VE, "qp_max" }, \
     { "qp_min", "Set the min QP/Q_Factor value", OFFSET(qp_min), AV_OPT_TYPE_INT, \
             { .i64 = -1 }, -1, 99, VE, "qp_min" }, \
+    { "chroma_fmt", "Specify the output chroma format for down subsampling", OFFSET(chroma_fmt), AV_OPT_TYPE_INT, \
+            { .i64 = MPP_CHROMA_UNSPECIFIED }, -1, MPP_CHROMA_444, VE, .unit = "chroma_fmt" }, \
+        { "auto", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = -1 }, 0, 0, VE, .unit = "chroma_fmt" },
+        { "400",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_400 }, 0, 0, VE, .unit = "chroma_fmt" },
+        { "420",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_420 }, 0, 0, VE, .unit = "chroma_fmt" },
+        { "422",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_422 }, 0, 0, VE, .unit = "chroma_fmt" },
+        { "444",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_444 }, 0, 0, VE, .unit = "chroma_fmt" },
     { NULL },
 };
 
@@ -225,9 +233,19 @@ static const enum AVPixelFormat rkmpp_enc_pix_fmts_h26x[] = {
 static const enum AVPixelFormat rkmpp_enc_pix_fmts_mjpeg[] = {
     AV_PIX_FMT_YUV420P,
     AV_PIX_FMT_YUVJ420P,
+    AV_PIX_FMT_YUV422P,  /* RK3576+ only */
+    AV_PIX_FMT_YUVJ422P,
+    AV_PIX_FMT_YUV444P,  /* RK3576+ only */
+    AV_PIX_FMT_YUVJ444P,
     AV_PIX_FMT_NV12,
+    AV_PIX_FMT_NV21,     /* RK3576+ only */
+    AV_PIX_FMT_NV16,     /* RK3576+ only */
+    AV_PIX_FMT_NV24,     /* RK3576+ only */
     AV_PIX_FMT_YUYV422,
     AV_PIX_FMT_UYVY422,
+    AV_PIX_FMT_YVYU422,  /* RK3576+ only */
+
+    /* RGB: pre-RK3576 only */
     AV_PIX_FMT_RGB444BE,
     AV_PIX_FMT_BGR444BE,
     AV_PIX_FMT_RGB555BE,

From 7d7212cb3ff8411c88b8b6a07ae2e85cda6a511a Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sun, 1 Jun 2025 23:47:26 +0800
Subject: [PATCH 088/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

refine colorspace conversion handling.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c | 149 ++++++++++++++++++++++---------------
 1 file changed, 91 insertions(+), 58 deletions(-)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index 82b2f53ef6e..b7c7a6ba127 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -258,78 +258,90 @@ static RGAFrame *get_free_frame(RGAFrame **list)
     return out;
 }
 
-static void set_colorspace_info(RGAFrameInfo *in_info, const AVFrame *in,
-                                RGAFrameInfo *out_info, AVFrame *out,
-                                int *color_space_mode)
+static void set_colorspace_info(RGAFrameInfo *in_info,
+                                enum AVColorSpace in_spc,
+                                enum AVColorRange in_rng,
+                                RGAFrameInfo *out_info,
+                                enum AVColorSpace *out_spc,
+                                enum AVColorRange *out_rng,
+                                int *color_space_mode,
+                                int is_rga2_used)
 {
-    if (!in_info || !out_info || !in || !out || !color_space_mode)
+    int rgb_in, rgb_out, out_mode = 0;
+
+    if (!in_info || !out_info || !color_space_mode)
         return;
 
-    *color_space_mode = 0;
+    rgb_in  = in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB;
+    rgb_out = out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB;
 
     /* rgb2yuv */
-    if ((in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB) &&
-        !(out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB)) {
+    if (rgb_in && !rgb_out) {
         /* rgb full -> yuv full/limit */
-        if (in->color_range == AVCOL_RANGE_JPEG) {
-            switch (in->colorspace) {
-            case AVCOL_SPC_BT709:
-                out->colorspace   = AVCOL_SPC_BT709;
-                *color_space_mode = 0xb << 8; /* rgb2yuv_709_limit */
-                break;
-            case AVCOL_SPC_BT470BG:
-                out->colorspace   = AVCOL_SPC_BT470BG;
-                *color_space_mode = 2 << 2; /* IM_RGB_TO_YUV_BT601_LIMIT */
-                break;
+        if (in_rng == AVCOL_RANGE_JPEG) {
+            if ((out_rng && *out_rng == AVCOL_RANGE_JPEG) ||
+                (out_spc && *out_spc == AVCOL_SPC_BT470BG)) {
+                if (out_spc)
+                    *out_spc = AVCOL_SPC_BT470BG;
+
+                if (out_rng && *out_rng == AVCOL_RANGE_JPEG)
+                    out_mode = 1 << 2; /* IM_RGB_TO_YUV_BT601_FULL */
+                else {
+                    if (out_rng)
+                        *out_rng = AVCOL_RANGE_MPEG;
+                    out_mode = 2 << 2; /* IM_RGB_TO_YUV_BT601_LIMIT */
+                }
+            } else {
+                if (out_spc)
+                    *out_spc = AVCOL_SPC_BT709;
+                if (out_rng)
+                    *out_rng = AVCOL_RANGE_MPEG;
+                out_mode = is_rga2_used ? (0xb << 8) /* rgb2yuv_709_limit */
+                                        : (3 << 2);  /* IM_RGB_TO_YUV_BT709_LIMIT */
             }
         }
-        if (*color_space_mode) {
-            out->color_trc       = AVCOL_TRC_UNSPECIFIED;
-            out->color_primaries = AVCOL_PRI_UNSPECIFIED;
-            out->color_range     = AVCOL_RANGE_MPEG;
-        }
+        if (out_mode)
+            *color_space_mode |= out_mode;
     }
-
     /* yuv2rgb */
-    if (!(in_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB) &&
-        (out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB)) {
+    else if (!rgb_in && rgb_out) {
         /* yuv full/limit -> rgb full */
-        switch (in->color_range) {
+        switch (in_rng) {
         case AVCOL_RANGE_MPEG:
-            if (in->colorspace == AVCOL_SPC_BT709) {
-                out->colorspace   = AVCOL_SPC_BT709;
-                *color_space_mode = 3 << 0; /* IM_YUV_TO_RGB_BT709_LIMIT */
-            }
-            if (in->colorspace == AVCOL_SPC_BT470BG) {
-                out->colorspace   = AVCOL_SPC_BT470BG;
-                *color_space_mode = 1 << 0; /* IM_YUV_TO_RGB_BT601_LIMIT */
-            }
+            if (in_spc == AVCOL_SPC_BT709)
+                out_mode = 3 << 0; /* IM_YUV_TO_RGB_BT709_LIMIT */
+            if (in_spc == AVCOL_SPC_BT470BG)
+                out_mode = 1 << 0; /* IM_YUV_TO_RGB_BT601_LIMIT */
             break;
         case AVCOL_RANGE_JPEG:
 #if 0
-            if (in->colorspace == AVCOL_SPC_BT709) {
-                out->colorspace   = AVCOL_SPC_BT709;
-                *color_space_mode = 0xc << 8; /* yuv2rgb_709_full */
-            }
+            if (in_spc == AVCOL_SPC_BT709)
+                out_mode = 0xc << 8; /* yuv2rgb_709_full */
+            if (in_spc == AVCOL_SPC_BT470BG)
 #endif
-            if (in->colorspace == AVCOL_SPC_BT470BG) {
-                out->colorspace   = AVCOL_SPC_BT470BG;
-                *color_space_mode = 2 << 0; /* IM_YUV_TO_RGB_BT601_FULL */
-            }
+                out_mode = 2 << 0; /* IM_YUV_TO_RGB_BT601_FULL */
             break;
         }
-        if (*color_space_mode) {
-            out->color_trc       = AVCOL_TRC_UNSPECIFIED;
-            out->color_primaries = AVCOL_PRI_UNSPECIFIED;
-            out->color_range     = AVCOL_RANGE_JPEG;
-        }
+        if (out_spc)
+            *out_spc = AVCOL_SPC_RGB;
+        if (out_rng)
+            *out_rng = AVCOL_RANGE_JPEG;
+        if (out_mode)
+            *color_space_mode |= out_mode;
+    }
+    /* passthrough */
+    else {
+        if (out_spc)
+            *out_spc = in_spc;
+        if (out_rng)
+            *out_rng = in_rng;
     }
 
     /* yuvj2yuv */
     if ((in_info->pix_fmt == AV_PIX_FMT_YUVJ420P ||
-         in_info->pix_fmt == AV_PIX_FMT_YUVJ422P) &&
-        !(out_info->pix_desc->flags & AV_PIX_FMT_FLAG_RGB)) {
-        out->color_range = AVCOL_RANGE_JPEG;
+         in_info->pix_fmt == AV_PIX_FMT_YUVJ422P) && !rgb_out) {
+        if (out_rng)
+            *out_rng = AVCOL_RANGE_JPEG;
     }
 }
 
@@ -391,7 +403,7 @@ static int verify_rga_frame_info_io_dynamic(AVFilterContext *avctx,
 }
 
 static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
-                              AVFrame *picref, int do_overlay, int pat_preproc)
+                              const AVFrame *picref, int do_overlay, int pat_preproc)
 {
     RGAFrame        *rga_frame;
     AVFilterContext *ctx = inlink->dst;
@@ -532,7 +544,7 @@ static RGAFrame *submit_frame(RKRGAContext *r, AVFilterLink *inlink,
 }
 
 static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
-                             const AVFrame *in, int pat_preproc)
+                             const AVFrame *in, const AVFrame *picref_pat, int pat_preproc)
 {
     AVFilterContext *ctx = outlink->src;
     AVFilterLink *inlink = ctx->inputs[0];
@@ -611,8 +623,29 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
     if (out_info->uncompact_10b_msb)
         info.is_10b_compact = info.is_10b_endian = 1;
 
-    if (!pat_preproc)
-        set_colorspace_info(in0_info, in, out_info, out_frame->frame, &info.color_space_mode);
+    if (!pat_preproc) {
+        int is_rga2_used = r->is_rga2_used || out_info->scheduler_core == (out_info->scheduler_core & 0xc);
+
+#ifdef RGA_NORMAL_DST_FULL_CSC_FIXUP
+        if (in1_info && picref_pat) {
+            enum AVColorSpace pat_colorspace = picref_pat->colorspace;
+            enum AVColorRange pat_color_range = picref_pat->color_range;
+            /* yuv2rgb src->pat */
+            set_colorspace_info(in0_info, in->colorspace, in->color_range,
+                                in1_info, &pat_colorspace, &pat_color_range,
+                                &info.color_space_mode, is_rga2_used);
+            /* rgb2yuv pat->dst */
+            set_colorspace_info(in1_info, pat_colorspace, pat_color_range,
+                                out_info, &out_frame->frame->colorspace, &out_frame->frame->color_range,
+                                &info.color_space_mode, is_rga2_used);
+        } else
+#endif
+        {
+            set_colorspace_info(in0_info, in->colorspace, in->color_range,
+                                out_info, &out_frame->frame->colorspace, &out_frame->frame->color_range,
+                                &info.color_space_mode, is_rga2_used);
+        }
+    }
 
     if (pat_preproc)
         rga_set_rect(&info.rect, in1_info->overlay_x, in1_info->overlay_y,
@@ -1223,8 +1256,8 @@ static int call_rkrga_blit(AVFilterContext *avctx,
 
 #define PRINT_RGA_INFO(ctx, info, name) do { \
     if (info && name) \
-        av_log(ctx, AV_LOG_DEBUG, "RGA %s | fd:%d mmu:%d rd_mode:%d | x:%d y:%d w:%d h:%d ws:%d hs:%d fmt:0x%x\n", \
-               name, info->fd, info->mmuFlag, (info->rd_mode >> 1), info->rect.xoffset, info->rect.yoffset, \
+        av_log(ctx, AV_LOG_DEBUG, "RGA %s | fd:%d mmu:%d rd:%d csc:%d | x:%d y:%d w:%d h:%d ws:%d hs:%d fmt:0x%x\n", \
+               name, info->fd, info->mmuFlag, (info->rd_mode >> 1), info->color_space_mode, info->rect.xoffset, info->rect.yoffset, \
                info->rect.width, info->rect.height, info->rect.wstride, info->rect.hstride, (info->rect.format >> 8)); \
 } while (0)
 
@@ -1290,7 +1323,7 @@ int ff_rkrga_filter_frame(RKRGAContext *r,
     }
 
     /* DST */
-    if (!(dst_frame = query_frame(r, outlink, src_frame->frame, 0))) {
+    if (!(dst_frame = query_frame(r, outlink, src_frame->frame, picref_pat, 0))) {
         av_log(ctx, AV_LOG_ERROR, "Failed to query an output frame\n");
         return AVERROR(ENOMEM);
     }
@@ -1313,7 +1346,7 @@ int ff_rkrga_filter_frame(RKRGAContext *r,
                        FF_INLINK_IDX(inlink_pat));
                 return AVERROR(ENOMEM);
             }
-            if (!(pat_out = query_frame(r, outlink, picref_pat, 1))) {
+            if (!(pat_out = query_frame(r, outlink, picref_pat, NULL, 1))) {
                 av_log(ctx, AV_LOG_ERROR, "Failed to query an output frame\n");
                 return AVERROR(ENOMEM);
             }

From 8d49209ccdba064e759718f08aa4bbd942187d06 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sun, 1 Jun 2025 23:48:31 +0800
Subject: [PATCH 089/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

fix rgb2yuv CSC when the input is RGB formats.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index d452c5d6dd5..b7ee3ffd1ed 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -341,7 +341,11 @@ static int rkmpp_set_enc_cfg_prep(AVCodecContext *avctx, AVFrame *frame)
     mpp_enc_cfg_set_s32(cfg, "prep:width", avctx->width);
     mpp_enc_cfg_set_s32(cfg, "prep:height", avctx->height);
 
-    mpp_enc_cfg_set_s32(cfg, "prep:colorspace", avctx->colorspace);
+    if (pix_desc->flags & AV_PIX_FMT_FLAG_RGB) /* RGB -> BT709 CSC */
+        mpp_enc_cfg_set_s32(cfg, "prep:colorspace", AVCOL_SPC_BT709);
+    else
+        mpp_enc_cfg_set_s32(cfg, "prep:colorspace", avctx->colorspace);
+
     mpp_enc_cfg_set_s32(cfg, "prep:colorprim", avctx->color_primaries);
     mpp_enc_cfg_set_s32(cfg, "prep:colortrc", avctx->color_trc);
 
@@ -388,7 +392,7 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
 {
     RKMPPEncContext *r = avctx->priv_data;
     MppEncCfg cfg = r->mcfg;
-
+    const AVPixFmtDescriptor *pix_desc;
     RK_U32 rc_mode, fps_num, fps_den;
     MppEncHeaderMode header_mode;
     MppEncSeiMode sei_mode;
@@ -400,12 +404,17 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
     mpp_enc_cfg_set_s32(cfg, "prep:height", avctx->height);
     mpp_enc_cfg_set_s32(cfg, "prep:hor_stride", FFALIGN(avctx->width, 64));
     mpp_enc_cfg_set_s32(cfg, "prep:ver_stride", FFALIGN(avctx->height, 64));
-    mpp_enc_cfg_set_s32(cfg, "prep:format", MPP_FMT_YUV420SP);
+    mpp_enc_cfg_set_s32(cfg, "prep:format", r->mpp_fmt);
     mpp_enc_cfg_set_s32(cfg, "prep:mirroring", 0);
     mpp_enc_cfg_set_s32(cfg, "prep:rotation", 0);
     mpp_enc_cfg_set_s32(cfg, "prep:flip", 0);
 
-    mpp_enc_cfg_set_s32(cfg, "prep:colorspace", avctx->colorspace);
+    pix_desc = av_pix_fmt_desc_get(r->pix_fmt);
+    if (pix_desc->flags & AV_PIX_FMT_FLAG_RGB) /* RGB -> BT709 CSC */
+        mpp_enc_cfg_set_s32(cfg, "prep:colorspace", AVCOL_SPC_BT709);
+    else
+        mpp_enc_cfg_set_s32(cfg, "prep:colorspace", avctx->colorspace);
+
     mpp_enc_cfg_set_s32(cfg, "prep:colorprim", avctx->color_primaries);
     mpp_enc_cfg_set_s32(cfg, "prep:colortrc", avctx->color_trc);
 

From 08b9691e330d0e9b5f4e89c46315694cca230fea Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 2 Jun 2025 17:38:54 +0800
Subject: [PATCH 090/103] fixup! lavc/rkmppenc: add chroma_fmt option for MJPEG
 encoder

omit the ".unit =" accessor in 6.x.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.h | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index de8ec2d5241..ab63d590036 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -192,12 +192,12 @@ static const AVOption mjpeg_options[] = {
     { "qp_min", "Set the min QP/Q_Factor value", OFFSET(qp_min), AV_OPT_TYPE_INT, \
             { .i64 = -1 }, -1, 99, VE, "qp_min" }, \
     { "chroma_fmt", "Specify the output chroma format for down subsampling", OFFSET(chroma_fmt), AV_OPT_TYPE_INT, \
-            { .i64 = MPP_CHROMA_UNSPECIFIED }, -1, MPP_CHROMA_444, VE, .unit = "chroma_fmt" }, \
-        { "auto", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = -1 }, 0, 0, VE, .unit = "chroma_fmt" },
-        { "400",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_400 }, 0, 0, VE, .unit = "chroma_fmt" },
-        { "420",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_420 }, 0, 0, VE, .unit = "chroma_fmt" },
-        { "422",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_422 }, 0, 0, VE, .unit = "chroma_fmt" },
-        { "444",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_444 }, 0, 0, VE, .unit = "chroma_fmt" },
+            { .i64 = MPP_CHROMA_UNSPECIFIED }, -1, MPP_CHROMA_444, VE, "chroma_fmt" }, \
+        { "auto", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = -1 }, 0, 0, VE, "chroma_fmt" },
+        { "400",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_400 }, 0, 0, VE, "chroma_fmt" },
+        { "420",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_420 }, 0, 0, VE, "chroma_fmt" },
+        { "422",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_422 }, 0, 0, VE, "chroma_fmt" },
+        { "444",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MPP_CHROMA_444 }, 0, 0, VE, "chroma_fmt" },
     { NULL },
 };
 

From 13668da03c40f84e58289a7ec687549c7b4c0467 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 3 Jun 2025 00:45:02 +0800
Subject: [PATCH 091/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

fix using vf_hwmap filter with RKMPP encoders.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index b7ee3ffd1ed..296cf181fb6 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -741,6 +741,8 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
         drm_frame = frame;
         mpp_enc_frame->frame = av_frame_clone(drm_frame);
     } else {
+        AVBufferRef *hw_frames_ctx = frame->hw_frames_ctx;
+
         drm_frame = av_frame_alloc();
         if (!drm_frame) {
             goto exit;
@@ -749,15 +751,19 @@ static MPPEncFrame *rkmpp_submit_frame(AVCodecContext *avctx, AVFrame *frame)
             av_log(avctx, AV_LOG_ERROR, "Cannot allocate an internal frame: %d\n", ret);
             goto exit;
         }
+        frame->hw_frames_ctx = NULL; /* clear hwfc to avoid HW -> HW transfer */
         if ((ret = av_hwframe_transfer_data(drm_frame, frame, 0)) < 0) {
             av_log(avctx, AV_LOG_ERROR, "av_hwframe_transfer_data failed: %d\n", ret);
+            frame->hw_frames_ctx = hw_frames_ctx;
             goto exit;
         }
         if ((ret = av_frame_copy_props(drm_frame, frame)) < 0) {
             av_log(avctx, AV_LOG_ERROR, "av_frame_copy_props failed: %d\n", ret);
+            frame->hw_frames_ctx = hw_frames_ctx;
             goto exit;
         }
         mpp_enc_frame->frame = drm_frame;
+        frame->hw_frames_ctx = hw_frames_ctx; /* restore hwfc */
     }
 
     drm_desc = (AVDRMFrameDescriptor *)drm_frame->data[0];

From bc39c417b1bdc07f4936a51e2863b750eee46b7f Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Tue, 3 Jun 2025 07:38:11 +0800
Subject: [PATCH 092/103] fixup! lavc/rkmppdec: add RKMPP MJPEG decoder

avoid using the MPP runtime's built-in misc group for info change frame.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 30 +++++++++++++++++++++++++-----
 libavcodec/rkmppdec.h |  2 ++
 2 files changed, 27 insertions(+), 5 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 4bdf875e0fe..1be1096ee8b 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -163,6 +163,10 @@ static av_cold int rkmpp_decode_close(AVCodecContext *avctx)
         mpp_buffer_group_put(r->buf_group);
         r->buf_group = NULL;
     }
+    if (r->buf_group_misc) {
+        mpp_buffer_group_put(r->buf_group_misc);
+        r->buf_group_misc = NULL;
+    }
 
     if (r->hwframe)
         av_buffer_unref(&r->hwframe);
@@ -187,9 +191,6 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
     if (opts_env && av_set_options_string(r, opts_env, "=", " ") <= 0)
         av_log(avctx, AV_LOG_WARNING, "Unable to set decoder options from env\n");
 
-    if (avctx->codec_id == AV_CODEC_ID_MJPEG)
-        r->buf_mode = RKMPP_DEC_HALF_INTERNAL;
-
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
     case AV_PIX_FMT_YUVJ420P:
@@ -269,6 +270,20 @@ static av_cold int rkmpp_decode_init(AVCodecContext *avctx)
         goto fail;
     }
 
+    if (avctx->codec_id == AV_CODEC_ID_MJPEG) {
+        r->buf_mode = RKMPP_DEC_HALF_INTERNAL;
+
+        /* Misc buffer group: for info change frame and bitstream only */
+        ret = mpp_buffer_group_get_internal(&r->buf_group_misc, MPP_BUFFER_TYPE_DRM |
+                                                                MPP_BUFFER_FLAGS_DMA32 |
+                                                                MPP_BUFFER_FLAGS_CACHABLE);
+        if (ret != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get MPP internal buffer group for Misc: %d\n", ret);
+            ret = AVERROR_EXTERNAL;
+            goto fail;
+        }
+    }
+
     if (avctx->skip_frame == AVDISCARD_NONKEY)
         r->deint = 0;
 
@@ -972,18 +987,21 @@ static int rkmpp_send_eos(AVCodecContext *avctx)
 static int rkmpp_mjpeg_put_packet(AVCodecContext *avctx, MppPacket mpp_pkt_with_buf)
 {
     RKMPPDecContext *r = avctx->priv_data;
+    MppBufferGroup buf_group = r->buf_group ? r->buf_group : r->buf_group_misc;
     MppBuffer mpp_buf = NULL;
     MppFrame mpp_frame = NULL;
     MppMeta pkt_meta = NULL;
     size_t buf_sz = FFALIGN(avctx->width, 16) * FFALIGN(avctx->height, 16) << 2;
     int ret;
 
+    av_assert0(buf_group);
+
     if ((ret = mpp_frame_init(&mpp_frame)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to init MPP frame: %d\n", ret);
         ret = MPP_ERR_UNKNOW;
         goto fail;
     }
-    if ((ret = mpp_buffer_get(r->buf_group, &mpp_buf, buf_sz)) != MPP_OK) {
+    if ((ret = mpp_buffer_get(buf_group, &mpp_buf, buf_sz)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to get buffer for frame: %d\n", ret);
         ret = MPP_ERR_UNKNOW;
         goto fail;
@@ -1063,9 +1081,11 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *pkt)
     if (avctx->codec_id == AV_CODEC_ID_MJPEG) {
         MppBuffer mpp_buf = NULL;
 
+        av_assert0(r->buf_group_misc);
+
         /* the input slot of the MJPEG decoder must be a DRM/DMA buffer,
          * so borrow some from the frame buffer to write the pkt data */
-        if ((ret = mpp_buffer_get(r->buf_group, &mpp_buf, pkt->size)) != MPP_OK) {
+        if ((ret = mpp_buffer_get(r->buf_group_misc, &mpp_buf, pkt->size)) != MPP_OK) {
             av_log(avctx, AV_LOG_ERROR, "Failed to get buffer for packet: %d\n", ret);
             return AVERROR_EXTERNAL;
         }
diff --git a/libavcodec/rkmppdec.h b/libavcodec/rkmppdec.h
index 5f7b9ac0768..6fd74e2563e 100644
--- a/libavcodec/rkmppdec.h
+++ b/libavcodec/rkmppdec.h
@@ -35,6 +35,7 @@
 #include "hwconfig.h"
 #include "internal.h"
 
+#include "libavutil/avassert.h"
 #include "libavutil/avstring.h"
 #include "libavutil/hwcontext_rkmpp.h"
 #include "libavutil/mastering_display_metadata.h"
@@ -49,6 +50,7 @@ typedef struct RKMPPDecContext {
     MppApi        *mapi;
     MppCtx         mctx;
     MppBufferGroup buf_group;
+    MppBufferGroup buf_group_misc;
 
     AVBufferRef   *hwdevice;
     AVBufferRef   *hwframe;

From f37c17d024cd35b6ad1a1837433dd2e66fa3414b Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Thu, 5 Jun 2025 00:17:34 +0800
Subject: [PATCH 093/103] fixup! lavu: add RKMPP hwcontext

fix width stride align 16 of rgb24 in rga3.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavutil/hwcontext_rkmpp.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavutil/hwcontext_rkmpp.c b/libavutil/hwcontext_rkmpp.c
index c0a14bf6d2d..78006511764 100644
--- a/libavutil/hwcontext_rkmpp.c
+++ b/libavutil/hwcontext_rkmpp.c
@@ -183,7 +183,7 @@ static int rkmpp_get_aligned_linesize(enum AVPixelFormat pix_fmt, int width, int
 
     if (is_packed_fmt) {
         const int pixel_width = av_get_padded_bits_per_pixel(pixdesc) / 8;
-        linesize = FFALIGN(linesize / pixel_width, 8) * pixel_width;
+        linesize = FFALIGN(linesize / pixel_width, 16) * pixel_width;
     } else if (is_yuv && is_fully_planar) {
         linesize = FFALIGN(linesize, 16 >> (plane ? pixdesc->log2_chroma_w : 0));
     } else

From 374848d45c60c2b8cbfc078280d14f80b28b2f68 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 30 Jun 2025 17:15:47 +0800
Subject: [PATCH 094/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

fix decoder options printing buffer not being freed.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 1be1096ee8b..d4546a502b9 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -857,6 +857,8 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 
         if (av_opt_serialize(r, 0, 0, &opts, '=', ' ') >= 0)
             av_log(avctx, AV_LOG_VERBOSE, "Decoder options: %s\n", opts);
+        if (opts)
+            av_freep(&opts);
 
         av_log(avctx, AV_LOG_VERBOSE, "Configured with size: %dx%d | pix_fmt: %s | sw_pix_fmt: %s\n",
                avctx->width, avctx->height,

From 419ef5955dec05b6e4eb6976a43ddd1ba68a0b4c Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Mon, 30 Jun 2025 17:16:45 +0800
Subject: [PATCH 095/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

fix in_rga_frame_infos not being freed.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index b7c7a6ba127..c7b74a066fd 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -1237,6 +1237,9 @@ av_cold int ff_rkrga_close(AVFilterContext *avctx)
 
     clear_frame_list(&r->pat_preproc_frame_list);
 
+    if (r->in_rga_frame_infos)
+        av_freep(&r->in_rga_frame_infos);
+
     av_fifo_freep2(&r->async_fifo);
 
     av_buffer_unref(&r->pat_preproc_hwframes_ctx);

From 0983084625e2ad38f768411b332d7975fceafd1e Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Fri, 4 Jul 2025 17:01:42 +0800
Subject: [PATCH 096/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

refine return value handling.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index d4546a502b9..38c27035dae 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -783,9 +783,15 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     else
         ret = r->mapi->decode_get_frame(r->mctx, &mpp_frame);
 
-    if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to get frame: %d\n", ret);
-        return AVERROR_EXTERNAL;
+    if (ret != MPP_OK) {
+        if (timeout == MPP_TIMEOUT_NON_BLOCK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get frame (non-block): %d\n", ret);
+            return AVERROR_EXTERNAL;
+        }
+        if (timeout != MPP_TIMEOUT_NON_BLOCK && ret != MPP_NOK && ret != MPP_ERR_TIMEOUT) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get frame (timeout: %d): %d\n", timeout, ret);
+            return AVERROR_EXTERNAL;
+        }
     }
 
     if (!mpp_frame) {

From 7ed6bee4065cb99bfba74c2c8d9578ef895fb7f5 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 23 Jul 2025 18:24:30 +0800
Subject: [PATCH 097/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

fix an issue where invalid frames could be returned.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 38c27035dae..4185d91acc5 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -901,6 +901,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
             mpp_frame_deinit(&mpp_frame);
             return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_MAX);
         }
+        ret = AVERROR(EAGAIN);
         goto exit;
     } else {
 export:

From e2bbfe4b31fc5328a625e266344a0bf3c2c45f60 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Wed, 23 Jul 2025 18:26:50 +0800
Subject: [PATCH 098/103] lavc/rkmppenc: add support for reporting average QP

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 10 +++++++++-
 libavcodec/rkmppenc.h |  1 +
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 296cf181fb6..5288d09ea74 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -938,7 +938,9 @@ static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout
     MppMeta mpp_meta = NULL;
     MppFrame mpp_frame = NULL;
     MppBuffer mpp_buf = NULL;
-    int ret, key_frame = 0;
+    int key_frame = 0;
+    int avg_qp = -1;
+    int ret;
 
     if ((ret = r->mapi->control(r->mctx, MPP_SET_OUTPUT_TIMEOUT, (MppParam)&timeout)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to set output timeout: %d\n", ret);
@@ -988,6 +990,12 @@ static int rkmpp_get_packet(AVCodecContext *avctx, AVPacket *packet, int timeout
     if (key_frame)
         packet->flags |= AV_PKT_FLAG_KEY;
 
+    mpp_meta_get_s32(mpp_meta, KEY_ENC_AVERAGE_QP, &avg_qp);
+    if (avg_qp >= 0)
+        ff_side_data_set_encoder_stats(packet, avg_qp * FF_QP2LAMBDA, NULL, 0,
+                                       (packet->flags & AV_PKT_FLAG_KEY) ?
+                                       AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P);
+
     if ((ret = mpp_meta_get_frame(mpp_meta, KEY_INPUT_FRAME, &mpp_frame)) != MPP_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to get key input frame from packet meta: %d\n", ret);
         ret = AVERROR_EXTERNAL;
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index ab63d590036..c5110b4a975 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -33,6 +33,7 @@
 #include "encode.h"
 #include "hwconfig.h"
 #include "internal.h"
+#include "packet_internal.h"
 
 #include "libavutil/hwcontext_rkmpp.h"
 #include "libavutil/opt.h"

From f339a3095753a36ddbd7d047c91b716c58b37034 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sun, 21 Sep 2025 20:42:47 +0800
Subject: [PATCH 099/103] fixup! lavc/rkmppdec: refactor RKMPP decoders and
 extend codecs

mark flush() as av_cold.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppdec.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 4185d91acc5..d6e418cdd29 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -1210,7 +1210,7 @@ static int rkmpp_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     return ret;
 }
 
-static void rkmpp_decode_flush(AVCodecContext *avctx)
+static av_cold void rkmpp_decode_flush(AVCodecContext *avctx)
 {
     RKMPPDecContext *r = avctx->priv_data;
     int ret;

From 88e527cb4758e8c918e7618fe6d374728ad24382 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sun, 21 Sep 2025 20:44:12 +0800
Subject: [PATCH 100/103] fixup! lavc/rkmppenc: add RKMPP H264 and HEVC encoder

mark init() and close() as av_cold.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 5288d09ea74..899180a9693 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -1063,7 +1063,7 @@ static int rkmpp_encode_frame(AVCodecContext *avctx, AVPacket *packet,
     return 0;
 }
 
-static int rkmpp_encode_close(AVCodecContext *avctx)
+static av_cold int rkmpp_encode_close(AVCodecContext *avctx)
 {
     RKMPPEncContext *r = avctx->priv_data;
 
@@ -1118,7 +1118,7 @@ static av_cold int init_hwframes_ctx(AVCodecContext *avctx)
     return 0;
 }
 
-static int rkmpp_encode_init(AVCodecContext *avctx)
+static av_cold int rkmpp_encode_init(AVCodecContext *avctx)
 {
     RKMPPEncContext *r = avctx->priv_data;
     enum AVPixelFormat pix_fmt = AV_PIX_FMT_NONE;

From 3dbfaebfebdbb493bd7cfa4f9205ca48e318c9fa Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Fri, 26 Sep 2025 18:34:19 +0800
Subject: [PATCH 101/103] lavc/rkmppenc: add support for enabling intra refresh
 (GDR)

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c |  9 +++++++++
 libavcodec/rkmppenc.h | 11 +++++++++++
 2 files changed, 20 insertions(+)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 899180a9693..4ce1ef20193 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -539,6 +539,15 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
             mpp_enc_cfg_set_s32(cfg, "rc:qp_min", qp_min);
             mpp_enc_cfg_set_s32(cfg, "rc:qp_max_i",qp_max_i);
             mpp_enc_cfg_set_s32(cfg, "rc:qp_min_i", qp_min_i);
+
+            /* Intra Refresh / GDR */
+            if (r->intra_refresh && r->refresh_num) {
+                mpp_enc_cfg_set_u32(cfg, "rc:refresh_en", 1);
+                mpp_enc_cfg_set_u32(cfg, "rc:refresh_mode", r->refresh_mode);
+                mpp_enc_cfg_set_u32(cfg, "rc:refresh_num", r->refresh_num);
+                av_log(avctx, AV_LOG_VERBOSE, "Requested to use Intra Refresh, "
+                       "Mode/Num is set to %d/%d\n", r->refresh_mode, r->refresh_num);
+            }
         }
         break;
     case AV_CODEC_ID_MJPEG:
diff --git a/libavcodec/rkmppenc.h b/libavcodec/rkmppenc.h
index c5110b4a975..fd2e0014f2c 100644
--- a/libavcodec/rkmppenc.h
+++ b/libavcodec/rkmppenc.h
@@ -84,6 +84,9 @@ typedef struct RKMPPEncContext {
     int                udu_sei;
     int                prefix_mode;
     int                chroma_fmt;
+    int                intra_refresh;
+    int                refresh_mode;
+    int                refresh_num;
 } RKMPPEncContext;
 
 static const AVRational mpp_tb = { 1, 1000000 };
@@ -114,6 +117,14 @@ static const AVRational mpp_tb = { 1, 1000000 };
             { .i64 = -1 }, -1, 51, VE, "qp_max_i" }, \
     { "qp_min_i", "Set the min QP value for I frame", OFFSET(qp_min_i), AV_OPT_TYPE_INT, \
             { .i64 = -1 }, -1, 51, VE, "qp_min_i" }, \
+    { "intra_refresh", "Use Intra Refresh instead of IDR frames", OFFSET(intra_refresh), AV_OPT_TYPE_BOOL, \
+            { .i64 = 0 }, 0, 1, VE, "intra_refresh" }, \
+    { "refresh_mode", "Set the Intra Refresh mode", OFFSET(refresh_mode), AV_OPT_TYPE_INT, \
+            { .i64 = MPP_ENC_RC_INTRA_REFRESH_ROW }, MPP_ENC_RC_INTRA_REFRESH_ROW, MPP_ENC_RC_INTRA_REFRESH_COL, VE, "refresh_mode" }, \
+        { "row", "Refresh by MB row",    0, AV_OPT_TYPE_CONST, { .i64 = MPP_ENC_RC_INTRA_REFRESH_ROW }, 0, 0, VE, .unit = "refresh_mode" }, \
+        { "col", "Refresh by MB column", 0, AV_OPT_TYPE_CONST, { .i64 = MPP_ENC_RC_INTRA_REFRESH_COL }, 0, 0, VE, .unit = "refresh_mode" }, \
+    { "refresh_num", "Set how many MB rows or columns refresh each time", OFFSET(refresh_num), AV_OPT_TYPE_INT, \
+            { .i64 = 1 }, 1, INT_MAX, VE, "refresh_num" }, \
 
 static const AVOption h264_options[] = {
     RKMPP_ENC_COMMON_OPTS

From 7d0f880f0a6df483caebc2cd51eee92bbf6c7b2b Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Fri, 26 Sep 2025 21:10:27 +0800
Subject: [PATCH 102/103] fixup! lavc/rkmppenc: add support for enabling intra
 refresh (GDR)

enable recovery point SEI for intra refresh.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavcodec/rkmppenc.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
index 4ce1ef20193..0d662aeeace 100644
--- a/libavcodec/rkmppenc.c
+++ b/libavcodec/rkmppenc.c
@@ -632,7 +632,8 @@ static int rkmpp_set_enc_cfg(AVCodecContext *avctx)
 
     if (avctx->codec_id == AV_CODEC_ID_H264 ||
         avctx->codec_id == AV_CODEC_ID_HEVC) {
-        sei_mode = r->udu_sei ? MPP_ENC_SEI_MODE_ONE_FRAME : MPP_ENC_SEI_MODE_DISABLE;
+        sei_mode = (r->udu_sei || (r->intra_refresh && r->refresh_num))
+                   ? MPP_ENC_SEI_MODE_ONE_FRAME : MPP_ENC_SEI_MODE_DISABLE;
         if ((ret = r->mapi->control(r->mctx, MPP_ENC_SET_SEI_CFG, &sei_mode)) != MPP_OK) {
             av_log(avctx, AV_LOG_ERROR, "Failed to set SEI config: %d\n", ret);
             return AVERROR_EXTERNAL;

From cc5de845d52265dd25cea3738952d331708c2374 Mon Sep 17 00:00:00 2001
From: nyanmisaka <nst799610810@gmail.com>
Date: Sun, 19 Oct 2025 17:21:07 +0800
Subject: [PATCH 103/103] fixup! lavf/rkrga: add RKRGA scale, vpp and overlay
 filter

move "rga3 inverted RGB/BGR order in FBCE" fixup to the runtime.

Signed-off-by: nyanmisaka <nst799610810@gmail.com>
---
 libavfilter/rkrga_common.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libavfilter/rkrga_common.c b/libavfilter/rkrga_common.c
index c7b74a066fd..f308fd14ea8 100644
--- a/libavfilter/rkrga_common.c
+++ b/libavfilter/rkrga_common.c
@@ -678,6 +678,7 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
             goto exit;
         }
 
+#ifndef RGA_NORMAL_FBCE_RGB_BGR_FIXUP
         /* Inverted RGB/BGR order in FBCE */
         switch (info.rect.format) {
         case RK_FORMAT_RGBA_8888:
@@ -687,6 +688,7 @@ static RGAFrame *query_frame(RKRGAContext *r, AVFilterLink *outlink,
             info.rect.format = RK_FORMAT_RGBA_8888;
             break;
         }
+#endif
 
         info.rect.wstride = w_stride;
         info.rect.hstride = h_stride;
